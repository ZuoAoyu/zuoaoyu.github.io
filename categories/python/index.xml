<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Python on o5o</title><link>https://o5o.me/categories/python/</link><description>Recent content in Python on o5o</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Sat, 31 Dec 2022 18:28:02 +0800</lastBuildDate><atom:link href="https://o5o.me/categories/python/index.xml" rel="self" type="application/rss+xml"/><item><title>Think Python Exercise 10.6</title><link>https://o5o.me/post/think_python_exercise_10.6/</link><pubDate>Sat, 31 Dec 2022 18:28:02 +0800</pubDate><guid>https://o5o.me/post/think_python_exercise_10.6/</guid><description>如果可以通过重排一个单词中字母的顺序，得到另外一个单词，那么称这两个单词是变位词。编写一个叫做 is_anagram 的函数，接受两个字符串作为参数， 如果它们是变位词则返回 True 。
解答：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 def is_anagram(s1,s2): t1 = list(s1) t2 = list(s2) #先把字符串转换成列表 if len(t1) == len(t2): #如果两个字符串长度都不一样，那么肯定不是变位词了 t1.sort() t2.sort() #按照同样的方式重新排序后，如果二者元素对应相等，那么它们就是变位词了 for i in range(len(t1)): if t1[i] == t2[i]: pass else: return False return True else: return False is_anagram(&amp;#39;abc&amp;#39;,&amp;#39;bac&amp;#39;)</description></item><item><title>Think Python Exercise 10.5</title><link>https://o5o.me/post/think_python_exercise_10.5/</link><pubDate>Sat, 31 Dec 2022 17:50:04 +0800</pubDate><guid>https://o5o.me/post/think_python_exercise_10.5/</guid><description>编写一个叫做is_sorted的函数，接受一个列表作为参数，如果列表是递增排列的则返回 True ，否则返回False。 例如：
&amp;gt;&amp;gt;&amp;gt; is_sorted([1, 2, 2]) True &amp;gt;&amp;gt;&amp;gt; is_sorted([&amp;#39;b&amp;#39;, &amp;#39;a&amp;#39;]) False 分析：
可以先对列表用.sort()方法进行递增排列，如果递增排列后的列表和原列表的元素都对应相同，说明原列表本身就是递增排列的。
一个错误的写法：
1 2 3 4 5 6 7 8 9 def is_sorted(t): t_copy = t[:] print(t_copy) if t_copy == t.sort(): return True else: return False is_sorted([1, 2, 2]) 程序没有报错，但它仍是错的，因为，我们要比较的是两个列表里的元素对应相同，而不是看这两个变量是不是指向同一个列表。t_copy和t.sort()肯定不指向同一个列表，但它们的元素对应相同。因此我们不能用t_copy == t.sort()这样的方法来比较。可以这样做：
1 2 3 4 5 6 7 8 9 10 11 def is_sorted(t): t_copy = t[:] for i in range(len(t)): if t_copy[i] == t[i]: #如果递增排列后的列表和原列表的元素都对应相同，说明原列表本身就是递增排列的 pass else: return False return True is_sorted([1, 2, 2]) 还可以用另一种方法实现：</description></item><item><title>Think Python Exercise 10.4</title><link>https://o5o.me/post/think_python_exercise_10.4/</link><pubDate>Sat, 31 Dec 2022 17:29:11 +0800</pubDate><guid>https://o5o.me/post/think_python_exercise_10.4/</guid><description>编写一个叫做 chop 的函数，接受一个列表作为参数，移除第一个和最后一个元素，并返回None。例如：
&amp;gt;&amp;gt;&amp;gt; t = [1, 2, 3, 4] &amp;gt;&amp;gt;&amp;gt; chop(t) &amp;gt;&amp;gt;&amp;gt; t [2, 3] 分析：
一顿操作猛如虎：（错的）
1 2 3 4 5 6 7 8 def chop(t): t = t[1:-1] t1 = [1, 2, 3, 4] chop(t1) t1 为什么t1没变化？是我列表切片用错了吗，再试试：（还是错的）
1 2 3 4 5 6 7 8 def chop(t): t = t[1:len(t)-2] t1 = [1, 2, 3, 4] chop(t1) t1 可以看到，t1还是没变化，为什么？为什么这样是错的？
不要被迷惑了，当一个列表t1传递给一个函数时，t1和形参t共同指向同一个列表，但当函数内部t重新赋值后，t指向了一个新的列表，而t1依然指向原来的列表，那么当函数运行结束后，t1的值当然还是原来的啦。
由于题目要求函数不能有返回值，可以使用下面的做法：
1 2 3 4 5 6 7 8 9 def chop(t): del t[0] del t[-1] t1 = [1, 2, 3, 4] chop(t1) t1 如果函数可以有返回值，可以这样写：</description></item><item><title>Think Python Exercise 10.3</title><link>https://o5o.me/post/think_python_exercise_10.3/</link><pubDate>Sat, 31 Dec 2022 16:59:00 +0800</pubDate><guid>https://o5o.me/post/think_python_exercise_10.3/</guid><description>编写一个函数，读取文件 words.txt ，建立一个列表,其中每个单词为一个元素。
编写两个版本，一个使用 append 方法，另一个使用 t = t + [x] 。那个版本运行得慢？为什么？
解答：
在 jupyter 中的一个代码单元（cell）中，代码第一行写上%%time或%%timeit，即可计算代码的运行时间。
版本1：
1 2 3 4 5 6 7 8 9 10 11 12 %%time def read_word1(file_in): word_list = [] for line in file_in: word = line.strip() word_list.append(word) return word_list fin = open(&amp;#39;words.txt&amp;#39;) a = read_word1(fin) 运行结果：
CPU times: user 85.3 ms, sys: 0 ns, total: 85.3 ms Wall time: 88.4 ms
版本2：
1 2 3 4 5 6 7 8 9 10 11 12 %%time def read_word2(file_in): word_list = [] for line in file_in: word = line.</description></item><item><title>Think Python Exercise 10.2</title><link>https://o5o.me/post/think_python_exercise_10.2/</link><pubDate>Sat, 31 Dec 2022 16:42:52 +0800</pubDate><guid>https://o5o.me/post/think_python_exercise_10.2/</guid><description>编写一个叫做 cumsum 的函数，接受一个由数值组成的列表，并返回累加和；即一个新列表，其中第i个元素是原列表中前i+1个元素的和（注意i是从0开始的）。 例如：
&amp;gt;&amp;gt;&amp;gt; t = [1, 2, 3] &amp;gt;&amp;gt;&amp;gt; cumsum(t) [1, 3, 6] 解答：
1 2 3 4 5 6 7 8 9 10 11 12 def cumsum(t): numsum = [] for i in range(len(t)): numsum.append(sum(t[:i+1])) #对t的前i+1个元素求和（注意i是从0开始，所以第i个元素是第i+1个元素），然后追加到新列表里 return numsum t = [1, 2, 3] print(cumsum(t)) t = [3,3,6,9,10] print(cumsum(t))</description></item><item><title>Think Python Exercise 10.1</title><link>https://o5o.me/post/think_python_exercise_10.1/</link><pubDate>Sat, 31 Dec 2022 16:22:37 +0800</pubDate><guid>https://o5o.me/post/think_python_exercise_10.1/</guid><description>编写一个叫做 nested_sum 的函数，接受一个由一些整数列表构成的列表作为参数，并将所有嵌套列表中的元素相加。例如：
&amp;gt;&amp;gt;&amp;gt; t = [[1, 2], [3], [4, 5, 6]] &amp;gt;&amp;gt;&amp;gt; nested_sum(t) 21 解答：
可以分别对每个子列表求和，再对得到的各个和求和。也可以先把各个子列表合并起来，然后对得到的列表求和。
1 2 3 4 5 6 7 8 9 def nested_sum(t): c = [] for i in t: c = c + i #把t列表里的各个列表合并成一个列表 return sum(c) t = [[1, 2], [3], [4, 5, 6]] nested_sum(t)</description></item><item><title>Think Python Exercise 9.6</title><link>https://o5o.me/post/think_python_exercise_9.6/</link><pubDate>Thu, 29 Dec 2022 17:45:12 +0800</pubDate><guid>https://o5o.me/post/think_python_exercise_9.6/</guid><description>编写一个名为is_abecedarian 的函数, 如果单词中的字符以字符表的顺序出现 (允许重复字符),则返回True。有多少个具备这种特征的单词?
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 def word_abcde(word): alphabets = &amp;#34;abcdefghijklmnopqrstuvwxyz&amp;#34; i = 0 front = 0 #前一个字母的序数 mine = 0 #当前字母的序数 while i &amp;lt; len(word): index = 0 while index &amp;lt; len(alphabets): # print(i,word[i],index,alphabets[index]) if word[i] == alphabets[index]: mine = index if mine &amp;lt; front: return False else: front = mine break index += 1 i += 1 return True def is_abecedarian(file_in): count = 0 for line in file_in: word = line.</description></item><item><title>Think Python Exercise 9.5</title><link>https://o5o.me/post/think_python_exercise_9.5/</link><pubDate>Thu, 29 Dec 2022 16:05:12 +0800</pubDate><guid>https://o5o.me/post/think_python_exercise_9.5/</guid><description>编写一个名为uses_all的函数,接受一个单词和一个必须使用的字符组成的字符串。如果该单词包括此字符串中的全部字符至少一次,则返回True。你能统计出多少单词包含了所有的元音字符aeiou吗?如果换成aeiouy 呢?
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 def uses_all(word, muststr): for i in muststr: count = 0 index = 0 while index &amp;lt; len(word): if i == word[index]: break index += 1 if index == len(word): return False return True def count_word(file_in, als): count = 0 for line in file_in: word = line.</description></item><item><title>Think Python Exercise 9.4</title><link>https://o5o.me/post/think_python_exercise_9.4/</link><pubDate>Thu, 29 Dec 2022 15:30:12 +0800</pubDate><guid>https://o5o.me/post/think_python_exercise_9.4/</guid><description>编写一个名为 avoids 的函数，接受一个单词和一个指定禁止使用字符的字符串，如果单词中不包含任意被禁止的字符，则返回True 。
修改你的程序，提示用户输入一个禁止使用的字符，然后打印不包含这些字符的单词的数量。你能找到一个5个禁止使用字符的组合，使得其排除的单词数目最少么？
你能找到一个&amp;quot;5个禁止使用字符&amp;quot;的组合，使得其排除的单词数目最少么？ 分析：从26个字母中挑选5个字母构成一个组合，打印不包含这些字母的单词的数量，看哪个组合下被排除出去的单词数目最少。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 def avoids(word,ause): #ause，avoid use for i in ause: for letter in word: if letter == i: return False return True def has_no_string(file_in, nals): #nals指的是no alphabets，字母 count_nals = 0 #不含用户指定的各个字符的单词的个数 for line in file_in: word = line.strip() if avoids(word,nals): count_nals += 1 print(&amp;#34;不含&amp;#34;,nals,&amp;#34;的单词有&amp;#34;,count_nals,&amp;#34;个&amp;#34;) text = input(&amp;#34;请输入一个禁止使用的字符串，字符串里的字母都不会出现在单词中\n&amp;#34;) fin = open(&amp;#39;words.</description></item><item><title>Think Python Exercise 9.3</title><link>https://o5o.me/post/think_python_exercise_9.3/</link><pubDate>Thu, 29 Dec 2022 15:28:12 +0800</pubDate><guid>https://o5o.me/post/think_python_exercise_9.3/</guid><description>编写一个名为 avoids 的函数，接受一个单词和一个指定禁止使用字符的字符串，如果单词中不包含任意被禁止的字符，则返回True 。
修改你的程序，提示用户输入一个禁止使用的字符，然后打印不包含这些字符的单词的数量。你能找到一个5个禁止使用字符的组合，使得其排除的单词数目最少么？
你能找到一个&amp;quot;5个禁止使用字符&amp;quot;的组合，使得其排除的单词数目最少么？ 分析：从26个字母中挑选5个字母构成一个组合，打印不包含这些字母的单词的数量，看哪个组合下被排除出去的单词数目最少。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 def avoids(word,ause): #ause，avoid use for i in ause: for letter in word: if letter == i: return False return True def has_no_string(file_in, nals): #nals指的是no alphabets，字母 count_nals = 0 #不含用户指定的各个字符的单词的个数 for line in file_in: word = line.strip() if avoids(word,nals): count_nals += 1 print(&amp;#34;不含&amp;#34;,nals,&amp;#34;的单词有&amp;#34;,count_nals,&amp;#34;个&amp;#34;) text = input(&amp;#34;请输入一个禁止使用的字符串，字符串里的字母都不会出现在单词中\n&amp;#34;) fin = open(&amp;#39;words.</description></item><item><title>Think Python Exercise 9.2</title><link>https://o5o.me/post/think_python_exercise_9.2/</link><pubDate>Thu, 29 Dec 2022 15:27:12 +0800</pubDate><guid>https://o5o.me/post/think_python_exercise_9.2/</guid><description>1939年，Ernest Vincent Wright出版了一本名为 《Gadsby》 的小说，该小说里完全没有使用字符“e”。由于“e”是最常用的英文字符，因此这并不容易做到。
事实上，不使用这个最常用的符号(字符e)来构建一个孤立的想法是很难的。开始进展缓慢，但是经过有意识的、长时间的训练，你可以逐渐地熟练。
好啦，不再说题外话了（让我们开始编程练习）。
写一个叫做has_no_e的函数，如果给定的单词中不包含字符“e”，其返回 True 。
修改上一节中的程序，只打印不包含“e”的单词，并且计算列表中不含“e”单词的比例。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 fin = open(&amp;#39;words.txt&amp;#39;) def has_no_e(file_in): count_ne = 0 #不含e的单词的个数 count = 0 #总单词个数 for line in file_in: word = line.strip() index = 0 while index &amp;lt; len(word): if word[index] == &amp;#39;e&amp;#39;: break else: index = index + 1 if index == len(word): # print(word) #因为单词比较多，不一个个列出来了 count_ne = count_ne + 1 count = count + 1 print(&amp;#34;不含e的单词有&amp;#34;,count_ne,&amp;#34;个&amp;#34;,&amp;#34;单词一共有&amp;#34;,count,&amp;#34;个&amp;#34;,&amp;#34;不含“e”单词的比例为&amp;#34;,count_ne/count*100,&amp;#34;%&amp;#34;) has_no_e(fin) 上面是一个字母一个字母判断单词是不是包含‘e’的，下面是在 if 中使用 in 操作符简化后的方案：</description></item><item><title>Think Python Exercise 9.1</title><link>https://o5o.me/post/think_python_exercise_9.1/</link><pubDate>Wed, 28 Dec 2022 21:48:12 +0800</pubDate><guid>https://o5o.me/post/think_python_exercise_9.1/</guid><description>编程写一个程序，使得它可以读取 words.txt　，然后只打印出那些长度超过20个字符的单词(不包括空格)。
1 2 3 4 5 6 fin = open(&amp;#39;words.txt&amp;#39;) for line in fin: word = line.strip() if len(word) &amp;gt; 20: print(word)</description></item></channel></rss>