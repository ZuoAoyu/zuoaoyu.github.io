<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Python on o5o</title><link>https://o5o.me/categories/python/</link><description>Recent content in Python on o5o</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Mon, 02 Jan 2023 21:29:30 +0800</lastBuildDate><atom:link href="https://o5o.me/categories/python/index.xml" rel="self" type="application/rss+xml"/><item><title>Think Python Exercise 10.10</title><link>https://o5o.me/post/think_python_exercise_10.10/</link><pubDate>Mon, 02 Jan 2023 21:29:30 +0800</pubDate><guid>https://o5o.me/post/think_python_exercise_10.10/</guid><description>使用in运算符可以检查一个单词是否在单词表中, 但这很慢, 因为它是按顺序查找单词。
由于单词是按照字母顺序排序的,我们可以使用两分法 (也称二叉树搜索) 来加快速度, 类似于在字典中查找单词的方法。你从中间开始,如果你要找的单词在中间的单词之前,你查找前半部分,否则你查找后半部分。
不管怎样, 你都会将搜索范围减小一半。 如果单词表有 113,809 个单词, 你只需要 17 步就可以找到这个单词,或着得出单词不存在的结论。
编写一个叫做in_bisect的函数,接受一个已排序的列表和一个目标值作为参数,返回该值在列表中的位置,如果不存在则返回None。
或者你可以阅读bisect模块的文档并使用它!
解答：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 def in_bisect(t,a): s1 = int((len(t))/2) s = s1 #如果a在列表内，s保存a的下标 while s1 &amp;gt; 0: if a == t[s1]: return s elif a &amp;gt; t[s1]: t = t[s1:] s1 = int(len(t)/2) #在循环过程中，确保s和s1所指的是同一个元素。 #print(a,&amp;#34;的位置大于&amp;#34;,s) s += s1 else: t = t[:s1] s1 = int(len(t)/2) #print(a,&amp;#34;的位置小于等于&amp;#34;,s) s -= s1 return None t1 = [&amp;#39;a&amp;#39;,&amp;#39;b&amp;#39;,&amp;#39;c&amp;#39;,&amp;#39;d&amp;#39;,&amp;#39;e&amp;#39;,&amp;#39;f&amp;#39;,&amp;#39;g&amp;#39;,&amp;#39;h&amp;#39;,&amp;#39;i&amp;#39;,&amp;#39;j&amp;#39;,&amp;#39;k&amp;#39;,&amp;#39;l&amp;#39;,&amp;#39;m&amp;#39;,&amp;#39;n&amp;#39;,&amp;#39;o&amp;#39;,&amp;#39;p&amp;#39;,&amp;#39;q&amp;#39;] in_bisect(t1,&amp;#39;c&amp;#39;) s和s1这两个变量，保存的是列表元素的下标。在循环过程中，确保s和s1所指的是同一个元素，即：s保存的是元素在完整列表里的下标，s1保存的是元素在切片后的列表里的下标，在两个列表里，第s个元素和第s1个元素（都从0开始）是同一个元素。</description></item><item><title>Think Python Exercise 10.3</title><link>https://o5o.me/post/think_python_exercise_10.3/</link><pubDate>Mon, 02 Jan 2023 21:22:48 +0800</pubDate><guid>https://o5o.me/post/think_python_exercise_10.3/</guid><description>编写一个叫做middle的函数,接受一个列表作为参数,并返回一个除了第一个和最后一个元素的列表。例如:
&amp;gt;&amp;gt;&amp;gt; t = [1, 2, 3, 4] &amp;gt;&amp;gt;&amp;gt; middle(t) [2, 3] 解答：
1 2 3 4 5 def middle(t): return t[1:-1] t1 = [1,2,3,4] middle(t1)</description></item><item><title>Think Python Exercise 10.7</title><link>https://o5o.me/post/think_python_exercise_10.7/</link><pubDate>Mon, 02 Jan 2023 20:31:00 +0800</pubDate><guid>https://o5o.me/post/think_python_exercise_10.7/</guid><description>编写一个叫做 has_duplicates 的函数，接受一个列表作为参数，如果一个元素在列表中出现了不止一次，则返回 True 。这个函数不能改变原列表。
解答：
1 2 3 4 5 6 7 8 9 10 11 12 def has_duplicates(t): p = [] for i in t: if i not in p: p.append(i) else: return False return True t1 = [1,2,3] has_duplicates(t1)</description></item><item><title>Think Python Exercise 4.1</title><link>https://o5o.me/post/think_python_exercise_4.1/</link><pubDate>Sun, 01 Jan 2023 18:23:34 +0800</pubDate><guid>https://o5o.me/post/think_python_exercise_4.1/</guid><description>画一个执行 circle(bob,radius) 时的堆栈图（stack diagram），说明程序的各个状态。你可以手动进行计算，也可以在代码中加入打印语句。 “重构”一节中给出的 arc 函数版本并不太精确，因为圆形的线性近似（linear approximation）永远处在真正的圆形之外。因此，Turtle 总是和正确的终点相差几个像素。我的答案中展示了降低这个错误影响的一种方法。阅读其中的代码，看看你是否能够理解。如果你画一个堆栈图的话，你可能会更容易明白背后的原理。 先放上代码，得到代码过程可以看Think Python Exercise 4.0。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 import turtle import math def polyline(t,length,n,angle): for i in range(n): t.fd(length) t.lt(angle) def arc(t,r,angle): &amp;#34;&amp;#34;&amp;#34;angle取值范围是1~360，度数。 画出圆的一部分。 &amp;#34;&amp;#34;&amp;#34; arc_length = 2 * math.pi * r * angle / 360 n = int(arc_length / 3) + 1 step_length = arc_length / n step_angle = angle / n polyline(t,step_length,n,step_angle) def circle(t,r): arc(t,r,360) #circle是arc函数在角度angle取360时的特例 bob = turtle.</description></item><item><title>Think Python Exercise 4.0</title><link>https://o5o.me/post/think_python_exercise_4.0/</link><pubDate>Sun, 01 Jan 2023 16:04:43 +0800</pubDate><guid>https://o5o.me/post/think_python_exercise_4.0/</guid><description>写一个名为 square 的函数，接受一个名为 t 的形参，t 是一个海龟。这个函数应用这只海龟画一个正方形。 写一个函数调用，将 bob 作为实参传给 square ，然后再重新运行程序。
1 2 3 4 5 6 7 8 9 10 11 12 import turtle def square(t): for i in range(4): t.fd(100) t.lt(90) bob = turtle.Turtle() square(bob) turtle.mainloop() 给 square 增加另一个名为 length 的形参。修改函数体，使得正方形边的长度是 length ，然后修改函数调用，提供第二个实参。 重新运行程序。用一系列 length 值测试你的程序。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import turtle def square(t,length): for i in range(4): t.</description></item><item><title>Think Python Exercise 5.4</title><link>https://o5o.me/post/think_python_exercise_5.4/</link><pubDate>Sun, 01 Jan 2023 13:04:59 +0800</pubDate><guid>https://o5o.me/post/think_python_exercise_5.4/</guid><description>下面程序的输出是什么？画出展示程序每次打印输出时的堆栈图。
1 2 3 4 5 6 7 def recurse(n, s): if n == 0: print(s) else: recurse(n-1, n+s) recurse(3, 0) 如果你这样调用函数： recurse(-1,0) ，会有什么结果？ 请写一个文档字符串，解释调用该函数时需要了解的全部信息（仅此而已）。 解答：
我用obsidian的Excalidraw插件画了一个。
如果这样调用函数： recurse(-1,0)，Python会抛出一个递归错误：超过最大递归深度。
&amp;gt;&amp;gt;&amp;gt; recurse(-1,0) Traceback (most recent call last): File &amp;#34;&amp;lt;stdin&amp;gt;&amp;#34;, line 1, in &amp;lt;module&amp;gt; File &amp;#34;&amp;lt;stdin&amp;gt;&amp;#34;, line 5, in recurse File &amp;#34;&amp;lt;stdin&amp;gt;&amp;#34;, line 5, in recurse File &amp;#34;&amp;lt;stdin&amp;gt;&amp;#34;, line 5, in recurse [Previous line repeated 996 more times] RecursionError: maximum recursion depth exceeded 写一个文档字符串，解释调用该函数时需要了解的全部信息</description></item><item><title>Think Python Exercise 10.6</title><link>https://o5o.me/post/think_python_exercise_10.6/</link><pubDate>Sat, 31 Dec 2022 18:28:02 +0800</pubDate><guid>https://o5o.me/post/think_python_exercise_10.6/</guid><description>如果可以通过重排一个单词中字母的顺序，得到另外一个单词，那么称这两个单词是变位词。编写一个叫做 is_anagram 的函数，接受两个字符串作为参数， 如果它们是变位词则返回 True 。
解答：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 def is_anagram(s1,s2): t1 = list(s1) t2 = list(s2) #先把字符串转换成列表 if len(t1) == len(t2): #如果两个字符串长度都不一样，那么肯定不是变位词了 t1.sort() t2.sort() #按照同样的方式重新排序后，如果二者元素对应相等，那么它们就是变位词了 for i in range(len(t1)): if t1[i] == t2[i]: pass else: return False return True else: return False is_anagram(&amp;#39;abc&amp;#39;,&amp;#39;bac&amp;#39;)</description></item><item><title>Think Python Exercise 10.5</title><link>https://o5o.me/post/think_python_exercise_10.5/</link><pubDate>Sat, 31 Dec 2022 17:50:04 +0800</pubDate><guid>https://o5o.me/post/think_python_exercise_10.5/</guid><description>编写一个叫做is_sorted的函数，接受一个列表作为参数，如果列表是递增排列的则返回 True ，否则返回False。 例如：
&amp;gt;&amp;gt;&amp;gt; is_sorted([1, 2, 2]) True &amp;gt;&amp;gt;&amp;gt; is_sorted([&amp;#39;b&amp;#39;, &amp;#39;a&amp;#39;]) False 分析：
可以先对列表用.sort()方法进行递增排列，如果递增排列后的列表和原列表的元素都对应相同，说明原列表本身就是递增排列的。
一个错误的写法：
1 2 3 4 5 6 7 8 9 def is_sorted(t): t_copy = t[:] print(t_copy) if t_copy == t.sort(): return True else: return False is_sorted([1, 2, 2]) 程序没有报错，但它仍是错的，因为，我们要比较的是两个列表里的元素对应相同，而不是看这两个变量是不是指向同一个列表。t_copy和t.sort()肯定不指向同一个列表，但它们的元素对应相同。因此我们不能用t_copy == t.sort()这样的方法来比较。可以这样做：
1 2 3 4 5 6 7 8 9 10 11 def is_sorted(t): t_copy = t[:] for i in range(len(t)): if t_copy[i] == t[i]: #如果递增排列后的列表和原列表的元素都对应相同，说明原列表本身就是递增排列的 pass else: return False return True is_sorted([1, 2, 2]) 还可以用另一种方法实现：从第二个元素开始，依次和前面一个元素比较大小。</description></item><item><title>Think Python Exercise 10.4</title><link>https://o5o.me/post/think_python_exercise_10.4/</link><pubDate>Sat, 31 Dec 2022 17:29:11 +0800</pubDate><guid>https://o5o.me/post/think_python_exercise_10.4/</guid><description>编写一个叫做 chop 的函数，接受一个列表作为参数，移除第一个和最后一个元素，并返回None。例如：
&amp;gt;&amp;gt;&amp;gt; t = [1, 2, 3, 4] &amp;gt;&amp;gt;&amp;gt; chop(t) &amp;gt;&amp;gt;&amp;gt; t [2, 3] 分析：
一顿操作猛如虎：（错的）
1 2 3 4 5 6 7 8 def chop(t): t = t[1:-1] t1 = [1, 2, 3, 4] chop(t1) t1 为什么t1没变化？是我列表切片用错了吗，再试试：（还是错的）
1 2 3 4 5 6 7 8 def chop(t): t = t[1:len(t)-2] t1 = [1, 2, 3, 4] chop(t1) t1 可以看到，t1还是没变化，为什么？为什么这样是错的？
不要被迷惑了，当一个列表t1传递给一个函数时，t1和形参t共同指向同一个列表，但当函数内部t重新赋值后，t指向了一个新的列表，而t1依然指向原来的列表，那么当函数运行结束后，t1的值当然还是原来的啦。
由于题目要求函数不能有返回值，可以使用下面的做法：
1 2 3 4 5 6 7 8 9 def chop(t): del t[0] del t[-1] t1 = [1, 2, 3, 4] chop(t1) t1 如果函数可以有返回值，可以这样写：</description></item><item><title>Think Python Exercise 10.9</title><link>https://o5o.me/post/think_python_exercise_10.9/</link><pubDate>Sat, 31 Dec 2022 16:59:00 +0800</pubDate><guid>https://o5o.me/post/think_python_exercise_10.9/</guid><description>编写一个函数，读取文件 words.txt ，建立一个列表,其中每个单词为一个元素。
编写两个版本，一个使用 append 方法，另一个使用 t = t + [x] 。那个版本运行得慢？为什么？
解答：
在 jupyter 中的一个代码单元（cell）中，代码第一行写上%%time或%%timeit，即可计算代码的运行时间。
版本1：
1 2 3 4 5 6 7 8 9 10 11 12 %%time def read_word1(file_in): word_list = [] for line in file_in: word = line.strip() word_list.append(word) return word_list fin = open(&amp;#39;words.txt&amp;#39;) a = read_word1(fin) 运行结果：
CPU times: user 85.3 ms, sys: 0 ns, total: 85.3 ms Wall time: 88.4 ms
版本2：
1 2 3 4 5 6 7 8 9 10 11 12 %%time def read_word2(file_in): word_list = [] for line in file_in: word = line.</description></item><item><title>Think Python Exercise 10.2</title><link>https://o5o.me/post/think_python_exercise_10.2/</link><pubDate>Sat, 31 Dec 2022 16:42:52 +0800</pubDate><guid>https://o5o.me/post/think_python_exercise_10.2/</guid><description>编写一个叫做 cumsum 的函数，接受一个由数值组成的列表，并返回累加和；即一个新列表，其中第i个元素是原列表中前i+1个元素的和（注意i是从0开始的）。 例如：
&amp;gt;&amp;gt;&amp;gt; t = [1, 2, 3] &amp;gt;&amp;gt;&amp;gt; cumsum(t) [1, 3, 6] 解答：
1 2 3 4 5 6 7 8 9 10 11 12 def cumsum(t): numsum = [] for i in range(len(t)): numsum.append(sum(t[:i+1])) #对t的前i+1个元素求和（注意i是从0开始，所以第i个元素是第i+1个元素），然后追加到新列表里 return numsum t = [1, 2, 3] print(cumsum(t)) t = [3,3,6,9,10] print(cumsum(t))</description></item><item><title>Think Python Exercise 10.1</title><link>https://o5o.me/post/think_python_exercise_10.1/</link><pubDate>Sat, 31 Dec 2022 16:22:37 +0800</pubDate><guid>https://o5o.me/post/think_python_exercise_10.1/</guid><description>编写一个叫做 nested_sum 的函数，接受一个由一些整数列表构成的列表作为参数，并将所有嵌套列表中的元素相加。例如：
&amp;gt;&amp;gt;&amp;gt; t = [[1, 2], [3], [4, 5, 6]] &amp;gt;&amp;gt;&amp;gt; nested_sum(t) 21 解答：
可以分别对每个子列表求和，再对得到的各个和求和。也可以先把各个子列表合并起来，然后对得到的列表求和。
1 2 3 4 5 6 7 8 9 def nested_sum(t): c = [] for i in t: c = c + i #把t列表里的各个列表合并成一个列表 return sum(c) t = [[1, 2], [3], [4, 5, 6]] nested_sum(t)</description></item><item><title>Think Python Exercise 9.6</title><link>https://o5o.me/post/think_python_exercise_9.6/</link><pubDate>Thu, 29 Dec 2022 17:45:12 +0800</pubDate><guid>https://o5o.me/post/think_python_exercise_9.6/</guid><description>编写一个名为is_abecedarian 的函数, 如果单词中的字符以字符表的顺序出现 (允许重复字符),则返回True。有多少个具备这种特征的单词?
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 def word_abcde(word): alphabets = &amp;#34;abcdefghijklmnopqrstuvwxyz&amp;#34; i = 0 front = 0 #前一个字母的序数 mine = 0 #当前字母的序数 while i &amp;lt; len(word): index = 0 while index &amp;lt; len(alphabets): # print(i,word[i],index,alphabets[index]) if word[i] == alphabets[index]: mine = index if mine &amp;lt; front: return False else: front = mine break index += 1 i += 1 return True def is_abecedarian(file_in): count = 0 for line in file_in: word = line.</description></item><item><title>Think Python Exercise 9.5</title><link>https://o5o.me/post/think_python_exercise_9.5/</link><pubDate>Thu, 29 Dec 2022 16:05:12 +0800</pubDate><guid>https://o5o.me/post/think_python_exercise_9.5/</guid><description>编写一个名为uses_all的函数,接受一个单词和一个必须使用的字符组成的字符串。如果该单词包括此字符串中的全部字符至少一次,则返回True。你能统计出多少单词包含了所有的元音字符aeiou吗?如果换成aeiouy 呢?
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 def uses_all(word, muststr): for i in muststr: count = 0 index = 0 while index &amp;lt; len(word): if i == word[index]: break index += 1 if index == len(word): return False return True def count_word(file_in, als): count = 0 for line in file_in: word = line.</description></item><item><title>Think Python Exercise 9.4</title><link>https://o5o.me/post/think_python_exercise_9.4/</link><pubDate>Thu, 29 Dec 2022 15:30:12 +0800</pubDate><guid>https://o5o.me/post/think_python_exercise_9.4/</guid><description>编写一个名为 avoids 的函数，接受一个单词和一个指定禁止使用字符的字符串，如果单词中不包含任意被禁止的字符，则返回True 。
修改你的程序，提示用户输入一个禁止使用的字符，然后打印不包含这些字符的单词的数量。你能找到一个5个禁止使用字符的组合，使得其排除的单词数目最少么？
你能找到一个&amp;quot;5个禁止使用字符&amp;quot;的组合，使得其排除的单词数目最少么？ 分析：从26个字母中挑选5个字母构成一个组合，打印不包含这些字母的单词的数量，看哪个组合下被排除出去的单词数目最少。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 def avoids(word,ause): #ause，avoid use for i in ause: for letter in word: if letter == i: return False return True def has_no_string(file_in, nals): #nals指的是no alphabets，字母 count_nals = 0 #不含用户指定的各个字符的单词的个数 for line in file_in: word = line.strip() if avoids(word,nals): count_nals += 1 print(&amp;#34;不含&amp;#34;,nals,&amp;#34;的单词有&amp;#34;,count_nals,&amp;#34;个&amp;#34;) text = input(&amp;#34;请输入一个禁止使用的字符串，字符串里的字母都不会出现在单词中\n&amp;#34;) fin = open(&amp;#39;words.</description></item><item><title>Think Python Exercise 9.3</title><link>https://o5o.me/post/think_python_exercise_9.3/</link><pubDate>Thu, 29 Dec 2022 15:28:12 +0800</pubDate><guid>https://o5o.me/post/think_python_exercise_9.3/</guid><description>编写一个名为 avoids 的函数，接受一个单词和一个指定禁止使用字符的字符串，如果单词中不包含任意被禁止的字符，则返回True 。
修改你的程序，提示用户输入一个禁止使用的字符，然后打印不包含这些字符的单词的数量。你能找到一个5个禁止使用字符的组合，使得其排除的单词数目最少么？
你能找到一个&amp;quot;5个禁止使用字符&amp;quot;的组合，使得其排除的单词数目最少么？ 分析：从26个字母中挑选5个字母构成一个组合，打印不包含这些字母的单词的数量，看哪个组合下被排除出去的单词数目最少。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 def avoids(word,ause): #ause，avoid use for i in ause: for letter in word: if letter == i: return False return True def has_no_string(file_in, nals): #nals指的是no alphabets，字母 count_nals = 0 #不含用户指定的各个字符的单词的个数 for line in file_in: word = line.strip() if avoids(word,nals): count_nals += 1 print(&amp;#34;不含&amp;#34;,nals,&amp;#34;的单词有&amp;#34;,count_nals,&amp;#34;个&amp;#34;) text = input(&amp;#34;请输入一个禁止使用的字符串，字符串里的字母都不会出现在单词中\n&amp;#34;) fin = open(&amp;#39;words.</description></item><item><title>Think Python Exercise 9.2</title><link>https://o5o.me/post/think_python_exercise_9.2/</link><pubDate>Thu, 29 Dec 2022 15:27:12 +0800</pubDate><guid>https://o5o.me/post/think_python_exercise_9.2/</guid><description>1939年，Ernest Vincent Wright出版了一本名为 《Gadsby》 的小说，该小说里完全没有使用字符“e”。由于“e”是最常用的英文字符，因此这并不容易做到。
事实上，不使用这个最常用的符号(字符e)来构建一个孤立的想法是很难的。开始进展缓慢，但是经过有意识的、长时间的训练，你可以逐渐地熟练。
好啦，不再说题外话了（让我们开始编程练习）。
写一个叫做has_no_e的函数，如果给定的单词中不包含字符“e”，其返回 True 。
修改上一节中的程序，只打印不包含“e”的单词，并且计算列表中不含“e”单词的比例。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 fin = open(&amp;#39;words.txt&amp;#39;) def has_no_e(file_in): count_ne = 0 #不含e的单词的个数 count = 0 #总单词个数 for line in file_in: word = line.strip() index = 0 while index &amp;lt; len(word): if word[index] == &amp;#39;e&amp;#39;: break else: index = index + 1 if index == len(word): # print(word) #因为单词比较多，不一个个列出来了 count_ne = count_ne + 1 count = count + 1 print(&amp;#34;不含e的单词有&amp;#34;,count_ne,&amp;#34;个&amp;#34;,&amp;#34;单词一共有&amp;#34;,count,&amp;#34;个&amp;#34;,&amp;#34;不含“e”单词的比例为&amp;#34;,count_ne/count*100,&amp;#34;%&amp;#34;) has_no_e(fin) 上面是一个字母一个字母判断单词是不是包含‘e’的，下面是在 if 中使用 in 操作符简化后的方案：</description></item><item><title>Think Python Exercise 9.1</title><link>https://o5o.me/post/think_python_exercise_9.1/</link><pubDate>Wed, 28 Dec 2022 21:48:12 +0800</pubDate><guid>https://o5o.me/post/think_python_exercise_9.1/</guid><description>编程写一个程序，使得它可以读取 words.txt　，然后只打印出那些长度超过20个字符的单词(不包括空格)。
1 2 3 4 5 6 fin = open(&amp;#39;words.txt&amp;#39;) for line in fin: word = line.strip() if len(word) &amp;gt; 20: print(word)</description></item></channel></rss>