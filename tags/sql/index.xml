<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>SQL on o5o</title><link>https://o5o.me/tags/sql/</link><description>Recent content in SQL on o5o</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Tue, 31 Jan 2023 20:59:00 +0800</lastBuildDate><atom:link href="https://o5o.me/tags/sql/index.xml" rel="self" type="application/rss+xml"/><item><title>Leetcode 183 从不订购的客户</title><link>https://o5o.me/post/leetcode_183_customers_who_never_order/</link><pubDate>Tue, 31 Jan 2023 20:59:00 +0800</pubDate><guid>https://o5o.me/post/leetcode_183_customers_who_never_order/</guid><description>题目：183. 从不订购的客户
我的解答 1 2 3 4 5 SELECT Name AS Customers FROM Customers WHERE NOT ID IN ( SELECT CustomerId FROM Orders);</description></item><item><title>Leetcode 182 查找重复的电子邮箱</title><link>https://o5o.me/post/leetcode_182_duplicate_emails/</link><pubDate>Tue, 31 Jan 2023 20:53:00 +0800</pubDate><guid>https://o5o.me/post/leetcode_182_duplicate_emails/</guid><description>题目：182. 查找重复的电子邮箱
我的解答 1 2 3 4 5 6 7 8 # Write your MySQL query statement below SELECT name AS Employee FROM ( SELECT a.name AS name, a.salary AS mySalary, b.salary AS manaSalary FROM Employee a, Employee b WHERE a.managerId = b.id ) as b WHERE mySalary &amp;gt; manaSalary; 更好的答案：
自联结 1 2 3 4 SELECT e1.name AS Employee FROM Employee AS e1, Employee AS e2 WHERE e1.managerID = e2.</description></item><item><title>Leetcode 181 超过经理收入的员工</title><link>https://o5o.me/post/leetcode_181_employees_earning_more_than-their_managers/</link><pubDate>Tue, 31 Jan 2023 20:34:00 +0800</pubDate><guid>https://o5o.me/post/leetcode_181_employees_earning_more_than-their_managers/</guid><description>题目：181. 超过经理收入的员工
我的解答 1 2 3 4 5 6 7 8 # Write your MySQL query statement below SELECT name AS Employee FROM ( SELECT a.name AS name, a.salary AS mySalary, b.salary AS manaSalary FROM Employee a, Employee b WHERE a.managerId = b.id ) as b WHERE mySalary &amp;gt; manaSalary; 更好的答案：
自联结 1 2 3 4 SELECT e1.name AS Employee FROM Employee AS e1, Employee AS e2 WHERE e1.managerID = e2.</description></item><item><title>Leetcode 180 连续出现的数字</title><link>https://o5o.me/post/leetcode_180_consecutive_numbers/</link><pubDate>Tue, 31 Jan 2023 20:12:00 +0800</pubDate><guid>https://o5o.me/post/leetcode_180_consecutive_numbers/</guid><description>题目：180. 连续出现的数字
我的解答 使用变量
1 2 3 4 5 6 7 8 9 SELECT DISTINCT num AS ConsecutiveNums FROM ( SELECT num, (CASE WHEN @prev = num THEN @cur := @cur +1 WHEN @prev := num THEN @cur := 1 END) AS ran FROM Logs, (SELECT @prev := NULL, @cur := 0) AS r ) AS t WHERE t.ran &amp;gt;= 3</description></item><item><title>Leetcode 178 分数排名</title><link>https://o5o.me/post/leetcode_178_rank_scores/</link><pubDate>Tue, 31 Jan 2023 16:20:00 +0800</pubDate><guid>https://o5o.me/post/leetcode_178_rank_scores/</guid><description>题目：178. 分数排名
我的解答 使用了MySQL提供的函数 1 2 3 SELECT score, DENSE_RANK() OVER(ORDER BY score DESC) AS &amp;#39;rank&amp;#39; FROM Scores; 因为别名rank和rank函数冲突了，所以加个引号。
使用变量 SELECT score, CAST((CASE WHEN @prev = score THEN @curRank WHEN @prev := score THEN @curRank := @curRank +1 WHEN score = 0 THEN @curRank := @curRank + 1 END) AS SIGNED) AS &amp;#39;rank&amp;#39; FROM scores, (SELECT @curRank := 0, @prev := NULL) AS r ORDER BY score DESC; 变量prev指向的是先前一行记录里的score，变量curRank是当前这个分数的排名。
这一段的描述可能不够准确：首先查询得到每一条记录的score并按降序排序，而后，从上到下，第一个score是4.00，设为1，第二个score也是4.00，也设为1，第三个是3.85，设为1+1=2，依次类推。根据我所了解的，SQL的执行顺序中，ORDER BY是在SELECT执行之后才执行的。但是，上述过程很明显利用了排序后的结果，所以这一点我就很困惑。如果用主查询和子查询来理解，主查询执行完之后，对于返回的每一行结果再执行子查询，似乎可行，但代码中的子查询是出现在FROM后面的，而条件判断是主查询里面的。这里我依旧很困惑。</description></item><item><title>Leetcode 177 第N高的薪水</title><link>https://o5o.me/post/leetcode_177_nth_highest_salary/</link><pubDate>Sat, 28 Jan 2023 20:51:00 +0800</pubDate><guid>https://o5o.me/post/leetcode_177_nth_highest_salary/</guid><description>题目：177. 第N高的薪水
我的解答 1 2 3 4 5 6 7 8 9 10 11 12 CREATE FUNCTION getNthHighestSalary(N INT) RETURNS INT BEGIN SET N = N - 1; RETURN ( # Write your MySQL query statement below. SELECT IFNULL( (SELECT DISTINCT salary FROM Employee ORDER BY salary DESC LIMIT 1 OFFSET N),NULL) AS getNthHighestSalary ); END 在 LIMIT 和 OFFSET 内不能进行运算，所以在开头首先让N减1。
注意语句末尾的分号。
注意指定别名语句AS getNthHighestSalary末尾并没有括号。</description></item><item><title>Leetcode 176 第二高的薪水</title><link>https://o5o.me/post/leetcode_176_second_highest_salary/</link><pubDate>Sat, 28 Jan 2023 20:23:00 +0800</pubDate><guid>https://o5o.me/post/leetcode_176_second_highest_salary/</guid><description>题目：176. 第二高的薪水
我的解答 下面这个最初的解答被判定为错，乐扣没显示是哪些测试用例错了，所以也没办法改进。
1 2 3 4 5 6 7 # Write your MySQL query statement below SELECT MAX(salary) AS SecondHignestSalary FROM Employee WHERE salary &amp;lt; ( SELECT MAX(salary) FROM Employee ); 下面这个解答是成功通过的：
1 2 3 4 5 SELECT IFNULL( (SELECT DISTINCT salary FROM Employee ORDER BY salary DESC LIMIT 1 OFFSET 1),NULL) AS SecondHighestSalary; DISTINCT参数用于让查询结果中相同的值只出现一次。
DESC关键字用于让查询结果按降序进行排序。
IFNULL()函数用于判断第一个表达式是否为 NULL，如果为 NULL 则返回第二个参数的值。
LIMIT 和 OFFSET 用于对查询结果进行分页，每次返回查询结果的一部分。</description></item><item><title>Leetcode 175 组合两个表</title><link>https://o5o.me/post/leetcode_175_combine_two_tables/</link><pubDate>Sat, 28 Jan 2023 19:48:52 +0800</pubDate><guid>https://o5o.me/post/leetcode_175_combine_two_tables/</guid><description>题目：175. 组合两个表
我的解答 1 2 3 # Write your MySQL query statement below SELECT FirstName AS firstName, LastName AS lastName, City AS city, State AS state From Person LEFT OUTER JOIN Address ON Person.PersonId = Address.PersonId;</description></item></channel></rss>