[{"categories":["Python"],"contents":" 描述 牛牛在门头沟大学学习，一学年过去了，需要根据他的成绩计算他的平均绩点，假如绩点与等级的对应关系如下表所示。请根据输入的等级和学分数，计算牛牛的均绩（每门课学分乘上单门课绩点，求和后对学分求均值）。\nA 4.0 B 3.0 C 2.0 D 1.0 F 0 这一题来自牛客网，题目链接：here\n输入描述： 连续输入一行等级一行学分，遇到等级为False则结束输入。\n输出描述： 均绩保留两位小数。\n示例1 输入： A 3 B 4 C 2 False 输出： 3.11 我的解答 最初的解答：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 d={\u0026#39;A\u0026#39;:4.0,\u0026#39;B\u0026#39;:3.0,\u0026#39;C\u0026#39;:2.0,\u0026#39;D\u0026#39;:1.0,\u0026#39;F\u0026#39;:0} b=[] c=[] i=1 while True: a = input() if a != \u0026#34;False\u0026#34; and i%2 == 1: b.append(a) i += 1 elif a != \u0026#34;False\u0026#34; and i%2 == 0: c.append(int(a)) i += 1 elif a == \u0026#34;False\u0026#34;: break else: break e=0 for i,j in zip(b,c): e += d[i]*j print(\u0026#34;%.2f\u0026#34; % (e/sum(c))) 很不优雅。我看到高赞解答后，真的是惊为天人，太优雅了！\n我又动手写了一个优雅版的：\n1 2 3 4 5 6 7 8 9 d={\u0026#39;A\u0026#39;:4.0,\u0026#39;B\u0026#39;:3.0,\u0026#39;C\u0026#39;:2.0,\u0026#39;D\u0026#39;:1.0,\u0026#39;F\u0026#39;:0} t1 = 0 t2 = 0 while rank:=d.get(input(),False): score = int(input()) t1 += rank * score t2 += score print(\u0026#34;%.2f\u0026#34; % (t1/t2)) 用到了海象运算服，用到了字典的get()方法，关键是它还很短。\n","date":"Feb 03","permalink":"https://o5o.me/post/python_exercise_nowcoder_np47/","tags":null,"title":"Python练习题NP47牛牛的绩点"},{"categories":["SRS"],"contents":"Anki更新2.1.57版本后，内置支持自建同步服务。之前都是需要以插件的形式实现，且搭建后往往只适用于旧版本的Anki，选择了自建同步服务就意味着放弃追求新版本和新功能。\n只需要几行代码就可以搭建自己的Anki同步服务了：\nscreen -S anki-aoyu python3 -m venv ~/syncserver ~/syncserver/bin/pip install anki SYNC_USER1=aoyu:123456 ~/syncserver/bin/python -m anki.syncserver 我的系统版本是Ubuntu22.04，安装过程是相当顺畅的。很大概率你需要先运行apt install python3.10-venv，之后才能python3 -m venv ~/syncserver，不过你不需要提前考虑到这一点，报错后会提醒你安装的。\nSYNC_USER1后面跟的是账户名和密码，在Anki里用这个账号登录。\n你需要在Anki软件设置Self-hosted sync server项里填写http://服务器ip:8080/，之后就可以使用自己的同步服务了。\n可以用 Nginx 做一个反代，我能想到的优点有：不让8080端口暴露到网络上；给anki的同步服务绑定一个域名，好记；可以启用https。这里就不写了，懒。\nscreen命令的使用可参考：SSH远程会话管理工具 - screen使用教程 - VPS侦探 (vpser.net)\n安装参考：Sync Server - Anki Manual (ankiweb.net)\n","date":"Jan 31","permalink":"https://o5o.me/post/anki_self_hosted_sync_server_ubuntu/","tags":["Anki"],"title":"Ubuntu自建Anki同步服务"},{"categories":["LeetCode"],"contents":"题目：183. 从不订购的客户\n我的解答 1 2 3 4 5 SELECT Name AS Customers FROM Customers WHERE NOT ID IN ( SELECT CustomerId FROM Orders); ","date":"Jan 31","permalink":"https://o5o.me/post/leetcode_183_customers_who_never_order/","tags":["SQL"],"title":"Leetcode 183 从不订购的客户"},{"categories":["LeetCode"],"contents":"题目：182. 查找重复的电子邮箱\n我的解答 1 2 3 4 5 6 7 8 # Write your MySQL query statement below SELECT name AS Employee FROM ( SELECT a.name AS name, a.salary AS mySalary, b.salary AS manaSalary FROM Employee a, Employee b WHERE a.managerId = b.id ) as b WHERE mySalary \u0026gt; manaSalary; 更好的答案：\n自联结 1 2 3 4 SELECT e1.name AS Employee FROM Employee AS e1, Employee AS e2 WHERE e1.managerID = e2.id AND e1.salary \u0026gt; e2.salary; 子查询 1 2 3 4 5 6 SELECT name AS Employee FROM Employee as e WHERE salary \u0026gt; ( SELECT salary FROM Employee WHERE id = e.managerId); ","date":"Jan 31","permalink":"https://o5o.me/post/leetcode_182_duplicate_emails/","tags":["SQL"],"title":"Leetcode 182 查找重复的电子邮箱"},{"categories":["LeetCode"],"contents":"题目：181. 超过经理收入的员工\n我的解答 1 2 3 4 5 6 7 8 # Write your MySQL query statement below SELECT name AS Employee FROM ( SELECT a.name AS name, a.salary AS mySalary, b.salary AS manaSalary FROM Employee a, Employee b WHERE a.managerId = b.id ) as b WHERE mySalary \u0026gt; manaSalary; 更好的答案：\n自联结 1 2 3 4 SELECT e1.name AS Employee FROM Employee AS e1, Employee AS e2 WHERE e1.managerID = e2.id AND e1.salary \u0026gt; e2.salary; 子查询 1 2 3 4 5 6 SELECT name AS Employee FROM Employee as e WHERE salary \u0026gt; ( SELECT salary FROM Employee WHERE id = e.managerId); ","date":"Jan 31","permalink":"https://o5o.me/post/leetcode_181_employees_earning_more_than-their_managers/","tags":["SQL"],"title":"Leetcode 181 超过经理收入的员工"},{"categories":["LeetCode"],"contents":"题目：180. 连续出现的数字\n我的解答 使用变量\n1 2 3 4 5 6 7 8 9 SELECT DISTINCT num AS ConsecutiveNums FROM ( SELECT num, (CASE WHEN @prev = num THEN @cur := @cur +1 WHEN @prev := num THEN @cur := 1 END) AS ran FROM Logs, (SELECT @prev := NULL, @cur := 0) AS r ) AS t WHERE t.ran \u0026gt;= 3 ","date":"Jan 31","permalink":"https://o5o.me/post/leetcode_180_consecutive_numbers/","tags":["SQL"],"title":"Leetcode 180 连续出现的数字"},{"categories":["LeetCode"],"contents":"题目：178. 分数排名\n我的解答 使用了MySQL提供的函数 1 2 3 SELECT score, DENSE_RANK() OVER(ORDER BY score DESC) AS \u0026#39;rank\u0026#39; FROM Scores; 因为别名rank和rank函数冲突了，所以加个引号。\n使用变量 SELECT score, CAST((CASE WHEN @prev = score THEN @curRank WHEN @prev := score THEN @curRank := @curRank +1 WHEN score = 0 THEN @curRank := @curRank + 1 END) AS SIGNED) AS \u0026#39;rank\u0026#39; FROM scores, (SELECT @curRank := 0, @prev := NULL) AS r ORDER BY score DESC; 变量prev指向的是先前一行记录里的score，变量curRank是当前这个分数的排名。\n这一段的描述可能不够准确：首先查询得到每一条记录的score并按降序排序，而后，从上到下，第一个score是4.00，设为1，第二个score也是4.00，也设为1，第三个是3.85，设为1+1=2，依次类推。根据我所了解的，SQL的执行顺序中，ORDER BY是在SELECT执行之后才执行的。但是，上述过程很明显利用了排序后的结果，所以这一点我就很困惑。如果用主查询和子查询来理解，主查询执行完之后，对于返回的每一行结果再执行子查询，似乎可行，但代码中的子查询是出现在FROM后面的，而条件判断是主查询里面的。这里我依旧很困惑。\n(SELECT @curRank := 0, @prev := NULL) AS r，是一个子查询，可以看做是为这两个变量设定初始值。对于派生出来的表，必须指定别名（Every derived table must have its own alias）。这里指定了别名r。\ncast(字段 as signed)将数据转换为整型，如果不使用这个函数，选出来的排名有双引号。\n参考：MySQL自定义变量的语法，Case When语法及用法 教你用SQL实现统计排名\n使用自联结 SELECT a.score AS score, COUNT(DISTINCT b.score) AS \u0026#39;rank\u0026#39; FROM scores AS a, scores AS b WHERE a.score \u0026lt;= b.score GROUP BY a.id ORDER BY a.score DESC ","date":"Jan 31","permalink":"https://o5o.me/post/leetcode_178_rank_scores/","tags":["SQL"],"title":"Leetcode 178 分数排名"},{"categories":["LeetCode"],"contents":"题目：177. 第N高的薪水\n我的解答 1 2 3 4 5 6 7 8 9 10 11 12 CREATE FUNCTION getNthHighestSalary(N INT) RETURNS INT BEGIN SET N = N - 1; RETURN ( # Write your MySQL query statement below. SELECT IFNULL( (SELECT DISTINCT salary FROM Employee ORDER BY salary DESC LIMIT 1 OFFSET N),NULL) AS getNthHighestSalary ); END 在 LIMIT 和 OFFSET 内不能进行运算，所以在开头首先让N减1。\n注意语句末尾的分号。\n注意指定别名语句AS getNthHighestSalary末尾并没有括号。\n","date":"Jan 28","permalink":"https://o5o.me/post/leetcode_177_nth_highest_salary/","tags":["SQL"],"title":"Leetcode 177 第N高的薪水"},{"categories":["LeetCode"],"contents":"题目：176. 第二高的薪水\n我的解答 下面这个最初的解答被判定为错，乐扣没显示是哪些测试用例错了，所以也没办法改进。\n1 2 3 4 5 6 7 # Write your MySQL query statement below SELECT MAX(salary) AS SecondHignestSalary FROM Employee WHERE salary \u0026lt; ( SELECT MAX(salary) FROM Employee ); 下面这个解答是成功通过的：\n1 2 3 4 5 SELECT IFNULL( (SELECT DISTINCT salary FROM Employee ORDER BY salary DESC LIMIT 1 OFFSET 1),NULL) AS SecondHighestSalary; DISTINCT参数用于让查询结果中相同的值只出现一次。\nDESC关键字用于让查询结果按降序进行排序。\nIFNULL()函数用于判断第一个表达式是否为 NULL，如果为 NULL 则返回第二个参数的值。\nLIMIT 和 OFFSET 用于对查询结果进行分页，每次返回查询结果的一部分。\n","date":"Jan 28","permalink":"https://o5o.me/post/leetcode_176_second_highest_salary/","tags":["SQL"],"title":"Leetcode 176 第二高的薪水"},{"categories":["LeetCode"],"contents":"题目：175. 组合两个表\n我的解答 1 2 3 # Write your MySQL query statement below SELECT FirstName AS firstName, LastName AS lastName, City AS city, State AS state From Person LEFT OUTER JOIN Address ON Person.PersonId = Address.PersonId; ","date":"Jan 28","permalink":"https://o5o.me/post/leetcode_175_combine_two_tables/","tags":["SQL"],"title":"Leetcode 175 组合两个表"},{"categories":["SRS"],"contents":"我日常用于复习的 SuperMemo 是中文懒人包版本，前几天打算学 AdvEng2018 牌组，担心合并牌组时导致文件损坏，所以就又用了另一个SM软件来单独学AdvEng2018，同时也想是用用英文SM，汉化版软件里有些翻译的中文选项我不理解，可以对照着看。\n复习时经常出现一个对话框：Which interval do you want to use?\n用SM的懒人包版本复习时则没这个弹窗。\n出现这个弹窗的原因是，软件想告诉你，按照默认的算法，下次安排这张卡片的复习要到几十天之后了，这个时间间隔太长了，问你要不要换个时间间隔短一点的算法。\n让它不显示的办法：默认是，如果一张卡片的复习间隔超过14天就会显示这个弹窗，我们把这个天数调大一些就好了。\n流程：Toolkit - Options -\u0026gt; Learning - Algorithm SM-18 Alerts - Interval [days]，默认是14，改大一点，例如改为3000.\n参考：Which interval do you want to use - SuperMemopedia\n","date":"Jan 27","permalink":"https://o5o.me/post/supermemo_which_interval_do_you_want_to_use/","tags":["SuperMemo"],"title":"Supermemo出现弹窗Which interval do you want to use?"},{"categories":["Python"],"contents":"运行下述代码后报错：\n1 2 import pygame pygame.init() 完整报错：\nlibGL error: MESA-LOADER: failed to open iris: /usr/lib/dri/iris_dri.so: cannot open shared object file: No such file or directory (search paths /usr/lib/x86_64-linux-gnu/dri:\\$${ORIGIN}/dri:/usr/lib/dri, suffix _dri) libGL error: failed to load driver: iris libGL error: MESA-LOADER: failed to open swrast: /usr/lib/dri/swrast_dri.so: cannot open shared object file: No such file or directory (search paths /usr/lib/x86_64-linux-gnu/dri:\\$${ORIGIN}/dri:/usr/lib/dri, suffix _dri) libGL error: failed to load driver: swrast X Error of failed request: BadValue (integer parameter out of range for operation) Major opcode of failed request: 149 (GLX) Minor opcode of failed request: 3 (X_GLXCreateContext) Value in failed request: 0x0 Serial number of failed request: 101 Current serial number in output stream: 102 提示在/usr/lib/dri/找不到iris和swrast驱动。而在/usr/lib/x86_64-linux-gnu/dri这个目录下，两个驱动都有。\n解决办法：在上面第一个目录中建立到第二个目录中文件的软链接。\naoyu@aoyuSurface:~$ sudo mkdir /usr/lib/dri aoyu@aoyuSurface:~$ cd /usr/lib/dri aoyu@aoyuSurface:/usr/lib/dri$ sudo ln -s /usr/lib/x86_64-linux-gnu/dri/iris_dri.so iris_dri.so sudo ln -s /usr/lib/x86_64-linux-gnu/dri/swrast_dri.so swrast_dri.so 运行程序，再次报错：\nlibGL error: MESA-LOADER: failed to open iris: /home/aoyu/AoyuCondaEnv/alien_invasion/bin/../lib/libstdc++.so.6: version `GLIBCXX_3.4.30\u0026#39; not found (required by /lib/x86_64-linux-gnu/libLLVM-15.so.1) (search paths /usr/lib/x86_64-linux-gnu/dri:\\$${ORIGIN}/dri:/usr/lib/dri, suffix _dri) libGL error: failed to load driver: iris libGL error: MESA-LOADER: failed to open swrast: /home/aoyu/AoyuCondaEnv/alien_invasion/bin/../lib/libstdc++.so.6: version `GLIBCXX_3.4.30\u0026#39; not found (required by /lib/x86_64-linux-gnu/libLLVM-15.so.1) (search paths /usr/lib/x86_64-linux-gnu/dri:\\$${ORIGIN}/dri:/usr/lib/dri, suffix _dri) libGL error: failed to load driver: swrast X Error of failed request: BadValue (integer parameter out of range for operation) Major opcode of failed request: 149 (GLX) Minor opcode of failed request: 3 (X_GLXCreateContext) Value in failed request: 0x0 Serial number of failed request: 101 Current serial number in output stream: 102 其中/home/aoyu/AoyuCondaEnv/alien_invasion/是我的Python解释器所在位置。\n报错的原因是GLIBCXX_3.4.30' not found。在libstdc++.so.6中看一看所有有关GLIBCXX的信息12：\naoyu@aoyuSurface:~$ strings /home/aoyu/AoyuCondaEnv/alien_invasion/lib/libstdc++.so.6 | grep GLIBCXX GLIBCXX_3.4 GLIBCXX_3.4.1 GLIBCXX_3.4.2 GLIBCXX_3.4.3 GLIBCXX_3.4.4 GLIBCXX_3.4.5 GLIBCXX_3.4.6 GLIBCXX_3.4.7 GLIBCXX_3.4.8 GLIBCXX_3.4.9 GLIBCXX_3.4.10 GLIBCXX_3.4.11 GLIBCXX_3.4.12 GLIBCXX_3.4.13 GLIBCXX_3.4.14 GLIBCXX_3.4.15 GLIBCXX_3.4.16 GLIBCXX_3.4.17 GLIBCXX_3.4.18 GLIBCXX_3.4.19 GLIBCXX_3.4.20 GLIBCXX_3.4.21 GLIBCXX_3.4.22 GLIBCXX_3.4.23 GLIBCXX_3.4.24 GLIBCXX_3.4.25 GLIBCXX_3.4.26 GLIBCXX_3.4.27 GLIBCXX_3.4.28 GLIBCXX_3.4.29 GLIBCXX_DEBUG_MESSAGE_LENGTH _ZNKSt14basic_ifstreamIcSt11char_traitsIcEE7is_openEv@GLIBCXX_3.4 _ZNSt13basic_istreamIwSt11char_traitsIwEE6ignoreEv@@GLIBCXX_3.4.5 _ZNKSbIwSt11char_traitsIwESaIwEE11_M_disjunctEPKw@GLIBCXX_3.4 _ZNKSt14basic_ifstreamIwSt11char_traitsIwEE7is_openEv@@GLIBCXX_3.4.5 GLIBCXX_3.4.21 GLIBCXX_3.4.9 _ZSt10adopt_lock@@GLIBCXX_3.4.11 GLIBCXX_3.4.10 GLIBCXX_3.4.16 GLIBCXX_3.4.1 _ZNSt19istreambuf_iteratorIcSt11char_traitsIcEEppEv@GLIBCXX_3.4 GLIBCXX_3.4.28 _ZNSs7_M_copyEPcPKcm@GLIBCXX_3.4 GLIBCXX_3.4.25 _ZNSt19istreambuf_iteratorIcSt11char_traitsIcEEppEv@@GLIBCXX_3.4.5 _ZNSs7_M_moveEPcPKcm@@GLIBCXX_3.4.5 _ZNKSt13basic_fstreamIwSt11char_traitsIwEE7is_openEv@GLIBCXX_3.4 _ZNKSt13basic_fstreamIcSt11char_traitsIcEE7is_openEv@GLIBCXX_3.4 _ZNSbIwSt11char_traitsIwESaIwEE4_Rep26_M_set_length_and_sharableEm@@GLIBCXX_3.4.5 _ZNSs4_Rep26_M_set_length_and_sharableEm@GLIBCXX_3.4 _ZSt10defer_lock@@GLIBCXX_3.4.11 _ZN10__gnu_norm15_List_node_base4swapERS0_S1_@@GLIBCXX_3.4 _ZNSs9_M_assignEPcmc@@GLIBCXX_3.4.5 _ZNKSbIwSt11char_traitsIwESaIwEE15_M_check_lengthEmmPKc@@GLIBCXX_3.4.5 _ZNKSt14basic_ifstreamIcSt11char_traitsIcEE7is_openEv@@GLIBCXX_3.4.5 _ZNSbIwSt11char_traitsIwESaIwEE7_M_moveEPwPKwm@GLIBCXX_3.4 GLIBCXX_3.4.24 _ZNVSt9__atomic011atomic_flag12test_and_setESt12memory_order@@GLIBCXX_3.4.11 GLIBCXX_3.4.20 _ZNSt11char_traitsIwE2eqERKwS2_@@GLIBCXX_3.4.5 GLIBCXX_3.4.12 _ZNSi6ignoreEv@@GLIBCXX_3.4.5 GLIBCXX_3.4.2 _ZNSt11char_traitsIcE2eqERKcS2_@@GLIBCXX_3.4.5 GLIBCXX_3.4.6 GLIBCXX_3.4.15 _ZNKSt13basic_fstreamIcSt11char_traitsIcEE7is_openEv@@GLIBCXX_3.4.5 _ZNSs9_M_assignEPcmc@GLIBCXX_3.4 GLIBCXX_3.4.19 _ZNKSt14basic_ofstreamIwSt11char_traitsIwEE7is_openEv@GLIBCXX_3.4 _ZNSt19istreambuf_iteratorIwSt11char_traitsIwEEppEv@GLIBCXX_3.4 GLIBCXX_3.4.27 _ZN10__gnu_norm15_List_node_base7reverseEv@@GLIBCXX_3.4 _ZN10__gnu_norm15_List_node_base4hookEPS0_@@GLIBCXX_3.4 _ZNSt11char_traitsIwE2eqERKwS2_@GLIBCXX_3.4 _ZNSbIwSt11char_traitsIwESaIwEE7_M_copyEPwPKwm@GLIBCXX_3.4 _ZNSbIwSt11char_traitsIwESaIwEE7_M_copyEPwPKwm@@GLIBCXX_3.4.5 GLIBCXX_3.4.23 GLIBCXX_3.4.3 GLIBCXX_3.4.7 _ZNSi6ignoreEl@@GLIBCXX_3.4.5 _ZNKSbIwSt11char_traitsIwESaIwEE11_M_disjunctEPKw@@GLIBCXX_3.4.5 _ZNSt13basic_istreamIwSt11char_traitsIwEE6ignoreEv@GLIBCXX_3.4 _ZNKSt13basic_fstreamIwSt11char_traitsIwEE7is_openEv@@GLIBCXX_3.4.5 _ZNSbIwSt11char_traitsIwESaIwEE7_M_moveEPwPKwm@@GLIBCXX_3.4.5 GLIBCXX_3.4.18 _ZNSbIwSt11char_traitsIwESaIwEE4_Rep26_M_set_length_and_sharableEm@GLIBCXX_3.4 _ZNSt13basic_istreamIwSt11char_traitsIwEE6ignoreEl@@GLIBCXX_3.4.5 _ZSt15future_category@@GLIBCXX_3.4.14 _ZNSi6ignoreEl@GLIBCXX_3.4 GLIBCXX_3.4.29 _ZNSt11char_traitsIcE2eqERKcS2_@GLIBCXX_3.4 _ZNKSs15_M_check_lengthEmmPKc@GLIBCXX_3.4 _ZN10__gnu_norm15_List_node_base8transferEPS0_S1_@@GLIBCXX_3.4 _ZNSbIwSt11char_traitsIwESaIwEE9_M_assignEPwmw@GLIBCXX_3.4 _ZNVSt9__atomic011atomic_flag5clearESt12memory_order@@GLIBCXX_3.4.11 _ZNKSt14basic_ofstreamIcSt11char_traitsIcEE7is_openEv@@GLIBCXX_3.4.5 _ZNKSt14basic_ofstreamIcSt11char_traitsIcEE7is_openEv@GLIBCXX_3.4 _ZNSs7_M_moveEPcPKcm@GLIBCXX_3.4 _ZNSt13basic_istreamIwSt11char_traitsIwEE6ignoreEl@GLIBCXX_3.4 _ZNSbIwSt11char_traitsIwESaIwEE9_M_assignEPwmw@@GLIBCXX_3.4.5 _ZNKSbIwSt11char_traitsIwESaIwEE15_M_check_lengthEmmPKc@GLIBCXX_3.4 _ZNKSs11_M_disjunctEPKc@@GLIBCXX_3.4.5 _ZN10__gnu_norm15_List_node_base6unhookEv@@GLIBCXX_3.4 GLIBCXX_3.4.22 _ZNSt19istreambuf_iteratorIwSt11char_traitsIwEEppEv@@GLIBCXX_3.4.5 _ZNSi6ignoreEv@GLIBCXX_3.4 _ZNSs7_M_copyEPcPKcm@@GLIBCXX_3.4.5 GLIBCXX_3.4.8 GLIBCXX_3.4.13 _ZSt11try_to_lock@@GLIBCXX_3.4.11 _ZNKSt14basic_ofstreamIwSt11char_traitsIwEE7is_openEv@@GLIBCXX_3.4.5 GLIBCXX_3.4.17 GLIBCXX_3.4.4 _ZNKSs15_M_check_lengthEmmPKc@@GLIBCXX_3.4.5 _ZNKSt14basic_ifstreamIwSt11char_traitsIwEE7is_openEv@GLIBCXX_3.4 _ZNSs4_Rep26_M_set_length_and_sharableEm@@GLIBCXX_3.4.5 GLIBCXX_3.4.26 _ZNKSs11_M_disjunctEPKc@GLIBCXX_3.4 确实，最高版本是GLIBCXX_3.4.29。\n（这里为了方便，我用sudo su -切换为了root）\n看一下libstdc++.so.6这个文件的信息：\n(base) root@aoyuSurface:~# ls -l /home/aoyu/AoyuCondaEnv/alien_invasion/lib/libstdc++.so.6 lrwxrwxrwx 1 aoyu aoyu 19 1月 26 13:25 /home/aoyu/AoyuCondaEnv/alien_invasion/lib/libstdc++.so.6 -\u0026gt; libstdc++.so.6.0.29 (base) root@aoyuSurface:~# ls -l /home/aoyu/AoyuCondaEnv/alien_invasion/lib/libstdc++.so.6.0.29 -rwxrwxr-x 3 aoyu aoyu 17981480 6月 1 2022 /home/aoyu/AoyuCondaEnv/alien_invasion/lib/libstdc++.so.6.0.29 是一个指向libstdc++.so.6.0.29的链接。\n找找电脑里有没有libstdc++.so新一点的版本：\n(base) root@aoyuSurface:~# find / -name \u0026#34;libstdc++.so*\u0026#34; /opt/anaconda3/lib/libstdc++.so /opt/anaconda3/lib/libstdc++.so.6.0.29 /opt/anaconda3/lib/libstdc++.so.6 /opt/anaconda3/pkgs/libstdcxx-ng-11.2.0-h1234567_1/lib/libstdc++.so /opt/anaconda3/pkgs/libstdcxx-ng-11.2.0-h1234567_1/lib/libstdc++.so.6.0.29 /opt/anaconda3/pkgs/libstdcxx-ng-11.2.0-h1234567_1/lib/libstdc++.so.6 /home/aoyu/.conda/pkgs/libstdcxx-ng-11.2.0-h1234567_1/lib/libstdc++.so /home/aoyu/.conda/pkgs/libstdcxx-ng-11.2.0-h1234567_1/lib/libstdc++.so.6.0.29 /home/aoyu/.conda/pkgs/libstdcxx-ng-11.2.0-h1234567_1/lib/libstdc++.so.6 /home/aoyu/AoyuCondaEnv/alien_invasion/lib/libstdc++.so /home/aoyu/AoyuCondaEnv/alien_invasion/lib/libstdc++.so.6.0.29 /home/aoyu/AoyuCondaEnv/alien_invasion/lib/libstdc++.so.6 find: ‘/run/user/1000/doc’: 权限不够 find: ‘/run/user/1000/gvfs’: 权限不够 /usr/lib/gcc/x86_64-linux-gnu/12/libstdc++.so /usr/lib/x86_64-linux-gnu/libstdc++.so.6 /usr/lib/x86_64-linux-gnu/libstdc++.so.6.0.30 /usr/share/gdb/auto-load/usr/lib/x86_64-linux-gnu/libstdc++.so.6.0.30-gdb.py /snap/core20/1778/usr/lib/x86_64-linux-gnu/libstdc++.so.6 /snap/core20/1778/usr/lib/x86_64-linux-gnu/libstdc++.so.6.0.28 /snap/core20/1778/usr/share/gdb/auto-load/usr/lib/x86_64-linux-gnu/libstdc++.so.6.0.28-gdb.py /snap/core20/1623/usr/lib/x86_64-linux-gnu/libstdc++.so.6 /snap/core20/1623/usr/lib/x86_64-linux-gnu/libstdc++.so.6.0.28 /snap/core20/1623/usr/share/gdb/auto-load/usr/lib/x86_64-linux-gnu/libstdc++.so.6.0.28-gdb.py (base) root@aoyuSurface:~# 看到最新的版本是/usr/lib/x86_64-linux-gnu/libstdc++.so.6.0.30。\n看一下里面有没有GLIBCXX_3.4.30：\n(base) root@aoyuSurface:~# strings /usr/lib/x86_64-linux-gnu/libstdc++.so.6.0.30 | grep GLIBCXX GLIBCXX_3.4 GLIBCXX_3.4.1 GLIBCXX_3.4.2 GLIBCXX_3.4.3 GLIBCXX_3.4.4 GLIBCXX_3.4.5 GLIBCXX_3.4.6 GLIBCXX_3.4.7 GLIBCXX_3.4.8 GLIBCXX_3.4.9 GLIBCXX_3.4.10 GLIBCXX_3.4.11 GLIBCXX_3.4.12 GLIBCXX_3.4.13 GLIBCXX_3.4.14 GLIBCXX_3.4.15 GLIBCXX_3.4.16 GLIBCXX_3.4.17 GLIBCXX_3.4.18 GLIBCXX_3.4.19 GLIBCXX_3.4.20 GLIBCXX_3.4.21 GLIBCXX_3.4.22 GLIBCXX_3.4.23 GLIBCXX_3.4.24 GLIBCXX_3.4.25 GLIBCXX_3.4.26 GLIBCXX_3.4.27 GLIBCXX_3.4.28 GLIBCXX_3.4.29 GLIBCXX_3.4.30 GLIBCXX_DEBUG_MESSAGE_LENGTH 可以看到里面有GLIBCXX_3.4.30，那接下来就用这个libstdc++.so替换旧的：\n(base) root@aoyuSurface:~# cp /usr/lib/x86_64-linux-gnu/libstdc++.so.6.0.30 /home/aoyu/AoyuCondaEnv/alien_invasion/lib/ (base) root@aoyuSurface:~# rm /home/aoyu/AoyuCondaEnv/alien_invasion/lib/libstdc++.so.6.0.29 (base) root@aoyuSurface:~# rm /home/aoyu/AoyuCondaEnv/alien_invasion/lib/libstdc++.so.6 (base) root@aoyuSurface:~# ln -s /home/aoyu/AoyuCondaEnv/alien_invasion/lib/libstdc++.so.6.0.30 /home/aoyu/AoyuCondaEnv/alien_invasion/lib/libstdc++.so.6 来确认一下替换libstdc++.so.6是不是成功了：\n(base) root@aoyuSurface:~# strings /home/aoyu/AoyuCondaEnv/alien_invasion/lib/libstdc++.so.6 | grep GLIBCXX GLIBCXX_3.4 GLIBCXX_3.4.1 GLIBCXX_3.4.2 GLIBCXX_3.4.3 GLIBCXX_3.4.4 GLIBCXX_3.4.5 GLIBCXX_3.4.6 GLIBCXX_3.4.7 GLIBCXX_3.4.8 GLIBCXX_3.4.9 GLIBCXX_3.4.10 GLIBCXX_3.4.11 GLIBCXX_3.4.12 GLIBCXX_3.4.13 GLIBCXX_3.4.14 GLIBCXX_3.4.15 GLIBCXX_3.4.16 GLIBCXX_3.4.17 GLIBCXX_3.4.18 GLIBCXX_3.4.19 GLIBCXX_3.4.20 GLIBCXX_3.4.21 GLIBCXX_3.4.22 GLIBCXX_3.4.23 GLIBCXX_3.4.24 GLIBCXX_3.4.25 GLIBCXX_3.4.26 GLIBCXX_3.4.27 GLIBCXX_3.4.28 GLIBCXX_3.4.29 GLIBCXX_3.4.30 GLIBCXX_DEBUG_MESSAGE_LENGTH 里面含有GLIBCXX_3.4.30，确实成功了。\n运行程序试试，程序成功运行。\n参考资料 conda + openai-gym + 核显 报错：libGL error: MESA-LOADER: failed to open iris\nAnaconda libstdc++.so.6: version `GLIBCXX_3.4.20\u0026rsquo; not found\nhttps://www.cnblogs.com/klb561/p/10765464.html\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nhttps://www.runoob.com/linux/linux-comm-grep.html\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"Jan 26","permalink":"https://o5o.me/post/python_libgl_error_driver_iris_swrast/","tags":null,"title":"Python报错libGL error: failed to load driver"},{"categories":null,"contents":"搜狗输入法基于fcitx。所有的JetBrains的IDE对所有的fcitx输入法都有这个问题。\n解决方法，从这里下载文件直接替换PyCharm安装路径里的jbr目录（我的在/opt/pycharm-community-2022.3.1/jbr/）。\n经测试有效。不过候选框会出现在光标的上方，而不是光标下方，还行，能用。\n","date":"Jan 26","permalink":"https://o5o.me/post/pycharm_fcitx_sogou_not_follow_cursor/","tags":null,"title":"Pycharm内搜狗输入法候选框不跟随光标"},{"categories":["SRS"],"contents":"首先在目录树（Alt+C）中移动卡片分支到正确的概念组下面。\n接下来设定Reference信息中的“Concept group”为正确信息：\n在卡片分支上点鼠标右键，“处理选中分支”，“设置概念分组”，在弹出的窗口中，在窗口左侧给正确的概念组打对钩，在窗口下方那一排按钮中点击“确定”。\n完成。\n","date":"Jan 24","permalink":"https://o5o.me/post/supermemo_wrong_branch/","tags":["SuperMemo"],"title":"Supermemo将内容导入到了错误的概念组怎么办"},{"categories":["Python"],"contents":"在PyCharm中，快捷键Ctrl+Alt+T的作用是“环绕方式\u0026hellip;，使用一些模板代码环绕所选代码段”。\n而在Ubuntu中，快捷键Ctrl+Alt+T的作用是“打开终端”。\n解决冲突的方式是修改二者其中之一的快捷键。\n修改PyCharm的这一个快捷键：文件-设置-\u0026gt;按键映射-搜索“环绕”-在快捷键那一项上点鼠标右键-移除Ctrl+Alt+T-添加键盘快捷键。\n修改Ubuntu（22.10）的这一个快捷键：设置-\u0026gt;键盘-\u0026gt;键盘快捷键-查看及自定义快捷键-\u0026gt;在搜索框中搜索“ctrl+”找到快捷键“Ctrl+Alt+T”-在那一项上面单击鼠标左键-在键盘上输入以设定新快捷键。\n我的选择是修改Ubuntu的这一个快捷键，因为我截止目前还没养成用快捷键打开终端的习惯。\n","date":"Jan 24","permalink":"https://o5o.me/post/pycharm_ubuntu_shortcut_conflict/","tags":null,"title":"Pycharm和Ubuntu快捷键冲突解决"},{"categories":["SRS"],"contents":"标题中的“新卡片”指的是在SuperMemo的“目录窗口（Contents Window）”中被标记为“浅蓝色”的卡片。\n我想要学习 Advanced English 2018 牌组包里的“Grammar”分支下的卡片，这个牌组包里的“新卡片”非常非常多，有几万张，包含单词、语法、发音、拼写等等，如果按默认复习队列一锅粥地学，很不系统，因此我才想着先学Grammar语法部分。\n一番尝试及朋友推荐，得到下面几种实现的方法。方法1就不推荐了，方法2和方法3按需取用。我选择的是方法2。\n方法1 一番尝试及在朋友帮助下，目前找到的可行的方法是将“新卡片”（浅蓝色）变为“已记”（问答卡片，深蓝色）。\n操作过程：打开“目录窗口”（Alt+C） -\u0026gt; 展开至想要学习的分支 -\u0026gt; 在那个分支标题上点鼠标右键 -\u0026gt; “处理选中分支（Process branch）” -\u0026gt; “已记（）”。在弹出的新窗口中（Which interval should be chosen in scheduling）选~~“One day interval”，那个分支下的卡片就会在一天内出现~~（我这里的理解可能是错误的）。\n总结：把未学的卡片设置为已学过的卡片，进入复习队列。\n方法2 由于我想要学的AdvEng2018是一个单独的kno文件，我把想要学的部分卡片从里面导出到另一个kno文件（我日常学习用的）里面，那也就实现了本文标题所称的效果。\n操作过程：打开“目录窗口”（Alt+C） -\u0026gt; 展开至想要学习的分支 -\u0026gt; 在那个分支标题上点鼠标右键 -\u0026gt; “导出（export）” -\u0026gt; “Transfer elements Shift+Ctrl+T” -\u0026gt; 在弹出的窗口中选想要导入的那个kno文件 -\u0026gt; 问你 Do you want to transfer elements? 选yes -\u0026gt; 问你 Do you want to integrate all files with the target file system? 选yes。这样就导入成功了。\n总结：把某一个“牌组”下的部分卡片导入到另一个“牌组”当中。\n方法3 思路：SuperMemo的作用是给一张张卡片排序形成“队列”，按排定的顺序将卡片推送给用户进行学习。那么我们只要将某一分支下的卡片的顺序调整到“队列”前面，就达到了学习某一分支下的卡片的目的。\n这个答案（如何在 SuperMemo 中复习/学习指定的folder/branch？ - 叶峻峣的回答 - 知乎）符合上面的思路，但有更好的方法：\n操作过程：打开“目录窗口”（Alt+C） -\u0026gt; 展开至想要学习的分支 -\u0026gt; 在那个分支标题上点鼠标右键 -\u0026gt; “查看（view）”-“分支元素（Branch）”-\u0026gt;在弹出的窗口中点最上方工具栏第一个按钮 -\u0026gt; 在打开的菜单中点“工具（Tools）” -\u0026gt; “保存未学部分（Save pending）”。这样就调整好了。\n不信？在SuperMemo主菜单中点“查看（View）”- \u0026ldquo;查看其他（Other）\u0026rdquo; - “尚未学习（Pending）”，在弹出的窗口中可以看到，你选定的那一个分支下的卡片，都跑到了队列的前面（队列第一张可能还是原来的，不过无伤大雅）。\n其他 FAQ: Advanced English with SuperMemo (super-memory.com)记录了一个官方的操作方法，但经我测试，在我使用的SuperMemo版本（18.05）上无法实现想要的效果，学了一张新卡片后，后续显示的是仍是正常学习队列的卡片，而不是选定分支下的后续卡片。\n","date":"Jan 24","permalink":"https://o5o.me/post/supermemo_learn_new_elements_that_belong_to_a_given_branch/","tags":["SuperMemo"],"title":"Supermemo学习某分支下的新卡片"},{"categories":["Python"],"contents":"在PyCharm的代码编辑区域显示一条竖线，提醒自己每行的代码尽量不要超过80字符。这是PEP8中有关行长的指南。\n文件-设置-\u0026gt;编辑器-代码样式-\u0026gt;常规-“视觉参考线”，设为80, 120，然后保存。在编辑代码时，右侧就会显示两条竖线，一个在第80个字符的位置，一个在第120个字符的位置。\n可以勾选“强制换行位置”（默认为120字符）后的“键入时换行”，这样，当行长到达120字符时就会强制换行。\n","date":"Jan 22","permalink":"https://o5o.me/post/pycharm_pep8_code_editor_vertical_line/","tags":null,"title":"在Pycharm的代码编辑区显示一条竖线提醒换行"},{"categories":["Python"],"contents":"主要是练习列表解析式。以下练习均使用列表解析式完成。\n练习4.3 数到20，使用一个for循环打印数1~20（含）。\n1 print([value for value in range(1,21)]) 练习4.4 一百万\n创建一个包含数 1～1 000 000 的列表，再使用一个 for 循环将这些数打印出来。（如果输出的时间太长，按 Ctrl + C 停止输出或关闭输出窗口。）\nprint([value for value in range(1,1_000_001)]) 不要尝试去运行上面的代码，能理解即可。\n练习4.5 一百万求和\n创建一个包含数 1～1 000 000的列表，再使用 min()和 max() 核实该列表确实是从 1 开始、到 1 000 000 结束的。另外，对这个列表调用函数 sum()， 看看 Python 将一百万个数相加需要多长时间。\n1 2 3 4 list1 = [i for i in range(1,1_000_001)] print(min(list1)) print(max(list1)) print(sum(list1)) 练习4.6 奇数\n通过给函数 range() 指定第三个参数来创建一个列表，其中包含 1～20 的奇数，再使用一个 for 循环将这些数打印出来。\n1 2 3 4 list1 = [i for i in range(1,20,2)] for i in list1: print(i) 练习4.7 3 的倍数\n创建一个列表，其中包含 3～30 能被 3 整除的数，再使用一 个 for 循环将这个列表中的数打印出来。\n1 2 3 4 list1 = [i for i in range(3,31,3)] for i in list1: print(i) 练习4.8 立方\n将同一个数乘三次称为立方。例如，在 Python 中，2 的立方用 2**3 表示。请创建一个列表，其中包含前 10 个整数（1～10）的立方，再使用一个 for 循环将这些立方数打印出来。\n1 2 3 4 list1 = [value**3 for value in range(1,11)] for i in list1: print(i) 练习4.9 立方解析\n使用列表解析生成一个列表，其中包含前 10 个整数的立方。\n1 list1 = [value**3 for value in range(1,11)] 和练习4.8相同。\n","date":"Jan 22","permalink":"https://o5o.me/post/python_crash_course_4/","tags":null,"title":"Python Crash Course 4"},{"categories":null,"contents":"我今天新装了ubuntu，把hugo博客仓库clone到本地，运行hugo server后，终端里显示貌似一切正常，但打开http://localhost:1313却是一片空白。\n原因是我只把博客内容克隆了下来，但子模块却忘记了克隆。\n补救措施：在仓库里运行git submodule update --init即可。\n由于我本地的public目录还是空的，所以我需要运行hugo server --disableFastRender，然后就一切正常了。\n参考：Git 工具 - 子模块\n","date":"Jan 18","permalink":"https://o5o.me/post/hugo_server_localhost_page_empty/","tags":["hugo"],"title":"本地运行hugo server时页面空白"},{"categories":null,"contents":"原因是我没有把anaconda安装在默认位置（/home目录里），而是装在了/opt目录里，我以普通用户的身份运行PyCharm，没有权限访问/opt目录，所以有了这个错误提示。\n解决办法：在/home/用户目录里我建了一个文件夹来放conda环境。\n","date":"Jan 18","permalink":"https://o5o.me/post/pycharm_condaerror_anaconda/","tags":["Anaconda"],"title":"PyCharm创建conda项目时提示CondaError: Unable to create prefix directory"},{"categories":["Python"],"contents":"今天写的程序运行时提示：AttributeError: 'BaiduImageSpider' object has no attribute 'url'，让我百思不得其解。\n最后发现是我把__init__写成了__int__，DeBug也没发现这个错误。\n","date":"Jan 17","permalink":"https://o5o.me/post/python_attributeerror_object_has_no_attribute/","tags":null,"title":"AttributeError: object has no attribute"},{"categories":null,"contents":"我觉得我遇到了 Baader-Meinhof 现象1。\n今天在写爬虫的时候，突然想到，如果Chrome的网页源代码页面的代码能自动换行就好了。我就去网上搜有没有方法能让源代码自动换行显示。\n一番搜寻没有结果，然后我就打算放弃，然后我不经意往一个已经打开的网页源代码页面一瞟，赫然有一个“自动换行”复选框静静显示在那里。\n天地良心，我以前真的是没有注意到过那里还有那么一个按钮，而现在它却那么显眼。\nFrequency illusion - Wikipedia\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"Jan 13","permalink":"https://o5o.me/post/chrome_view_source/","tags":["Chrome"],"title":"Chrome网页源代码自动换行"},{"categories":null,"contents":"写了一个简单的爬虫程序，从百度图片下载图片，但运行时报错：UnicodeEncodeError: 'latin-1' codec can't encode characters in position 41-44: ordinal not in range(256)\n程序反反复复检查了好几遍，最终确定是cookie的问题。\n我是从自己的 Chrome 浏览器里直接拷贝的cookie值粘贴到程序里的，没注意从Chrome直接复制的cookie会先解码再给你。就是说，程序里需要的cookie是不带中文的（中文先进行编码，比如把古力娜扎编码为%E5%8F%A4%E5%8A%9B%E5%A8%9C%E6%89%8E），但从Chrome复制出来的cookie带中文。\nChrome这是好心办坏事吗。\n","date":"Jan 13","permalink":"https://o5o.me/post/spider_unicodeencodeerror_latin-1/","tags":["爬虫"],"title":"爬虫运行报错：UnicodeEncodeError: 'latin-1' codec can't encode characters"},{"categories":["Python"],"contents":"注意:请使用我们目前学过的语句和特性来完成本题。\n编写一个能画出如下网格 (grid) 的函数: + - - - - + - - - - + | | | | | | | | | | | | + - - - - + - - - - + | | | | | | | | | | | | + - - - - + - - - - + 提示:你可以使用一个用逗号分隔的值序列,在一行中打印出多个值:\nprint(\u0026#39;+\u0026#39;, \u0026#39;−\u0026#39;) print 函数默认会自动换行,但是你可以阻止这个行为,只需要像下面这样将行结尾变成一个空格:\nprint(\u0026#39;+\u0026#39;, end=\u0026#39; \u0026#39;) print(\u0026#39;−\u0026#39;) 这两个语句的输出结果是+ −。\n一个没有传入实参的print 语句会结束当前行,跳到下一行。\n编写一个能够画出四行四列的类似网格的函数。 致谢: 这个习题基于 Practical C Programming, Third Edition 一书中的习题改编,该书由 O’Reilly 出版社于 1997 年出版。\n第一小题\n一行行来写\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 def paintgrid2x2(): print(\u0026#34;+\u0026#34;,\u0026#34;- \u0026#34;*4,end=\u0026#34;\u0026#34;) print(\u0026#34;+\u0026#34;,\u0026#34;- \u0026#34;*4,end=\u0026#34;+\\n\u0026#34;) print(\u0026#34;|\u0026#34;,\u0026#34; \u0026#34;*7,\u0026#34;|\u0026#34;, \u0026#34; \u0026#34;*7,\u0026#34;|\u0026#34;) print(\u0026#34;|\u0026#34;,\u0026#34; \u0026#34;*7,\u0026#34;|\u0026#34;, \u0026#34; \u0026#34;*7,\u0026#34;|\u0026#34;) print(\u0026#34;|\u0026#34;,\u0026#34; \u0026#34;*7,\u0026#34;|\u0026#34;, \u0026#34; \u0026#34;*7,\u0026#34;|\u0026#34;) print(\u0026#34;|\u0026#34;,\u0026#34; \u0026#34;*7,\u0026#34;|\u0026#34;, \u0026#34; \u0026#34;*7,\u0026#34;|\u0026#34;) print(\u0026#34;+\u0026#34;,\u0026#34;- \u0026#34;*4,end=\u0026#34;\u0026#34;) print(\u0026#34;+\u0026#34;,\u0026#34;- \u0026#34;*4,end=\u0026#34;+\\n\u0026#34;) print(\u0026#34;|\u0026#34;,\u0026#34; \u0026#34;*7,\u0026#34;|\u0026#34;, \u0026#34; \u0026#34;*7,\u0026#34;|\u0026#34;) print(\u0026#34;|\u0026#34;,\u0026#34; \u0026#34;*7,\u0026#34;|\u0026#34;, \u0026#34; \u0026#34;*7,\u0026#34;|\u0026#34;) print(\u0026#34;|\u0026#34;,\u0026#34; \u0026#34;*7,\u0026#34;|\u0026#34;, \u0026#34; \u0026#34;*7,\u0026#34;|\u0026#34;) print(\u0026#34;|\u0026#34;,\u0026#34; \u0026#34;*7,\u0026#34;|\u0026#34;, \u0026#34; \u0026#34;*7,\u0026#34;|\u0026#34;) print(\u0026#34;+\u0026#34;,\u0026#34;- \u0026#34;*4,end=\u0026#34;\u0026#34;) print(\u0026#34;+\u0026#34;,\u0026#34;- \u0026#34;*4,end=\u0026#34;+\\n\u0026#34;) paintgrid2x2() 第二小题\n用了for循环，一行行来写太多了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 def paintgrid3x3(): for j in range(3): print(\u0026#34;+\u0026#34;,\u0026#34;- \u0026#34;*4,end=\u0026#34;\u0026#34;) print(\u0026#34;+\u0026#34;,\u0026#34;- \u0026#34;*4,end=\u0026#34;\u0026#34;) print(\u0026#34;+\u0026#34;,\u0026#34;- \u0026#34;*4,end=\u0026#34;+\\n\u0026#34;) for i in range(4): print(\u0026#34;|\u0026#34;,\u0026#34; \u0026#34;*8,end=\u0026#34;\u0026#34;) print(\u0026#34;|\u0026#34;,\u0026#34; \u0026#34;*8,end=\u0026#34;\u0026#34;) print(\u0026#34;|\u0026#34;,\u0026#34; \u0026#34;*8,end=\u0026#34;|\\n\u0026#34;) print(\u0026#34;+\u0026#34;,\u0026#34;- \u0026#34;*4,end=\u0026#34;\u0026#34;) print(\u0026#34;+\u0026#34;,\u0026#34;- \u0026#34;*4,end=\u0026#34;\u0026#34;) print(\u0026#34;+\u0026#34;,\u0026#34;- \u0026#34;*4,end=\u0026#34;+\\n\u0026#34;) paintgrid3x3() 效果：\n+ - - - - + - - - - + - - - - + | | | | | | | | | | | | | | | | + - - - - + - - - - + - - - - + | | | | | | | | | | | | | | | | + - - - - + - - - - + - - - - + | | | | | | | | | | | | | | | | + - - - - + - - - - + - - - - + ","date":"Jan 10","permalink":"https://o5o.me/post/think_python_exercise_3.3/","tags":null,"title":"Think Python Exercise 3.3"},{"categories":["Python"],"contents":"函数对象是一个可以赋值给变量的值, 也可以作为实参传递。 例如, do_twice 函数接受函数对象作为实参,并调用这个函数对象两次:\ndef do_twice(f): f() f() 下面这个示例使用 do_twice 来调用名为 print_spam 的函数两次。\ndef print_spam (): print(\u0026#39;spam \u0026#39;) do_twice(print_spam) 将这个示例写入脚本,并测试。 修改do_twice,使其接受两个实参,一个是函数对象,另一个是值。然后调用这一函数对象两次,将那个值传递给函数对象作为实参。 从本章前面一些的示例中, 将 print_twice 函数的定义复制到脚本中。 使用修改过的 do_twice ,调用print_twice 两次,将 spam 传递给它作为实参。 定义一个名为 do_four 的新函数,其接受一个函数对象和一个值作为实参。调用这个函数对象四次,将那个值作为形参传递给它。函数体中应该只有两条语句,而不是四条。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 def do_twice(f, argus): f(argus) f(argus) def print_twice(bruce): print(bruce) print(bruce) def do_four(f, argus): do_twice(f, argus) do_twice(f, argus) do_twice(print_twice, \u0026#39;spam\u0026#39;) #do_four(print_twice, \u0026#34;spam\u0026#34;) ","date":"Jan 10","permalink":"https://o5o.me/post/think_python_exercise_3.2/","tags":null,"title":"Think Python Exercise 3.2"},{"categories":["Python"],"contents":"编写一个名为 right_justify 的函数, 函数接受一个名为 s 的字符串作为形参, 并在打印足够多的前导空格 (leading space) 之后打印这个字符串,使得字符串的最后一个字母位于显示屏的第 70 列。\n提示: 使用字符串拼接 (string concatenation) 和重复。 另外, Python 提供了一个名叫len 的内建函数,可以返回一个字符串的长度,因此len(\u0026lsquo;allen\u0026rsquo;) 的值是 5。\n1 2 3 4 5 6 7 def right_justify(s): print(\u0026#39; \u0026#39;*(70-len(s)),s) s1 = \u0026#34;good morning\u0026#34; s2 = \u0026#34;nice to meet you\u0026#34; right_justify(s1) right_justify(s2) ","date":"Jan 10","permalink":"https://o5o.me/post/think_python_exercise_3.1/","tags":null,"title":"Think Python Exercise 3.1"},{"categories":["Python"],"contents":"这道习题中包含了 Python 中最常见、最难找出来的错误。编写一个叫 Kangaroo 的类,包含以下方法:\n一个__init__ 方法,初始化一个叫 pounch_contents 的属性为空列表。 一个叫put_in_pounch 的方法,将一个任意类型的对象加入pounch_contents。 一个__str__ 方法,返回 Kangaroo 对象的字符串表示和 pounch 中的内容。 创建两个 Kangaroo 对象, 将它们命名为 kanga 和 roo , 然后将 roo 加入 kanga 的 pounch 列表, 以此测试你写的代码。\n这是我在不完全理解题目时写的代码（请不要参考）：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Kangaroo: def __init__(self): self.pounch_contents = [] def put_in_pounch(self, ayobj): self.pounch_contents.append(ayobj) def __str__(self): return str(self.pounch_contents) kanga = Kangaroo() roo = Kangaroo() kanga.put_in_pounch(roo) print(kanga) 其实这是一个找bug的练习。作者想让我们使用pylint这个工具找出他的代码里的bug。\n作者的代码（含bug）：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 \u0026#34;\u0026#34;\u0026#34;This module contains a code example related to Think Python, 2nd Edition by Allen Downey http://thinkpython2.com Copyright 2015 Allen Downey License: http://creativecommons.org/licenses/by/4.0/ \u0026#34;\u0026#34;\u0026#34; from __future__ import print_function, division \u0026#34;\u0026#34;\u0026#34; WARNING: this program contains a NASTY bug. I put it there on purpose as a debugging exercise, but you DO NOT want to emulate this example! \u0026#34;\u0026#34;\u0026#34; class Kangaroo: \u0026#34;\u0026#34;\u0026#34;A Kangaroo is a marsupial.\u0026#34;\u0026#34;\u0026#34; def __init__(self, name, contents=[]): \u0026#34;\u0026#34;\u0026#34;Initialize the pouch contents. name: string contents: initial pouch contents. \u0026#34;\u0026#34;\u0026#34; self.name = name self.pouch_contents = contents def __str__(self): \u0026#34;\u0026#34;\u0026#34;Return a string representaion of this Kangaroo. \u0026#34;\u0026#34;\u0026#34; t = [ self.name + \u0026#39; has pouch contents:\u0026#39; ] for obj in self.pouch_contents: s = \u0026#39; \u0026#39; + object.__str__(obj) t.append(s) return \u0026#39;\\n\u0026#39;.join(t) def put_in_pouch(self, item): \u0026#34;\u0026#34;\u0026#34;Adds a new item to the pouch contents. item: object to be added \u0026#34;\u0026#34;\u0026#34; self.pouch_contents.append(item) kanga = Kangaroo(\u0026#39;Kanga\u0026#39;) roo = Kangaroo(\u0026#39;Roo\u0026#39;) kanga.put_in_pouch(\u0026#39;wallet\u0026#39;) kanga.put_in_pouch(\u0026#39;car keys\u0026#39;) kanga.put_in_pouch(roo) print(kanga) # If you run this program as is, it seems to work. # To see the problem, trying printing roo. # Hint: to find the problem try running pylint. 用pylint分析一番：\n% pylint /Users/aoyu/Downloads/ThinkPython2-master/code/BadKangaroo.py ************* Module BadKangaroo Downloads/ThinkPython2-master/code/BadKangaroo.py:24:0: C0303: Trailing whitespace (trailing-whitespace) Downloads/ThinkPython2-master/code/BadKangaroo.py:1:0: C0103: Module name \u0026#34;BadKangaroo\u0026#34; doesn\u0026#39;t conform to snake_case naming style (invalid-name) Downloads/ThinkPython2-master/code/BadKangaroo.py:14:0: W0105: String statement has no effect (pointless-string-statement) Downloads/ThinkPython2-master/code/BadKangaroo.py:25:4: W0102: Dangerous default value [] as argument (dangerous-default-value) Downloads/ThinkPython2-master/code/BadKangaroo.py:37:8: C0103: Variable name \u0026#34;t\u0026#34; doesn\u0026#39;t conform to snake_case naming style (invalid-name) Downloads/ThinkPython2-master/code/BadKangaroo.py:39:12: C0103: Variable name \u0026#34;s\u0026#34; doesn\u0026#39;t conform to snake_case naming style (invalid-name) ------------------------------------------------------------------ Your code has been rated at 7.00/10 (previous run: 7.00/10, +0.00) 其他的都是小毛病，关键在于：\nDownloads/ThinkPython2-master/code/BadKangaroo.py:25:4: W0102: Dangerous default value [] as argument (dangerous-default-value) 说把空列表作为参数的默认值，很危险。怎么就危险了呢？看一个简单的例子就明白了：\n\u0026gt;\u0026gt;\u0026gt; a = [] \u0026gt;\u0026gt;\u0026gt; b = a \u0026gt;\u0026gt;\u0026gt; c = a \u0026gt;\u0026gt;\u0026gt; b.append(\u0026#39;a\u0026#39;) \u0026gt;\u0026gt;\u0026gt; a [\u0026#39;a\u0026#39;] \u0026gt;\u0026gt;\u0026gt; b [\u0026#39;a\u0026#39;] \u0026gt;\u0026gt;\u0026gt; c [\u0026#39;a\u0026#39;] a, b, c三个变量都是空列表的引用，其中一个改变，其他的变量也跟着改变。\n作者的代码的bug也是同理。每一个 Kangaroo 对象的 pouch_contents 属性的默认值都是一个空列表的引用，一个对象的 pouch_contents 改变，其他对象的 pouch_contents 也跟着改变。\n作者的解决办法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 \u0026#34;\u0026#34;\u0026#34;This module contains a code example related to Think Python, 2nd Edition by Allen Downey http://thinkpython2.com Copyright 2015 Allen Downey License: http://creativecommons.org/licenses/by/4.0/ \u0026#34;\u0026#34;\u0026#34; from __future__ import print_function, division \u0026#34;\u0026#34;\u0026#34; WARNING: this program contains a NASTY bug. I put it there on purpose as a debugging exercise, but you DO NOT want to emulate this example! \u0026#34;\u0026#34;\u0026#34; class Kangaroo: \u0026#34;\u0026#34;\u0026#34;A Kangaroo is a marsupial.\u0026#34;\u0026#34;\u0026#34; def __init__(self, name, contents=[]): \u0026#34;\u0026#34;\u0026#34;Initialize the pouch contents. name: string contents: initial pouch contents. \u0026#34;\u0026#34;\u0026#34; # The problem is the default value for contents. # Default values get evaluated ONCE, when the function # is defined; they don\u0026#39;t get evaluated again when the # function is called. # In this case that means that when __init__ is defined, # [] gets evaluated and contents gets a reference to # an empty list. # After that, every Kangaroo that gets the default # value gets a reference to THE SAME list. If any # Kangaroo modifies this shared list, they all see # the change. # The next version of __init__ shows an idiomatic way # to avoid this problem. self.name = name self.pouch_contents = contents def __init__(self, name, contents=None): \u0026#34;\u0026#34;\u0026#34;Initialize the pouch contents. name: string contents: initial pouch contents. \u0026#34;\u0026#34;\u0026#34; # In this version, the default value is None. When # __init__ runs, it checks the value of contents and, # if necessary, creates a new empty list. That way, # every Kangaroo that gets the default value gets a # reference to a different list. # As a general rule, you should avoid using a mutable # object as a default value, unless you really know # what you are doing. self.name = name if contents == None: contents = [] self.pouch_contents = contents def __str__(self): \u0026#34;\u0026#34;\u0026#34;Return a string representaion of this Kangaroo. \u0026#34;\u0026#34;\u0026#34; t = [ self.name + \u0026#39; has pouch contents:\u0026#39; ] for obj in self.pouch_contents: s = \u0026#39; \u0026#39; + object.__str__(obj) t.append(s) return \u0026#39;\\n\u0026#39;.join(t) def put_in_pouch(self, item): \u0026#34;\u0026#34;\u0026#34;Adds a new item to the pouch contents. item: object to be added \u0026#34;\u0026#34;\u0026#34; self.pouch_contents.append(item) kanga = Kangaroo(\u0026#39;Kanga\u0026#39;) roo = Kangaroo(\u0026#39;Roo\u0026#39;) kanga.put_in_pouch(\u0026#39;wallet\u0026#39;) kanga.put_in_pouch(\u0026#39;car keys\u0026#39;) kanga.put_in_pouch(roo) print(kanga) print(roo) # If you run this program as is, it seems to work. # To see the problem, trying printing roo. 代码里面的object.__str__(obj)怎样理解？\n返回它的参数obj所指的对象的字符串表现形式。\n举例：\n\u0026gt;\u0026gt;\u0026gt; a = \u0026#39;abc\u0026#39; \u0026gt;\u0026gt;\u0026gt; object.__str__(a) \u0026#34;\u0026#39;abc\u0026#39;\u0026#34; \u0026gt;\u0026gt;\u0026gt; print(a) abc \u0026gt;\u0026gt;\u0026gt; b = 123 \u0026gt;\u0026gt;\u0026gt; object.__str__(b) \u0026#39;123\u0026#39; \u0026gt;\u0026gt;\u0026gt; print(b) 123 \u0026gt;\u0026gt;\u0026gt; class Point: ... \u0026#34;\u0026#34;\u0026#34;test\u0026#34;\u0026#34;\u0026#34; ... \u0026gt;\u0026gt;\u0026gt; object.__str__(a) \u0026#39;\u0026lt;__main__.Point object at 0x7f7db642b700\u0026gt;\u0026#39; ","date":"Jan 10","permalink":"https://o5o.me/post/think_python_exercise_17.2/","tags":null,"title":"Think Python Exercise 17.2"},{"categories":["Python"],"contents":"我们做个练习, 将 time_to_int (见 16.4 节) 重写为方法。你或许也想将 int_to_time 改写为方法,但是那样做并没有什么意义,因为没有调用它的对象。\n原 int_to_time 函数见练习16.0。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Time: \u0026#34;\u0026#34;\u0026#34;Represents the time of day.\u0026#34;\u0026#34;\u0026#34; def print_time(self): print(\u0026#34;%.2d:%.2d:%.2d\u0026#34; % (self.hour, self.minute, self.second)) def time_to_int(self): minutes = self.hour * 60 + self.minute seconds = minutes * 60 + self.second return seconds start = Time() start.hour = 9 start.minute = 45 start.second = 20 start.time_to_int() 我们做个练习,为 Point 类写一个 init 方法,使用 x 和 y 作为可选参数,然后赋值给对应的属性。\n原相关代码见练习15.0。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Point: \u0026#34;\u0026#34;\u0026#34;表示一个二维的点 \u0026#34;\u0026#34;\u0026#34; def __init__(self, x=0, y=0): self.x = x self.y = y def print_point(self): print(\u0026#39;(%g, %g)\u0026#39; % (self.x, self.y)) Po1 = Point() Po2 = Point(100,75) Po1.print_point() Po2.print_point() 我们做个练习,为 Point 类写一个 str 方法。然后创建一个 Point 对象并打印。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Point: \u0026#34;\u0026#34;\u0026#34;表示一个二维的点 \u0026#34;\u0026#34;\u0026#34; def __init__(self, x=0, y=0): self.x = x self.y = y def __str__(self): return \u0026#39;(%g, %g)\u0026#39; % (self.x, self.y) Po1 = Point() Po2 = Point(100,75) print(Po1) print(Po2) 我们来做个练习,为 Point 类编写一个 add 方法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Point: \u0026#34;\u0026#34;\u0026#34;表示一个二维的点 \u0026#34;\u0026#34;\u0026#34; def __init__(self, x=0, y=0): self.x = x self.y = y def __str__(self): return \u0026#39;(%g, %g)\u0026#39; % (self.x, self.y) def __add__(self, other): return Point(self.x+other.x, self.y+other.y) Po1 = Point(200,80) Po2 = Point(100,75) print(Po1+Po2) 我们做个练习,为 Points 编写一个 add 方法,使其既适用 Point 对象,也适用元组:\n如果第二个运算数是一个 Point , 该方法将返回一个新的 Point, x 坐标是两个运算数的 x 的和,y 以此类推。\n如果第二个运算数是一个元组,该方法将把元组的第一个元素与 x 相加,第二个元素与 y 相加,然后返回以相关结果为参数的新的 Point。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Point: \u0026#34;\u0026#34;\u0026#34;表示一个二维的点 \u0026#34;\u0026#34;\u0026#34; def __init__(self, x=0, y=0): self.x = x self.y = y def __str__(self): return \u0026#39;(%g, %g)\u0026#39; % (self.x, self.y) def __add__(self, other): if isinstance(other, Point): return Point(self.x+other.x, self.y+other.y) else: return Point(self.x+other[0], self.y+other[1]) Po1 = Point(200,80) Po2 = Point(100,75) print(Po1+Po2) print(Po1+(12,2)) ","date":"Jan 10","permalink":"https://o5o.me/post/think_python_exercise_17.0/","tags":null,"title":"Think Python Exercise 17.0"},{"categories":["Python"],"contents":"修改 Time 类的属性, 使用一个整数代表自午夜零点开始的秒数。然后修改类的方法 (和int_to_time 函数),使其适用于新的实现。你不用修改 main 函数中的测试代码。完成之后, 程序的输出应该和之前保持一致。\n分析：作者的意思是，Time 类的属性，修改后只有“秒”这一个（小时、分钟都没了），同时，修改后Time类接收的参数和返回的值都保持不变。\n作者提供的用于修改的代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 \u0026#34;\u0026#34;\u0026#34;This module contains a code example related to Think Python, 2nd Edition by Allen Downey http://thinkpython2.com Copyright 2015 Allen Downey License: http://creativecommons.org/licenses/by/4.0/ \u0026#34;\u0026#34;\u0026#34; from __future__ import print_function, division class Time: \u0026#34;\u0026#34;\u0026#34;Represents the time of day. attributes: hour, minute, second \u0026#34;\u0026#34;\u0026#34; def __init__(self, hour=0, minute=0, second=0): \u0026#34;\u0026#34;\u0026#34;Initializes a time object. hour: int minute: int second: int or float \u0026#34;\u0026#34;\u0026#34; self.hour = hour self.minute = minute self.second = second def __str__(self): \u0026#34;\u0026#34;\u0026#34;Returns a string representation of the time.\u0026#34;\u0026#34;\u0026#34; return \u0026#39;%.2d:%.2d:%.2d\u0026#39; % (self.hour, self.minute, self.second) def print_time(self): \u0026#34;\u0026#34;\u0026#34;Prints a string representation of the time.\u0026#34;\u0026#34;\u0026#34; print(str(self)) def time_to_int(self): \u0026#34;\u0026#34;\u0026#34;Computes the number of seconds since midnight.\u0026#34;\u0026#34;\u0026#34; minutes = self.hour * 60 + self.minute seconds = minutes * 60 + self.second return seconds def is_after(self, other): \u0026#34;\u0026#34;\u0026#34;Returns True if t1 is after t2; false otherwise.\u0026#34;\u0026#34;\u0026#34; return self.time_to_int() \u0026gt; other.time_to_int() def __add__(self, other): \u0026#34;\u0026#34;\u0026#34;Adds two Time objects or a Time object and a number. other: Time object or number of seconds \u0026#34;\u0026#34;\u0026#34; if isinstance(other, Time): return self.add_time(other) else: return self.increment(other) def __radd__(self, other): \u0026#34;\u0026#34;\u0026#34;Adds two Time objects or a Time object and a number.\u0026#34;\u0026#34;\u0026#34; return self.__add__(other) def add_time(self, other): \u0026#34;\u0026#34;\u0026#34;Adds two time objects.\u0026#34;\u0026#34;\u0026#34; assert self.is_valid() and other.is_valid() seconds = self.time_to_int() + other.time_to_int() return int_to_time(seconds) def increment(self, seconds): \u0026#34;\u0026#34;\u0026#34;Returns a new Time that is the sum of this time and seconds.\u0026#34;\u0026#34;\u0026#34; seconds += self.time_to_int() return int_to_time(seconds) def is_valid(self): \u0026#34;\u0026#34;\u0026#34;Checks whether a Time object satisfies the invariants.\u0026#34;\u0026#34;\u0026#34; if self.hour \u0026lt; 0 or self.minute \u0026lt; 0 or self.second \u0026lt; 0: return False if self.minute \u0026gt;= 60 or self.second \u0026gt;= 60: return False return True def int_to_time(seconds): \u0026#34;\u0026#34;\u0026#34;Makes a new Time object. seconds: int seconds since midnight. \u0026#34;\u0026#34;\u0026#34; minutes, second = divmod(seconds, 60) hour, minute = divmod(minutes, 60) time = Time(hour, minute, second) return time def main(): start = Time(9, 45, 00) start.print_time() end = start.increment(1337) #end = start.increment(1337, 460) end.print_time() print(\u0026#39;Is end after start?\u0026#39;) print(end.is_after(start)) print(\u0026#39;Using __str__\u0026#39;) print(start, end) start = Time(9, 45) duration = Time(1, 35) print(start + duration) print(start + 1337) print(1337 + start) print(\u0026#39;Example of polymorphism\u0026#39;) t1 = Time(7, 43) t2 = Time(7, 41) t3 = Time(7, 37) total = sum([t1, t2, t3]) print(total) if __name__ == \u0026#39;__main__\u0026#39;: main() 修改后：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 class Time: \u0026#34;\u0026#34;\u0026#34;Represents the time of day. attributes: second, 自午夜零点开始的秒数 \u0026#34;\u0026#34;\u0026#34; def __init__(self, hour=0, minute=0, second=0): minutes = hour * 60 + minute self.second = minutes * 60 + second def __str__(self): \u0026#34;\u0026#34;\u0026#34;Returns a string representation of the time.\u0026#34;\u0026#34;\u0026#34; minutes, sec = divmod(self.second, 60) hour, minute = divmod(minutes, 60) return \u0026#39;%.2d:%.2d:%.2d\u0026#39; % (hour, minute, sec) def print_time(self): \u0026#34;\u0026#34;\u0026#34;Prints a string representation of the time.\u0026#34;\u0026#34;\u0026#34; print(str(self)) def time_to_int(self): \u0026#34;\u0026#34;\u0026#34;Computes the number of seconds since midnight.\u0026#34;\u0026#34;\u0026#34; return self.second def is_after(self, other): \u0026#34;\u0026#34;\u0026#34;Returns True if t1 is after t2; false otherwise.\u0026#34;\u0026#34;\u0026#34; return self.second \u0026gt; other.second def __add__(self, other): \u0026#34;\u0026#34;\u0026#34;Adds two Time objects or a Time object and a number. other: Time object or number of seconds \u0026#34;\u0026#34;\u0026#34; if isinstance(other, Time): return self.add_time(other) else: return self.increment(other) def __radd__(self, other): \u0026#34;\u0026#34;\u0026#34;Adds two Time objects or a Time object and a number.\u0026#34;\u0026#34;\u0026#34; return self.__add__(other) def add_time(self, other): \u0026#34;\u0026#34;\u0026#34;Adds two time objects.\u0026#34;\u0026#34;\u0026#34; assert self.is_valid() and other.is_valid() seconds = self.second + other.second return int_to_time(seconds) def increment(self, seconds): \u0026#34;\u0026#34;\u0026#34;Returns a new Time that is the sum of this time and seconds.\u0026#34;\u0026#34;\u0026#34; seconds += self.second return int_to_time(seconds) def is_valid(self): \u0026#34;\u0026#34;\u0026#34;Checks whether a Time object satisfies the invariants.\u0026#34;\u0026#34;\u0026#34; return self.second \u0026gt;= 0 and self.second \u0026lt; 24*60*60 def int_to_time(seconds): \u0026#34;\u0026#34;\u0026#34;Makes a new Time object. seconds: int seconds since midnight. \u0026#34;\u0026#34;\u0026#34; time = Time(0,0,seconds) return time def main(): start = Time(9, 45, 00) start.print_time() end = start.increment(1337) #end = start.increment(1337, 460) end.print_time() print(\u0026#39;Is end after start?\u0026#39;) print(end.is_after(start)) print(\u0026#39;Using __str__\u0026#39;) print(start, end) start = Time(9, 45) duration = Time(1, 35) print(start + duration) print(start + 1337) print(1337 + start) print(\u0026#39;Example of polymorphism\u0026#39;) t1 = Time(7, 43) t2 = Time(7, 41) t3 = Time(7, 37) total = sum([t1, t2, t3]) print(total) if __name__ == \u0026#39;__main__\u0026#39;: main() ","date":"Jan 10","permalink":"https://o5o.me/post/think_python_exercise_17.1/","tags":null,"title":"Think Python Exercise 17.1"},{"categories":["Python"],"contents":"datetime 模块提供的 time 对象,和本章的 Time 对象类似, 但前者提供了更丰富的方法和操作符。\n使用 datetime 模块来编写一个程序,获取当前日期并打印当天是周几。 编写一个程序,接受一个生日作为输入,并打印用户的年龄以及距离下个生日所需要的天数、小时数、分钟数和秒数。 对于两个不在同一天出生的人来说,总有一天,一个人的出生天数是另一个人的两倍。我们把这一天称为 ‘‘双倍日’’。编写一个程序,接受两个不同的出生日期, 并计算他们的 ‘‘双倍日’’。 再增加点挑战,编写一个更通用的版本,用于计算一个人出生天数是另一个人 n 倍的日子。 题1\n1 2 3 4 5 6 7 from datetime import date today = date.today() #print(dir(today)) #打印属性、方法列表 print(\u0026#34;今天是星期%d.\u0026#34; % (today.weekday()+1)) # weekday返回的值是从0开始的，所以+1 题2\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 from datetime import datetime def days_until_birthday(birthday): \u0026#34;\u0026#34;\u0026#34;距离下一次生日还有多长时间\u0026#34;\u0026#34;\u0026#34; today = datetime.today() next_birthday = datetime(today.year, birthday.month, birthday.day) if today \u0026gt; next_birthday: next_birthday = datetime(today.year+1, birthday.month, birthday.day) delta = next_birthday - today return delta.days today = datetime.today() print(today.strftime(\u0026#39;%A\u0026#39;)) #星期几 birthday = datetime(1999,5,10) print(days_until_birthday(birthday)) 题3和题4\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 from datetime import datetime def double_day(b1,b2): \u0026#34;\u0026#34;\u0026#34;计算，什么时候一个人的出生天数是另外一个人的两倍\u0026#34;\u0026#34;\u0026#34; if b1 \u0026gt; b2: delta = b1 - b2 dday = b1 + delta return dday elif b2 \u0026gt; b1: delta = b2 - b1 dday = b2 + delta return dday else: return False def ntimes_day(b1,b2,n): \u0026#34;\u0026#34;\u0026#34;计算，什么时候一个人的出生天数是另外一个人的n倍\u0026#34;\u0026#34;\u0026#34; if b1 \u0026gt; b2: delta = b1 - b2 dday = b1 + (n-1)*delta return dday elif b2 \u0026gt; b1: delta = b2 - b1 dday = b2 + (n-1)*delta return dday else: return False b1 = datetime(1999,5,10) b2 = datetime(2003,5,16) print(\u0026#39;两倍：\u0026#39;,double_day(b1,b2)) print(\u0026#39;6倍: \u0026#39;,ntimes_day(b1,b2,6)) ","date":"Jan 10","permalink":"https://o5o.me/post/think_python_exercise_16.2/","tags":null,"title":"Think Python Exercise 16.2"},{"categories":["Python"],"contents":"写一个叫做 mul_time 的函数,接收一个 Time 对象和一个数,并返回一个新的 Time 对象,包含原始时间和数的乘积。\n然后使用 mul_time 编写一个函数,接受一个表示比赛完赛时间的 Time 对象以及一个表示距离的数字,并返回一个用于表示平均配速 (每英里所需时间) 的 Time 对象。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class Time: \u0026#34;\u0026#34;\u0026#34;用于记录时间 属性：hour, minute, second \u0026#34;\u0026#34;\u0026#34; def print_time(ti): print(\u0026#34;%.2d:%.2d:%.2d\u0026#34; % (ti.hour,ti.minute,ti.second)) #记得加括号 def time_to_int(time): minutes = time.hour * 60 + time.minute seconds = minutes * 60 + time.second return seconds def int_to_time(seconds): time = Time() minutes, time.second = divmod(seconds, 60) time.hour, time.minute = divmod(minutes, 60) return time def mul_time(t1, a): return int_to_time(time_to_int(t1) * a) distance = 10 #距离，英里 time1 = Time() time1.hour = 11 time1.minute = 59 time1.second = 30 speed = mul_time(time1, 1/distance) #单位：小时/英里 print_time(speed) ","date":"Jan 10","permalink":"https://o5o.me/post/think_python_exercise_16.1/","tags":null,"title":"Think Python Exercise 16.1"},{"categories":["Python"],"contents":"编写一个叫做 print_time 的函数,接收一个 Time 对象并用 时:分:秒 的格式打印它。提示: 格式化序列 %.2d 可以至少两位数的形式打印一个整数,如果不足则在前面补 0。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Time: \u0026#34;\u0026#34;\u0026#34;用于记录时间 属性：hour, minute, second \u0026#34;\u0026#34;\u0026#34; def print_time(ti): print(\u0026#34;%.2d:%.2d:%.2d\u0026#34; % (ti.hour,ti.minute,ti.second)) #记得加括号 time1 = Time() time1.hour = 11 time1.minute = 59 time1.second = 30 print_time(time1) 编写一个叫做 is_after 的布尔函数,接收两个 Time 对象,t1 和 t2 ,若 t1 的时间在 t2 之后,则返回 True ,否则返回 False。挑战:不要使用 if 语句。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Time: \u0026#34;\u0026#34;\u0026#34;用于记录时间 属性：hour, minute, second \u0026#34;\u0026#34;\u0026#34; def print_time(ti): print(\u0026#34;%.2d:%.2d:%.2d\u0026#34; % (ti.hour,ti.minute,ti.second)) #记得加括号 def is_after(t1,t2): return (t1.hour, t1.minute, t1.second) \u0026gt; (t2.hour, t2.minute, t2.second) time1 = Time() time1.hour = 11 time1.minute = 59 time1.second = 30 time2 = Time() time2.hour = 11 time2.minute = 58 time2.second = 30 is_after(time1,time2) 我们做个练习,编写一个纯函数版本的 increment ,创建并返回一个 Time 对象,而不是修改参数。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Time: \u0026#34;\u0026#34;\u0026#34;用于记录时间 属性：hour, minute, second \u0026#34;\u0026#34;\u0026#34; def print_time(ti): print(\u0026#34;%.2d:%.2d:%.2d\u0026#34; % (ti.hour,ti.minute,ti.second)) #记得加括号 def increment(t1, seconds): \u0026#34;\u0026#34;\u0026#34;给一个Time对象增加指定的秒数\u0026#34;\u0026#34;\u0026#34; addedtime = Time() minutes, addedtime.second = divmod(t1.hour * 60 * 60 + t1.minute * 60 + t1.second + seconds, 60) addedtime.hour, addedtime.minute = divmod(minutes, 60) return addedtime time1 = Time() time1.hour = 11 time1.minute = 59 time1.second = 30 print_time(increment(time1, 90)) 我们再做个练习, 使用 time_to_int 和 int_to_time 重写 increment 函数。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 class Time: \u0026#34;\u0026#34;\u0026#34;用于记录时间 属性：hour, minute, second \u0026#34;\u0026#34;\u0026#34; def print_time(ti): print(\u0026#34;%.2d:%.2d:%.2d\u0026#34; % (ti.hour,ti.minute,ti.second)) #记得加括号 def time_to_int(time): minutes = time.hour * 60 + time.minute seconds = minutes * 60 + time.second return seconds def int_to_time(seconds): time = Time() minutes, time.second = divmod(seconds, 60) time.hour, time.minute = divmod(minutes, 60) return time def add_time(t1, t2): seconds = time_to_int(t1) + time_to_int(t1) return int_to_time(seconds) def increment(t1,seconds): \u0026#34;\u0026#34;\u0026#34;给一个Time对象增加指定的秒数\u0026#34;\u0026#34;\u0026#34; return int_to_time(time_to_int(t1) + seconds) def add_time(t1, t2): assert valid_time(t1) and valid_time(t2) seconds = time_to_int(t1) + time_to_int(t2) return int_to_time(seconds) time1 = Time() time1.hour = 11 time1.minute = 59 time1.second = 30 print_time(increment(time1, 90)) ","date":"Jan 09","permalink":"https://o5o.me/post/think_python_exercise_16.0/","tags":null,"title":"Think Python Exercise 16.1"},{"categories":["Python"],"contents":"编写一个名为 draw_rect 的函数,该函数接受一个 Turtle 对象和一个 Rectangle 对象,使用Turtle 画出该矩形。参考第 四 章中使用 Turtle 的示例。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 import turtle class Point: \u0026#34;\u0026#34;\u0026#34;表示一个二维的点 \u0026#34;\u0026#34;\u0026#34; class Rectangle: \u0026#34;\u0026#34;\u0026#34;Represents a rectangle. attributes: width, height, corner.\u0026#34;\u0026#34;\u0026#34; def draw_rect(t,rect): t.pu() #在移动到矩形左下角的过程中，不画出痕迹（提笔，put up） t.goto(rect.corner.x, rect.corner.y) t.pd() #落笔（put down） for i in range(2): t.fd(box.width) t.lt(90) t.fd(box.height) t.lt(90) bob = turtle.Turtle() box = Rectangle() box.width = 100.0 box.height = 200.0 box.corner = Point() box.corner.x = 100 box.corner.y = 90 draw_rect(bob,box) turtle.mainloop() 编写一个名为 draw_circle 的函数, 该函数接受一个 Turtle 对象和 Circle 对象, 并画出该圆。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 import turtle, math class Point: \u0026#34;\u0026#34;\u0026#34;表示一个二维的点 \u0026#34;\u0026#34;\u0026#34; class Circle: \u0026#34;\u0026#34;\u0026#34;属性：圆心center、半径radius 圆心是一个Point类 半径是一个数字 \u0026#34;\u0026#34;\u0026#34; #下面几个函数，用了4.1题画圆的代码 def polyline(t, n, length, angle): \u0026#34;\u0026#34;\u0026#34;Draws n line segments. t: Turtle object n: number of line segments length: length of each segment angle: degrees between segments \u0026#34;\u0026#34;\u0026#34; for i in range(n): t.fd(length) t.lt(angle) def polygon(t, n, length): \u0026#34;\u0026#34;\u0026#34;Draws a polygon with n sides. t: Turtle n: number of sides length: length of each side. \u0026#34;\u0026#34;\u0026#34; angle = 360.0/n polyline(t, n, length, angle) def arc(t, r, angle): \u0026#34;\u0026#34;\u0026#34;Draws an arc with the given radius and angle. t: Turtle r: radius angle: angle subtended by the arc, in degrees \u0026#34;\u0026#34;\u0026#34; arc_length = 2 * math.pi * r * abs(angle) / 360 #角度变为绝对值 n = int(arc_length / 4) + 3 #之前是int(arc_length / 3) + 1 step_length = arc_length / n step_angle = float(angle) / n # making a slight left turn before starting reduces # the error caused by the linear approximation of the arc # 在开始前稍微左转可以减少由直线逼近弧线所引起的误差 t.lt(step_angle/2) polyline(t, n, step_length, step_angle) t.rt(step_angle/2) def circle(t, r): \u0026#34;\u0026#34;\u0026#34;Draws a circle with the given radius. t: Turtle r: radius \u0026#34;\u0026#34;\u0026#34; arc(t, r, 360) def draw_circle(t,circ): t.pu() #在移动到圆心的过程中，不画出痕迹（提笔，put up） t.goto(circ.center.x, circ.center.y) t.pd() #落笔（put down） circle(t, circ.radius) bob = turtle.Turtle() tom = Circle() tom.center = Point() tom.center.x = 150 tom.center.y = 100 tom.radius = 75 draw_circle(bob,tom) turtle.mainloop() ","date":"Jan 09","permalink":"https://o5o.me/post/think_python_exercise_15.2/","tags":null,"title":"Think Python Exercise 15.2"},{"categories":["Python"],"contents":" 15.1.1 定义一个叫做Circle类, 类的属性是圆心 (center) 和半径 (radius), 其中, 圆心 (center) 是一个 Point 类,而半径 (radius) 是一个数字。\n实例化一个圆心 (center) 为 (150, 100) ,半径 (radius) 为 75 的Circle 对象。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Circle: \u0026#34;\u0026#34;\u0026#34;属性：圆心center、半径radius 圆心是一个Point类 半径是一个数字 \u0026#34;\u0026#34;\u0026#34; class Point: \u0026#34;\u0026#34;\u0026#34;表示一个二维的点 \u0026#34;\u0026#34;\u0026#34; bob = Circle() bob.center = Point() bob.center.x = 150 bob.center.y = 100 bob.radius = 75 15.1.2 编写一个名称为point_in_circle的函数,该函数可以接受一个圆类 (Circle) 对象和点类 (Point) 对象, 然后判断该点是否在圆内。在圆内则返回True 。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 import math class Circle: \u0026#34;\u0026#34;\u0026#34;属性：圆心center、半径radius 圆心是一个Point类 半径是一个数字 \u0026#34;\u0026#34;\u0026#34; class Point: \u0026#34;\u0026#34;\u0026#34;表示一个二维的点 \u0026#34;\u0026#34;\u0026#34; def point_in_circle(cir,poi): distance = math.sqrt((poi.x-cir.center.x)**2+(poi.y-cir.center.y)**2)#求点到圆心的距离来判断点是否在圆内 if distance \u0026lt;= cir.radius: return True else: return False bob = Circle() bob.center = Point() bob.center.x = 150 bob.center.y = 100 bob.radius = 75 tom = Point() tom.x = 100 tom.y = 101 point_in_circle(bob,tom) 15.1.3 编写一个名称为rect_in_circle的函数,该函数接受一个圆类 (Circle) 对象和矩形(Rectangle) 对象,如果该矩形上的点完全在圆内或者在圆上则返回True。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 import math class Point: \u0026#34;\u0026#34;\u0026#34;表示一个二维的点 \u0026#34;\u0026#34;\u0026#34; class Circle: \u0026#34;\u0026#34;\u0026#34;属性：圆心center、半径radius 圆心是一个Point类 半径是一个数字 \u0026#34;\u0026#34;\u0026#34; class Rectangle: \u0026#34;\u0026#34;\u0026#34;Represents a rectangle. attributes: width, height, corner.\u0026#34;\u0026#34;\u0026#34; def point_in_circle(cir,poi): distance = math.sqrt((poi.x-cir.center.x)**2+(poi.y-cir.center.y)**2)#求点到圆心的距离来判断点是否在圆内 if distance \u0026lt;= cir.radius: return True else: return False def rect_in_circle(cir,rect): #根据矩形左下角的坐标及长宽，得到其他三个点的坐标 topleft = Point() topleft.x = rect.corner.x topleft.y = rect.corner.y + rect.height topright = Point() topright.x = rect.corner.x + rect.width topright.y = rect.corner.y + rect.height bottomright = Point() bottomright.x = rect.corner.x + rect.width bottomright.y = rect.corner.y # 如果矩形的四个点都在圆内或圆上，就可以认为矩形在圆内或圆上 if point_in_circle(cir,topleft) and point_in_circle(cir,topright) and point_in_circle(cir, bottomright) and point_in_circle(cir, rect.corner): return True else: return False bob = Circle() bob.center = Point() bob.center.x = 150 bob.center.y = 100 bob.radius = 75 box = Rectangle() box.width = 100.0 box.height = 200.0 box.corner = Point() box.corner.x = 0.0 box.corner.y = 0.0 rect_in_circle(bob,box) 写到这里插句题外话，我在写代码的时候遇到两次这个类似报错：“AttributeError: \u0026lsquo;Rectangle\u0026rsquo; object has no attribute \u0026lsquo;x\u0026rsquo;”，但我咋看，我定义的函数咋没问题。最后发现，确实不是函数的问题，而是我调用错了函数。因为练习题与练习题之间是有关联的，我是直接在上一题的代码基础上来做这道题，在调用函数的时候，我错误地用了上一题的函数，调用了这一题这个函数对应的参数，所以就报错了。\n15.1.4 编写一个名为 rect_circle_overlap 函数,该函数接受一个圆类对象和一个矩形类对象,如果矩形有任意一个角落在圆内则返回True 。或者写一个更具有挑战性的版本, 如果该矩形有任何部分落在圆内返回True 。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 import math class Point: \u0026#34;\u0026#34;\u0026#34;表示一个二维的点 \u0026#34;\u0026#34;\u0026#34; class Circle: \u0026#34;\u0026#34;\u0026#34;属性：圆心center、半径radius 圆心是一个Point类 半径是一个数字 \u0026#34;\u0026#34;\u0026#34; class Rectangle: \u0026#34;\u0026#34;\u0026#34;Represents a rectangle. attributes: width, height, corner.\u0026#34;\u0026#34;\u0026#34; def point_in_circle(cir,poi): distance = math.sqrt((poi.x-cir.center.x)**2+(poi.y-cir.center.y)**2)#求点到圆心的距离来判断点是否在圆内 if distance \u0026lt;= cir.radius: return True else: return False def rect_circle_overlap(cir, rect): #根据矩形左下角的坐标及长宽，得到其他三个点的坐标 topleft = Point() topleft.x = rect.corner.x topleft.y = rect.corner.y + rect.height topright = Point() topright.x = rect.corner.x + rect.width topright.y = rect.corner.y + rect.height bottomright = Point() bottomright.x = rect.corner.x + rect.width bottomright.y = rect.corner.y # 矩形是否有角落在圆内 if point_in_circle(cir,topleft) or point_in_circle(cir,topright) or point_in_circle(cir, bottomright) or point_in_circle(cir, rect.corner): return True else: return False bob = Circle() bob.center = Point() bob.center.x = 150 bob.center.y = 100 bob.radius = 75 box = Rectangle() box.width = 100.0 box.height = 200.0 box.corner = Point() box.corner.x = 100 box.corner.y = 90 rect_circle_overlap(bob,box) 这里也就是把上一段代码里的 and 换成了 or、改了个函数名。函数其他部分一点都没变。\n","date":"Jan 04","permalink":"https://o5o.me/post/think_python_exercise_15.1/","tags":null,"title":"Think Python Exercise 15.1"},{"categories":["Python"],"contents":"编写一个叫做distance_between_points的函数，它接受两个Point作为参数，然后返回这两个点之间的距离。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 import math class Point: \u0026#34;\u0026#34;\u0026#34;表示一个二维的点 \u0026#34;\u0026#34;\u0026#34; def distance_between_points(p1,p2): return math.sqrt((p1.x - p2.x)**2+(p1.y - p2.y)**2) Po1 = Point() Po2 = Point() Po1.x = 5 Po1.y = 3 Po2.x = 6 Po2.y = 2 distance_between_points(Po1,Po2) 编写一个叫做move_rectangle的函数，接受一个Rectangle以及两个数字dx和dy。它把corner的x坐标加上dx，把corner的y坐标加上dy，从而改变矩形的位置。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 def print_point(p): print(\u0026#39;(%g, %g)\u0026#39; % (p.x, p.y)) class Point: \u0026#34;\u0026#34;\u0026#34;表示一个二维的点 \u0026#34;\u0026#34;\u0026#34; class Rectangle: \u0026#34;\u0026#34;\u0026#34;Represents a rectangle. attributes: width, height, corner.\u0026#34;\u0026#34;\u0026#34; def move_rectangle(rect,dx,dy): rect.corner.x += dx rect.corner.y += dy box = Rectangle() box.width = 100.0 box.height = 200.0 box.corner = Point() box.corner.x = 0.0 box.corner.y = 0.0 move_rectangle(box,20,30) print_point(box.corner) ","date":"Jan 04","permalink":"https://o5o.me/post/think_python_exercise_15.0/","tags":null,"title":"Think Python Exercise 15.0"},{"categories":["Python"],"contents":"将 习题6.2 中的 Ackermann 函数备忘录化(memoize), 看看备忘录化(memoization)是否可以支持解决更大的参数。没有提示!\n储存之前计算过的值以便今后使用，这个操作就称为备忘录化。\n做这道题首先要理解书上关于斐波那契数列的例子。\n计算斐波那契数列的代码：\n1 2 3 4 5 6 7 def fibonacci(n): if n == 0: return 0 elif n == 1: return 1 else: return fibonacci(n-1) + fibonacci(n-2) 备忘录化后的代码：\n1 2 3 4 5 6 7 8 9 known = {0:0, 1:1} def fibonacci(n): if n in known: return known[n] res = fibonacci(n-1) + fibonacci(n-2) known[n] = res return res 按照同样的思路，我们可以把计算的ack函数的值储存到字典里，后面再计算时先看之前是不是曾计算过，如果计算过，直接调用已有结果即可。\n原ack函数代码：\n1 2 3 4 5 6 7 8 def ackermann(m,n): #来自6.2 if m == 0: return n+1 if n == 0: return ackermann(m-1,1) return ackermann(m-1, ackermann(m,n-1)) print(ackermann(3,4)) 备忘录化后的ack代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 known = {} def ackermann(m,n): if (m,n) in known: return known[m,n] if m == 0: res = n+1 known[m,n] = res return res if n == 0: res = ackermann(m-1,1) known[m,n] = res return res res = ackermann(m-1, ackermann(m,n-1)) known[m,n] = res return res print(ackermann(3,4)) 可以注意到我用了元组作为字典的键，元组是下一章学的，这里用是因为我觉得没有比元组更合适的了。\n在 jupyter lab 里可以通过在代码第一行写%%time查看代码运行时间，经比较，可以发现备忘录化后的计算速度快了很多很多：\n1 2 3 4 5 6 7 8 9 %%time def ackermann(m,n): if m == 0: return n+1 if n == 0: return ackermann(m-1,1) return ackermann(m-1, ackermann(m,n-1)) print(ackermann(3,6)) 509 CPU times: user 55 ms, sys: 4.78 ms, total: 59.8 ms Wall time: 66.4 ms 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 %%time known = {} def ackermann(m,n): if (m,n) in known: return known[m,n] if m == 0: res = n+1 known[m,n] = res return res if n == 0: res = ackermann(m-1,1) known[m,n] = res return res res = ackermann(m-1, ackermann(m,n-1)) known[m,n] = res return res print(ackermann(3,6)) 509 CPU times: user 3.09 ms, sys: 1.51 ms, total: 4.59 ms Wall time: 5.48 ms 再大的数我就不试了。你感兴趣可以试试ackermann(4,3)/手动狗头。\n","date":"Jan 03","permalink":"https://o5o.me/post/think_python_exercise_11.3_ackermann/","tags":null,"title":"Think Python Exercise 11.3 阿克曼函数"},{"categories":["Python"],"contents":"Ackermann 函数 $A(m, n)$ 的定义如下:\n$$ A(m, n)=\\left{\\begin{array}{ll} n+1 \u0026amp; \\text { if } m=0 \\ A(m-1,1) \u0026amp; \\text { if } m\u0026gt;0 \\text { and } n=0 \\ A(m-1, A(m, n-1)) \u0026amp; \\text { if } m\u0026gt;0 \\text { and } n\u0026gt;0 \\end{array}\\right. $$\n查看维基百科的定义, 编写一个叫作ack的函数来计算 Ackermann 函数。使用你的函 数计算ack(3,4), 其结果应该为 125 。如果 $m$ 和 $n$ 的值较大时, 会发生什么?\n拙见：\n1 2 3 4 5 6 7 8 9 def ack(m,n): if m == 0: return n+1 elif m \u0026gt; 0 and n == 0: return ack(m-1,1) elif m \u0026gt; 0 and n \u0026gt; 0: return ack(m-1,ack(m,n-1)) ack(3,4) 似乎看上去平平无奇，把它的计算过程展示出来：\n1 2 3 4 5 6 7 8 9 10 11 12 def ack(m,n): if m == 0: print(n+1) return n+1 elif m \u0026gt; 0 and n == 0: print(\u0026#39;ack(\u0026#39;,m-1,\u0026#39;,\u0026#39;,1,\u0026#39;)\u0026#39;) return ack(m-1,1) elif m \u0026gt; 0 and n \u0026gt; 0: print(\u0026#39;ack(\u0026#39;,m-1,\u0026#39;,ack(\u0026#39;,m,\u0026#39;,\u0026#39;,n-1,\u0026#39;))\u0026#39;) return ack(m-1,ack(m,n-1)) ack(3,4) 你可以自己动手运行一下看看，实际上进行了上万次递归。\n作者的写法更简洁一些：\n1 2 3 4 5 6 7 8 def ackermann(m,n): if m == 0: return n+1 if n == 0: return ackermann(m-1,1) return ackermann(m-1, ackermann(m,n-1)) print(ackermann(3,4)) （补充说明一下，我的代码是在jupyter lab里运行的，所以不用使用print函数也能把结果显示出来。）\n","date":"Jan 03","permalink":"https://o5o.me/post/think_python_exercise_6.2_ackermann/","tags":null,"title":"Think Python Exercise 6.2 阿克曼函数"},{"categories":["Python"],"contents":"画出下面程序的堆栈图。这个程序的最终输出是什么?\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 def b(z): prod = a(z, z) print(z, prod) return prod def a(x, y): x = x + 1 return x * y def c(x, y, z): total = x + y + z square = b(total)**2 return square x = 1 y = x + 1 print(c(x, y+3, x+y)) 程序的最终输出：8100\n应该没有特别的意义吧？\n","date":"Jan 03","permalink":"https://o5o.me/post/think_python_exercise_6.1/","tags":null,"title":"Think Python Exercise 6.1"},{"categories":["Python"],"contents":"查看字典方法setdefault的文档, 并使用该方法写一个更简洁的invert_dict。\n原来的函数的定义：\n1 2 3 4 5 6 7 8 9 10 11 def invert_dict(d): \u0026#34;\u0026#34;\u0026#34;倒转一个字典，将原字典的值作为键，原字典的键作为值。 \u0026#34;\u0026#34;\u0026#34; inverse = dict() for key in d: val = d[key] if val not in inverse: inverse[val] = [key] #反转后，一个键可能对应多个值，所以把值放到列表里 else: inverse[val].append(key) #相当于给列表追加一个值。键val的值是一个列表。 return inverse 文档链接：这里\nsetdefault(key[, default]), 如果字典存在键 key ，返回它的值。如果不存在，插入值为 default 的键 key ，并返回 default 。 default 默认为 None。\n1 2 3 4 5 6 7 8 9 10 def invert_dict(d): \u0026#34;\u0026#34;\u0026#34;倒转一个字典，将原字典的值作为键，原字典的键作为值。 \u0026#34;\u0026#34;\u0026#34; inverse = dict() for key in d: inverse[d[key]]=inverse.setdefault(d[key],[])+[key] return inverse A = {\u0026#39;a\u0026#39;:2,\u0026#39;b\u0026#39;:3,\u0026#39;c\u0026#39;:2} invert_dict(A) 做这种题有助于提高自信。不建议看答案，看完你会有：“为啥我就没想到”这种想法，进一步怀疑自己的智商。\n","date":"Jan 03","permalink":"https://o5o.me/post/think_python_exercise_11.2/","tags":null,"title":"Think Python Exercise 11.2 字典方法setdefault"},{"categories":["Python"],"contents":"编写一函数,读取words.txt中的单词并存储为字典中的键。值是什么无所谓。然后,你可以使用in操作符检查一个字符串是否在字典中。\n如果你做过练习 10.10 ,可以比较一下in操作符和二分查找的速度。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 def make_word_list(): word_list = [] fin = open(\u0026#39;words.txt\u0026#39;) for line in fin: word = line.strip() word_list.append(word) return word_list def dictword(w_li): word_dict = dict() for word in w_li: word_dict[word] = \u0026#39;ok\u0026#39; #题目说值是什么无所谓 return word_dict word_list = make_word_list() word_dict = dictword(word_list) \u0026#39;aha\u0026#39; in word_dict 我就不比较in操作符和二分查找的速度了。\n","date":"Jan 03","permalink":"https://o5o.me/post/think_python_exercise_11.1/","tags":null,"title":"Think Python Exercise 11.1"},{"categories":["Python"],"contents":"两个单词中如果一个是另一个的反转, 则二者被称为是 ‘‘反转词对’’。 编写一个函数,找出单词表中所有的反转词对。\n解答：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 def read_word1(file_in): #来自10.9 word_list = [] for line in file_in: word = line.strip() word_list.append(word) return word_list def in_bisect(t,a): #来自10.10 \u0026#34;\u0026#34;\u0026#34;列表t，单词a，看单词是否在列表内，在的话返回单词的位置。 列表里的单词，必须是已经按字母顺序排好序的。 \u0026#34;\u0026#34;\u0026#34; s1 = int((len(t))/2) s = s1 #如果a在t内，s保存a的序数 while s1 \u0026gt; 0: if a == t[s1]: return s elif a \u0026gt; t[s1]: t = t[s1:] s1 = int(len(t)/2) #在循环过程中，确保s和s1所指的是同一个元素。 #print(a,\u0026#34;的位置大于\u0026#34;,s) s += s1 else: t = t[:s1] s1 = int(len(t)/2) #print(a,\u0026#34;的位置小于等于\u0026#34;,s) s -= s1 return None def findpairs(word_li): i = 0 for word in word_li: drow = word[::-1] #将单词里的字母按照相反的顺序排列 k = in_bisect(word_li[i:],drow) #写word_list[i:]目的是不让程序往前去找所谓的“反转词” if k: print(word,\u0026#39;和\u0026#39;,word_li[k+i]) i += 1 fin = open(\u0026#39;words.txt\u0026#39;) word_list = read_word1(fin) findpairs(word_list) 我在10.10题写的in_bisect函数有误差，导致上面的代码虽然能找到‘‘反转词对’，但在输出的时候有偏差。今天很晚了(0:44)，后面有机会再改吧。\n下面我用了Python的bisect模块：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 import bisect def read_word1(file_in): #来自10.9 word_list = [] for line in file_in: word = line.strip() word_list.append(word) return word_list def findpairs(word_li): for i in range(len(word_li)): drow = word_li[i][::-1] #将单词里的字母按照相反的顺序排列 k = bisect.bisect(word_li[i:],drow) #写word_list[i:]目的是不让程序往前去找所谓的“反转词” if drow == word_li[i+k-1]: print(i,word_li[i],\u0026#39;和\u0026#39;,i+k-1,word_li[i+k-1]) fin = open(\u0026#39;words.txt\u0026#39;) word_list = read_word1(fin) findpairs(word_list) 输出看起来很美好，但是我稍微变一下，它就不正常了：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 import bisect def read_word1(file_in): #来自10.9 word_list = [] for line in file_in: word = line.strip() word_list.append(word) return word_list def findpairs(word_li): for i in range(len(word_li)): drow = word_li[i][::-1] #将单词里的字母按照相反的顺序排列 k = bisect.bisect(word_li[i:],drow) #写word_list[i:]目的是不让程序往前去找所谓的“反转词” if k: print(i,word_li[i],\u0026#39;和\u0026#39;,i+k-1,word_li[i+k-1]) fin = open(\u0026#39;words.txt\u0026#39;) word_list = read_word1(fin) findpairs(word_list) 我把if里的drow == word_li[i+k-1]改成k，输出就不正常了，打印出来的一对单词 就不是‘‘反转词对’’了。而且因为单词表里的单词很多（十几万个），电脑还会卡死。\n看看作者答案是怎么写的吧：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 from __future__ import print_function, division from inlist import in_bisect, make_word_list def reverse_pair(word_list, word): rev_word = word[::-1] return in_bisect(word_list, rev_word) if __name__ == \u0026#39;__main__\u0026#39;: word_list = make_word_list() for word in word_list: if reverse_pair(word_list,word): print(word, word[::-1]) 有点失望，作者的代码完全没有涉及到下标的加加减减。\n","date":"Jan 02","permalink":"https://o5o.me/post/think_python_exercise_10.11/","tags":null,"title":"Think Python Exercise 10.11"},{"categories":["Python"],"contents":"使用in运算符可以检查一个单词是否在单词表中, 但这很慢, 因为它是按顺序查找单词。\n由于单词是按照字母顺序排序的,我们可以使用两分法 (也称二叉树搜索) 来加快速度, 类似于在字典中查找单词的方法。你从中间开始,如果你要找的单词在中间的单词之前,你查找前半部分,否则你查找后半部分。\n不管怎样, 你都会将搜索范围减小一半。 如果单词表有 113,809 个单词, 你只需要 17 步就可以找到这个单词,或着得出单词不存在的结论。\n编写一个叫做in_bisect的函数,接受一个已排序的列表和一个目标值作为参数,返回该值在列表中的位置,如果不存在则返回None。\n或者你可以阅读bisect模块的文档并使用它!\n解答：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 def in_bisect(t,a): \u0026#34;\u0026#34;\u0026#34;列表t，单词a，看单词是否在列表内，在的话返回单词的位置。 列表里的单词，必须是已经按字母顺序排好序的。 \u0026#34;\u0026#34;\u0026#34; s1 = int((len(t))/2) s = s1 #如果a在列表内，s保存a的下标 while s1 \u0026gt; 0: if a == t[s1]: return s elif a \u0026gt; t[s1]: t = t[s1:] s1 = int(len(t)/2) #在循环过程中，确保s和s1所指的是同一个元素。 #print(a,\u0026#34;的位置大于\u0026#34;,s) s += s1 else: t = t[:s1] s1 = int(len(t)/2) #print(a,\u0026#34;的位置小于等于\u0026#34;,s) s -= s1 return None t1 = [\u0026#39;a\u0026#39;,\u0026#39;b\u0026#39;,\u0026#39;c\u0026#39;,\u0026#39;d\u0026#39;,\u0026#39;e\u0026#39;,\u0026#39;f\u0026#39;,\u0026#39;g\u0026#39;,\u0026#39;h\u0026#39;,\u0026#39;i\u0026#39;,\u0026#39;j\u0026#39;,\u0026#39;k\u0026#39;,\u0026#39;l\u0026#39;,\u0026#39;m\u0026#39;,\u0026#39;n\u0026#39;,\u0026#39;o\u0026#39;,\u0026#39;p\u0026#39;,\u0026#39;q\u0026#39;] in_bisect(t1,\u0026#39;c\u0026#39;) s和s1这两个变量，保存的是列表元素的下标。在循环过程中，确保s和s1所指的是同一个元素，即：s保存的是元素在完整列表里的下标，s1保存的是元素在切片后的列表里的下标，在两个列表里，第s个元素和第s1个元素（都从0开始）是同一个元素。\n因为涉及到除法然后取整，写代码的时候老是担心误差，总想对下标加个1或减个1，所得到的结果越来越离谱，后来干脆不加不减，反倒顺顺利利的。真的就是做多错多。代码虽然是我写出来的，但实际上我对它的运行过程并不是了如指掌。\n我画了一个图来跟踪代码运行时的状态，不能叫堆栈图，就单纯是为了跟踪变量在一次循环后会如何变化。\n这是作者的代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 import bisect def make_word_list(): word_list = [] fin = open(\u0026#39;words.txt\u0026#39;) for line in fin: word = line.strip() word_list.append(word) return word_list def in_bisect(word_list, word): \u0026#34;\u0026#34;\u0026#34;通过二分法，检查一个单词是否在一个列表里 前置条件：列表里的单词是已排序的 returns：如果单词在，返回True，否则返回False \u0026#34;\u0026#34;\u0026#34; if len(word_list) == 0: return False i = len(word_list)//2 if word_list[i] == word: return True if word_list[i] \u0026gt; word: return in_bisect(word_list[:i],word) else: return in_bisect(word_list[i+1:],word) def in_bisect_cheat(word_list,word): i = bisect.bisect_left(word_list,word) if i == len(word_list): return False return word_list[i] == word if __name__ == \u0026#39;__main__\u0026#39;: word_list = make_word_list() for word in [\u0026#39;aa\u0026#39;, \u0026#39;alien\u0026#39;, \u0026#39;allen\u0026#39;, \u0026#39;zymurgy\u0026#39;]: print(word, \u0026#39;in list\u0026#39;, in_bisect(word_list, word)) for word in [\u0026#39;aa\u0026#39;, \u0026#39;alien\u0026#39;, \u0026#39;allen\u0026#39;, \u0026#39;zymurgy\u0026#39;]: print(word, \u0026#39;in list\u0026#39;, in_bisect_cheat(word_list, word)) 用了递归，比我写的高明很多。我的代码一比较，就跟直肠子似的，没有一点弯弯绕。\n但是作者并没有返回单词在列表的下标，只是简单返回一个True或False。\n","date":"Jan 02","permalink":"https://o5o.me/post/think_python_exercise_10.10/","tags":null,"title":"Think Python Exercise 10.10 二分法"},{"categories":["Python"],"contents":"编写一个叫做middle的函数,接受一个列表作为参数,并返回一个除了第一个和最后一个元素的列表。例如:\n\u0026gt;\u0026gt;\u0026gt; t = [1, 2, 3, 4] \u0026gt;\u0026gt;\u0026gt; middle(t) [2, 3] 解答：\n1 2 3 4 5 def middle(t): return t[1:-1] t1 = [1,2,3,4] middle(t1) ","date":"Jan 02","permalink":"https://o5o.me/post/think_python_exercise_10.3/","tags":null,"title":"Think Python Exercise 10.3"},{"categories":["Python"],"contents":"编写一个叫做 has_duplicates 的函数，接受一个列表作为参数，如果一个元素在列表中出现了不止一次，则返回 True 。这个函数不能改变原列表。\n解答：\n1 2 3 4 5 6 7 8 9 10 11 12 def has_duplicates(t): p = [] for i in t: if i not in p: p.append(i) else: return True return False t1 = [1,2,3] has_duplicates(t1) ","date":"Jan 02","permalink":"https://o5o.me/post/think_python_exercise_10.7/","tags":null,"title":"Think Python Exercise 10.7"},{"categories":null,"contents":"Roam Research是一个笔记软件，Anki是一个间隔重复软件。我在RR里写的笔记有复习需求，在Anki里的卡片有编辑、整理需求，所以以前的我就用Keyboard Maestro这个工具写了一个动作（Macro）来帮我将二者联系起来。\nRR的笔记可以导出为Anki卡片（卡片仅用于复习、展示，所有的编辑都在笔记上完成），笔记更新，卡片能同步更新，笔记和卡片能相互跳转。\n可以按下面的顺序进行配置（所需文件在文章最后），手把手教学请看视频：\n【详细配置】Keyboard Maestro动作实现Roam Research笔记和Anki卡片的双向链接、跳转和同步更新，配置指南\nAnki模板导入、修改 要改的地方就一处：修改模板里的RR graph名称。不改的话就没办法从Anki跳转回RR了。\nKM动作导入、修改 要改的地方也就只有一处：把你的Anki牌组的名字填进去。\nAnki插件安装 anki connect，插件代码：2055492159\n禁用App Nap 从Mac OS X Mavericks开始，操作系统中引入了名为App Nap的功能。此功能导致某些打开（但不可见）的应用程序处于挂起状态。由于此行为会导致Anki Connect在前台有另一个窗口时停止工作，因此应禁用Anki的App Nap1。\n在终端运行下面的命令即可。\n1 2 3 defaults write net.ankiweb.dtop NSAppSleepDisabled -bool true defaults write net.ichi2.anki NSAppSleepDisabled -bool true defaults write org.qt-project.Qt.QtWebEngineCore NSAppSleepDisabled -bool true 最后 这就配置完成了，是不是很简单？quicker版的动作配置更简单，除了下载插件，啥都不用配置，自动配置。想想以前真的傻，我给quicker版的这个动作加了批量导入、多种挖空标记、多种方式排列的笔记导入、自动从Anki获取牌组列表、自动添加Anki模板等等功能，这些功能在我现在看来用途很小很小，但当时却花了大量时间去改动作、修bug，浪费了很多时间在完全没必要的事情上。\n模板、动作下载链接: 百度网盘，提取码: 3tvu\n希望能给看到这里的你带来一些帮助。\nNotes for MacOS Users\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"Jan 02","permalink":"https://o5o.me/post/rr_km_anki_configuration_tutorial/","tags":["Anki","RoamResearch","KeyboardMaestro","bilibili"],"title":"Roam Research和Anki联用：动作配置"},{"categories":["Python"],"contents":" 画一个执行 circle(bob,radius) 时的堆栈图（stack diagram），说明程序的各个状态。你可以手动进行计算，也可以在代码中加入打印语句。 “重构”一节中给出的 arc 函数版本并不太精确，因为圆形的线性近似（linear approximation）永远处在真正的圆形之外。因此，Turtle 总是和正确的终点相差几个像素。我的答案中展示了降低这个错误影响的一种方法。阅读其中的代码，看看你是否能够理解。如果你画一个堆栈图的话，你可能会更容易明白背后的原理。 先放上代码，得到代码过程可以看Think Python Exercise 4.0。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 import turtle import math def polyline(t,length,n,angle): for i in range(n): t.fd(length) t.lt(angle) def arc(t,r,angle): \u0026#34;\u0026#34;\u0026#34;angle取值范围是1~360，度数。 画出圆的一部分。 \u0026#34;\u0026#34;\u0026#34; arc_length = 2 * math.pi * r * angle / 360 n = int(arc_length / 3) + 1 step_length = arc_length / n step_angle = angle / n polyline(t,step_length,n,step_angle) def circle(t,r): arc(t,r,360) #circle是arc函数在角度angle取360时的特例 bob = turtle.Turtle() circle(bob,100) turtle.mainloop() 我画的堆栈图如下：\n来看看作者重构的代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 \u0026#34;\u0026#34;\u0026#34;This module contains a code example related to Think Python, 2nd Edition by Allen Downey http://thinkpython2.com Copyright 2015 Allen Downey License: http://creativecommons.org/licenses/by/4.0/ \u0026#34;\u0026#34;\u0026#34; from __future__ import print_function, division import math import turtle def square(t, length): \u0026#34;\u0026#34;\u0026#34;Draws a square with sides of the given length. Returns the Turtle to the starting position and location. \u0026#34;\u0026#34;\u0026#34; for i in range(4): t.fd(length) t.lt(90) def polyline(t, n, length, angle): \u0026#34;\u0026#34;\u0026#34;Draws n line segments. t: Turtle object n: number of line segments length: length of each segment angle: degrees between segments \u0026#34;\u0026#34;\u0026#34; for i in range(n): t.fd(length) t.lt(angle) def polygon(t, n, length): \u0026#34;\u0026#34;\u0026#34;Draws a polygon with n sides. t: Turtle n: number of sides length: length of each side. \u0026#34;\u0026#34;\u0026#34; angle = 360.0/n polyline(t, n, length, angle) def arc(t, r, angle): \u0026#34;\u0026#34;\u0026#34;Draws an arc with the given radius and angle. t: Turtle r: radius angle: angle subtended by the arc, in degrees \u0026#34;\u0026#34;\u0026#34; arc_length = 2 * math.pi * r * abs(angle) / 360 #角度变为绝对值 n = int(arc_length / 4) + 3 #之前是int(arc_length / 3) + 1 step_length = arc_length / n step_angle = float(angle) / n # making a slight left turn before starting reduces # the error caused by the linear approximation of the arc # 在开始前稍微左转可以减少由直线逼近弧线所引起的误差 t.lt(step_angle/2) polyline(t, n, step_length, step_angle) t.rt(step_angle/2) def circle(t, r): \u0026#34;\u0026#34;\u0026#34;Draws a circle with the given radius. t: Turtle r: radius \u0026#34;\u0026#34;\u0026#34; arc(t, r, 360) # the following condition checks whether we are # running as a script, in which case run the test code, # or being imported, in which case don\u0026#39;t. if __name__ == \u0026#39;__main__\u0026#39;: bob = turtle.Turtle() # draw a circle centered on the origin radius = 100 bob.pu() #抬笔 bob.fd(radius) bob.lt(90) bob.pd() #落笔 circle(bob, radius) # wait for the user to close the window turtle.mainloop() 我画的堆栈图：\n代码主要的变化在于，作者换了种方式来计算用于近似圆的多边形的边数，所需边数更少了；在开始画画之前，让turtle稍微左转（多边形外角角度的一半），减少由直线逼近弧线所引起的误差。\n目前就分析出这么多。\n","date":"Jan 01","permalink":"https://o5o.me/post/think_python_exercise_4.1/","tags":null,"title":"Think Python Exercise 4.1"},{"categories":["Python"],"contents":" 写一个名为 square 的函数，接受一个名为 t 的形参，t 是一个海龟。这个函数应用这只海龟画一个正方形。 写一个函数调用，将 bob 作为实参传给 square ，然后再重新运行程序。\n1 2 3 4 5 6 7 8 9 10 11 12 import turtle def square(t): for i in range(4): t.fd(100) t.lt(90) bob = turtle.Turtle() square(bob) turtle.mainloop() 给 square 增加另一个名为 length 的形参。修改函数体，使得正方形边的长度是 length ，然后修改函数调用，提供第二个实参。 重新运行程序。用一系列 length 值测试你的程序。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import turtle def square(t,length): for i in range(4): t.fd(length) t.lt(90) bob = turtle.Turtle() square(bob,100) square(bob,120) square(bob,150) square(bob,200) turtle.mainloop() 复制 square ，并将函数改名为 polygon 。增加另外一个名为 n 的形参并修改函数体，让它画一个正n边形（n-sided regular polygon）。提示：正n边形的外角是$360/n$度。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 import turtle def polygon(t,length,n): for i in range(n): t.fd(length) t.lt(360/n) bob = turtle.Turtle() polygon(bob,100,6) polygon(bob,100,8) polygon(bob,100,15) turtle.mainloop() 看了答案后，觉得把360/n放到循环外面比较好，这样的话只需要计算一次。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import turtle def polygon(t,length,n): angle = 360 / n for i in range(n): t.fd(length) t.lt(angle) bob = turtle.Turtle() polygon(bob,100,6) polygon(bob,100,8) polygon(bob,100,15) turtle.mainloop() 编写一个名为 circle 的函数，它接受一个海龟t和半径r作为形参， 然后以合适的边长和边数调用 polygon ，画一个近似圆形。 用一系列r值测试你的函数。 提示：算出圆的周长，并确保 length * n = circumference 。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 import turtle import math def polygon(t,length,n): for i in range(n): t.fd(length) t.lt(360/n) def circle(t,r): \u0026#34;\u0026#34;\u0026#34;t是一只乌龟。r是所要画的圆的半径。 根据公式$2 \\pi r / n$确定用于近似圆的多边形的边长，n是多边形的边数。 \u0026#34;\u0026#34;\u0026#34; circumference = 2 * math.pi * r #周长 n = 200 #多边形边数，我想不到选多少边数合适，直接设200，画一个200边形 length = circumference / n polygon(t,length,n) bob = turtle.Turtle() circle(bob,150) #半径r设为150 turtle.mainloop() 答案是这样来确定n的值（多边形的边数）的：周长除以3，取整后加1，即n = int(circumference/3)+1，也就是近似为周长的三分之一，圆的半径的两倍。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 import turtle import math def polygon(t,length,n): angle = 360 / n for i in range(n): t.fd(length) t.lt(angle) def circle(t,r): \u0026#34;\u0026#34;\u0026#34;t是一只乌龟。r是所要画的圆的半径。 根据公式$2 \\pi r / n$确定用于近似圆的多边形的边长，n是多边形的边数。 \u0026#34;\u0026#34;\u0026#34; circumference = 2 * math.pi * r #周长 n = int(circumference/3)+1 #改的是这句 length = circumference / n polygon(t,length,n) bob = turtle.Turtle() circle(bob,150) #半径r设为150 turtle.mainloop() 完成一个更泛化（general）的 circle 函数，称其为 arc ，接受一个额外的参数 angle ，确定画多完整的圆。angle 的单位是度，因此当 angle=360 时， arc 应该画一个完整的圆。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 import turtle import math def polyline(t,length,n,m): \u0026#34;\u0026#34;\u0026#34;n是多边形的边数，m是指画出多边形的前多少条边 n和m必须为整数。 \u0026#34;\u0026#34;\u0026#34; for i in range(m): t.fd(length) t.lt(360/n) def arc(t,r,angle): \u0026#34;\u0026#34;\u0026#34;angle取值范围是1~360，度数。 画出圆的一部分。 \u0026#34;\u0026#34;\u0026#34; circumference = 2 * math.pi * r #周长 n = 200 #多边形边数，我想不到选多少边数合适，直接设200 length = circumference / n #多边形边长 m = int(n * angle / 360) # 画出多边形的前m条边 polyline(t,length,n,m) bob = turtle.Turtle() arc(bob,150,30) arc(bob,100,150) arc(bob,150,270) turtle.mainloop() 我是先算出来圆的周长，然后算出用于近似这个圆的多边形的边数，然后再算出近似圆的一部分需要的多边形的边数；\n答案是先算圆的一部分对应的长度，根据这个长度得到用边数为n的多边形去近似圆，然后得到一边的长度，以及多边形的外角的角度。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 import turtle import math def polyline(t,length,n,angle): for i in range(n): t.fd(length) t.lt(angle) def arc(t,r,angle): \u0026#34;\u0026#34;\u0026#34;angle取值范围是1~360，度数。 画出圆的一部分。 \u0026#34;\u0026#34;\u0026#34; arc_length = 2 * math.pi * r * angle / 360 n = int(arc_length / 3) + 1 step_length = arc_length / n step_angle = angle / n polyline(t,step_length,n,step_angle) bob = turtle.Turtle() arc(bob,150,30) arc(bob,100,150) arc(bob,150,270) turtle.mainloop() 根据这一题的代码，可以重写第四题的circle函数。circle函数可以看作是arc函数的一个特例。\n1 2 def circle(t,r): arc(t,r,360) ","date":"Jan 01","permalink":"https://o5o.me/post/think_python_exercise_4.0/","tags":null,"title":"Think Python Exercise 4.0"},{"categories":["Python"],"contents":"下面程序的输出是什么？画出展示程序每次打印输出时的堆栈图。\n1 2 3 4 5 6 7 def recurse(n, s): if n == 0: print(s) else: recurse(n-1, n+s) recurse(3, 0) 如果你这样调用函数： recurse(-1,0) ，会有什么结果？ 请写一个文档字符串，解释调用该函数时需要了解的全部信息（仅此而已）。 解答：\n我用obsidian的Excalidraw插件画了一个。\n如果这样调用函数： recurse(-1,0)，Python会抛出一个递归错误：超过最大递归深度。\n\u0026gt;\u0026gt;\u0026gt; recurse(-1,0) Traceback (most recent call last): File \u0026#34;\u0026lt;stdin\u0026gt;\u0026#34;, line 1, in \u0026lt;module\u0026gt; File \u0026#34;\u0026lt;stdin\u0026gt;\u0026#34;, line 5, in recurse File \u0026#34;\u0026lt;stdin\u0026gt;\u0026#34;, line 5, in recurse File \u0026#34;\u0026lt;stdin\u0026gt;\u0026#34;, line 5, in recurse [Previous line repeated 996 more times] RecursionError: maximum recursion depth exceeded 写一个文档字符串，解释调用该函数时需要了解的全部信息\n1 2 3 4 5 6 7 8 9 10 11 def recurse(n, s): \u0026#34;\u0026#34;\u0026#34;将s与前n个正整数（从1到n）相加， n是一个正整数， s可以是任意数字 \u0026#34;\u0026#34;\u0026#34; if n == 0: print(s) else: recurse(n-1, n+s) recurse(3, -5) ","date":"Jan 01","permalink":"https://o5o.me/post/think_python_exercise_5.4/","tags":null,"title":"Think Python Exercise 5.4"},{"categories":["RegEx"],"contents":"最近在用SuperMemo渐进阅读旋元佑的《英语魔法师之语法俱乐部》这本语法书。我的阅读前流程是这样的：（括号内的是所用工具）\n将epub电子书按章节分割（calibre-EpubSplit） 将需要阅读的章节导入SuperMemo（Quicker、pandoc、AutoHotkey） 在SuperMemo内将该章节分割成更小的卡片（鼠标右键-阅读-分割-分割文章） 统一将所得的所有卡片设为新材料（根卡片鼠标右键-处理选中分支-学习-忘记） 菜单栏-学习-阶段-新学材料（也可等当天复习完后根据提示进入） 问题在于，我所拥有的这本epub电子书，html标签很乱，导致我在导入SM后无法正确根据html标签分割文章，因此在导入SM前需要先整理epub文件的html标签。这也就是这篇文章的由来。\n截取这本书的一个片段：\n1 \u0026lt;p class=\u0026#34;calibre_16\u0026#34;\u0026gt;以上谈的是修饰动词专用的“方法、状态副词”，以及它在句中位置的变化原则。接下来看看其他种类的副词。\u0026lt;/p\u0026gt;\u0026lt;blockquote class=\u0026#34;calibre_5\u0026#34;\u0026gt;\u0026lt;blockquote class=\u0026#34;calibre2\u0026#34;\u0026gt;\u0026lt;blockquote class=\u0026#34;calibre2\u0026#34;\u0026gt;\u0026lt;blockquote class=\u0026#34;calibre2\u0026#34;\u0026gt;\u0026lt;blockquote class=\u0026#34;calibre_21\u0026#34;\u0026gt;\u0026lt;span class=\u0026#34;calibre1\u0026#34;\u0026gt;\u0026lt;span class=\u0026#34;bold\u0026#34;\u0026gt;\u0026lt;span class=\u0026#34;calibre_12\u0026#34;\u0026gt;强调语气的副词（Intensifiers)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\u0026lt;/blockquote\u0026gt;\u0026lt;/blockquote\u0026gt;\u0026lt;/blockquote\u0026gt;\u0026lt;/blockquote\u0026gt;\u0026lt;a id=\u0026#34;filepos295095\u0026#34;\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/blockquote\u0026gt;\u0026lt;p class=\u0026#34;calibre_24\u0026#34;\u0026gt;这一类副词有一个特色：它在使用上很有弹性，\u0026lt;span class=\u0026#34;bold\u0026#34;\u0026gt;四种主要词类，包括名词、动词、形容词与副词都可以用它来修饰。\u0026lt;/span\u0026gt;认识这一点，才算真正弄清楚形容词与副词间的分工。这一类的副词又可以细分为以下三种：\u0026lt;/p\u0026gt; 所要做的是把下面这一段变为：\u0026lt;h2\u0026gt;强调语气的副词（Intensifiers)\u0026lt;/h2\u0026gt;，这样我就可以在SM里很方便地按h2标签分割内容。\n1 \u0026lt;blockquote class=\u0026#34;calibre2\u0026#34;\u0026gt;\u0026lt;blockquote class=\u0026#34;calibre2\u0026#34;\u0026gt;\u0026lt;blockquote class=\u0026#34;calibre2\u0026#34;\u0026gt;\u0026lt;blockquote class=\u0026#34;calibre_21\u0026#34;\u0026gt;\u0026lt;span class=\u0026#34;calibre1\u0026#34;\u0026gt;\u0026lt;span class=\u0026#34;bold\u0026#34;\u0026gt;\u0026lt;span class=\u0026#34;calibre_12\u0026#34;\u0026gt;强调语气的副词（Intensifiers)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\u0026lt;/blockquote\u0026gt;\u0026lt;/blockquote\u0026gt;\u0026lt;/blockquote\u0026gt;\u0026lt;/blockquote\u0026gt; 可以看到，一共是4个blockquote标签，3个span标签，那么我们可以先设法用正则匹配出一个起始blockquote标签，然后重复4次，匹配出一个起始span标签，然后重复3词，就能匹配出所有的起始标签了。\n(\u0026lt;blockquote\\s[^\u0026gt;]*\u0026#34;\u0026gt;){4}(\u0026lt;span\\s[^\u0026gt;]*\u0026#34;\u0026gt;){3} 同样的道理，匹配所有的闭合标签。\n(\u0026lt;\\/span\u0026gt;){3}(\u0026lt;/blockquote\u0026gt;){4} 最后，标题可以用(.*?)匹配，把它们组合在一起，就成功匹配出了这段html代码。\n(\u0026lt;blockquote\\s[^\u0026gt;]*\u0026#34;\u0026gt;){4}(\u0026lt;span\\s[^\u0026gt;]*\u0026#34;\u0026gt;){3}(.*?)(\u0026lt;\\/span\u0026gt;){3}(\u0026lt;/blockquote\u0026gt;){4} 将其用下面的内容替换，内容就整理好了。\n\\n\u0026lt;h2\u0026gt;$3\u0026lt;/h2\u0026gt;\\n 上面的正则，经过我的实践，是比较经济实惠的。以后如果有更好的方案，本文会继续更新。\n","date":"Dec 31","permalink":"https://o5o.me/post/regexps_match_html_tags/","tags":["SuperMemo","Epub"],"title":"正则表达式匹配HTML标签"},{"categories":["Python"],"contents":"如果可以通过重排一个单词中字母的顺序，得到另外一个单词，那么称这两个单词是变位词。编写一个叫做 is_anagram 的函数，接受两个字符串作为参数， 如果它们是变位词则返回 True 。\n解答：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 def is_anagram(s1,s2): t1 = list(s1) t2 = list(s2) #先把字符串转换成列表 if len(t1) == len(t2): #如果两个字符串长度都不一样，那么肯定不是变位词了 t1.sort() t2.sort() #按照同样的方式重新排序后，如果二者元素对应相等，那么它们就是变位词了 for i in range(len(t1)): if t1[i] == t2[i]: pass else: return False return True else: return False is_anagram(\u0026#39;abc\u0026#39;,\u0026#39;bac\u0026#39;) ","date":"Dec 31","permalink":"https://o5o.me/post/think_python_exercise_10.6/","tags":null,"title":"Think Python Exercise 10.6"},{"categories":["Python"],"contents":"编写一个叫做is_sorted的函数，接受一个列表作为参数，如果列表是递增排列的则返回 True ，否则返回False。 例如：\n\u0026gt;\u0026gt;\u0026gt; is_sorted([1, 2, 2]) True \u0026gt;\u0026gt;\u0026gt; is_sorted([\u0026#39;b\u0026#39;, \u0026#39;a\u0026#39;]) False 分析：\n可以先对列表用.sort()方法进行递增排列，如果递增排列后的列表和原列表的元素都对应相同，说明原列表本身就是递增排列的。\n一个错误的写法：\n1 2 3 4 5 6 7 8 9 def is_sorted(t): t_copy = t[:] print(t_copy) if t_copy == t.sort(): return True else: return False is_sorted([1, 2, 2]) 程序没有报错，但它仍是错的，因为，我们要比较的是两个列表里的元素对应相同，而不是看这两个变量是不是指向同一个列表。t_copy和t.sort()肯定不指向同一个列表，但它们的元素对应相同。因此我们不能用t_copy == t.sort()这样的方法来比较。可以这样做：\n1 2 3 4 5 6 7 8 9 10 11 def is_sorted(t): t_copy = t[:] for i in range(len(t)): if t_copy[i] == t[i]: #如果递增排列后的列表和原列表的元素都对应相同，说明原列表本身就是递增排列的 pass else: return False return True is_sorted([1, 2, 2]) 还可以用另一种方法实现：从第二个元素开始，依次和前面一个元素比较大小。\n字符串也可以进行大小比较。英文字母按字母顺序从小到大；所有的大写字母在小写字母前面，所以如果进行大小比较的话，'A'\u0026lt;'Z'\u0026lt;'a'\u0026lt;'z'。\n1 2 3 4 5 6 7 8 9 10 def is_sorted(t): for i in range(1,len(t)): #从1开始，而不是从0开始生成序列 if t[i] \u0026gt;= t[i-1]: #如果从第二个元素开始，每一个元素都比它前面一个元素大，说明这个列表就是递增的 pass else: return False return True is_sorted([1, 2, 2]) ","date":"Dec 31","permalink":"https://o5o.me/post/think_python_exercise_10.5/","tags":null,"title":"Think Python Exercise 10.5"},{"categories":["Python"],"contents":"编写一个叫做 chop 的函数，接受一个列表作为参数，移除第一个和最后一个元素，并返回None。例如：\n\u0026gt;\u0026gt;\u0026gt; t = [1, 2, 3, 4] \u0026gt;\u0026gt;\u0026gt; chop(t) \u0026gt;\u0026gt;\u0026gt; t [2, 3] 分析：\n一顿操作猛如虎：（错的）\n1 2 3 4 5 6 7 8 def chop(t): t = t[1:-1] t1 = [1, 2, 3, 4] chop(t1) t1 为什么t1没变化？是我列表切片用错了吗，再试试：（还是错的）\n1 2 3 4 5 6 7 8 def chop(t): t = t[1:len(t)-2] t1 = [1, 2, 3, 4] chop(t1) t1 可以看到，t1还是没变化，为什么？为什么这样是错的？\n不要被迷惑了，当一个列表t1传递给一个函数时，t1和形参t共同指向同一个列表，但当函数内部t重新赋值后，t指向了一个新的列表，而t1依然指向原来的列表，那么当函数运行结束后，t1的值当然还是原来的啦。\n由于题目要求函数不能有返回值，可以使用下面的做法：\n1 2 3 4 5 6 7 8 9 def chop(t): del t[0] del t[-1] t1 = [1, 2, 3, 4] chop(t1) t1 如果函数可以有返回值，可以这样写：\n1 2 3 4 5 6 7 8 def chop(t): return t[1:-1] t1 = [1, 2, 3, 4] t1 = chop(t1) t1 ","date":"Dec 31","permalink":"https://o5o.me/post/think_python_exercise_10.4/","tags":null,"title":"Think Python Exercise 10.4"},{"categories":["Python"],"contents":"编写一个函数，读取文件 words.txt ，建立一个列表,其中每个单词为一个元素。\n编写两个版本，一个使用 append 方法，另一个使用 t = t + [x] 。那个版本运行得慢？为什么？\n解答：\n在 jupyter 中的一个代码单元（cell）中，代码第一行写上%%time或%%timeit，即可计算代码的运行时间。\n版本1：\n1 2 3 4 5 6 7 8 9 10 11 12 %%time def read_word1(file_in): word_list = [] for line in file_in: word = line.strip() word_list.append(word) return word_list fin = open(\u0026#39;words.txt\u0026#39;) a = read_word1(fin) 运行结果：\nCPU times: user 85.3 ms, sys: 0 ns, total: 85.3 ms Wall time: 88.4 ms\n版本2：\n1 2 3 4 5 6 7 8 9 10 11 12 %%time def read_word2(file_in): word_list = [] for line in file_in: word = line.strip() word_list = word_list + [word] #相当于word_list这个列表和一个只有一个元素的列表合并 return word_list fin = open(\u0026#39;words.txt\u0026#39;) a = read_word2(fin) 运行结果：\nCPU times: user 1min 1s, sys: 13.5 ms, total: 1min 1s Wall time: 1min 1s\n结果很显然，即便不准确测量也能感知到，第二个版本的代码相比第一个慢了很多。\n第一版的代码，每次循环，仅仅是操作一个元素，把它追加到列表末端；而第二版的代码，每次循环都要进行一次两个列表的拼接。\n","date":"Dec 31","permalink":"https://o5o.me/post/think_python_exercise_10.9/","tags":null,"title":"Think Python Exercise 10.9"},{"categories":["Python"],"contents":"编写一个叫做 cumsum 的函数，接受一个由数值组成的列表，并返回累加和；即一个新列表，其中第i个元素是原列表中前i+1个元素的和（注意i是从0开始的）。 例如：\n\u0026gt;\u0026gt;\u0026gt; t = [1, 2, 3] \u0026gt;\u0026gt;\u0026gt; cumsum(t) [1, 3, 6] 解答：\n1 2 3 4 5 6 7 8 9 10 11 12 def cumsum(t): numsum = [] for i in range(len(t)): numsum.append(sum(t[:i+1])) #对t的前i+1个元素求和（注意i是从0开始，所以第i个元素是第i+1个元素），然后追加到新列表里 return numsum t = [1, 2, 3] print(cumsum(t)) t = [3,3,6,9,10] print(cumsum(t)) ","date":"Dec 31","permalink":"https://o5o.me/post/think_python_exercise_10.2/","tags":null,"title":"Think Python Exercise 10.2"},{"categories":["Python"],"contents":"编写一个叫做 nested_sum 的函数，接受一个由一些整数列表构成的列表作为参数，并将所有嵌套列表中的元素相加。例如：\n\u0026gt;\u0026gt;\u0026gt; t = [[1, 2], [3], [4, 5, 6]] \u0026gt;\u0026gt;\u0026gt; nested_sum(t) 21 解答：\n可以分别对每个子列表求和，再对得到的各个和求和。也可以先把各个子列表合并起来，然后对得到的列表求和。\n1 2 3 4 5 6 7 8 9 def nested_sum(t): c = [] for i in t: c = c + i #把t列表里的各个列表合并成一个列表 return sum(c) t = [[1, 2], [3], [4, 5, 6]] nested_sum(t) ","date":"Dec 31","permalink":"https://o5o.me/post/think_python_exercise_10.1/","tags":null,"title":"Think Python Exercise 10.1"},{"categories":["SRS"],"contents":"在用SuperMemo复习时，一边要移动鼠标，浏览卡片内容，一边要用键盘评分、修改卡片内容，容易手忙脚乱。把评分常用的按键和其他一些按键映射到游戏手柄上可以稍微方便一点。\n游戏手柄：八位堂Zero2小手柄。 软件：AntiMicroX\n手柄连接计算机 看说明书即可。\n在AntiMicroX中设定快捷键 打开软件后，点手柄上的按键，可以看到有的按键映射是错的，点软件窗口左下角的“游戏控制器映射”，先矫正一遍。\n然后在软件主窗口中找到你想设定快捷键的按键（可以通过按手柄上的对应按键确定它的位置），鼠标点击，设定快捷键即可。\n在我的SuperMemo中，目前是有很多的摘录卡片，以及很少的填空题卡片。我习惯于一边复习一边编辑卡片内容，比如把一段紧凑的话分成一行一行的句子，修改一些措辞。\n在SM中，当我的鼠标点击了卡片，可以看作我进入了“编辑模式”，如果这张卡片看完了，想进入下一张卡片，我需要先退出“编辑模式”（按ESC），再按回车键。可以把这两个键简化为一个键，在游戏手柄上按一次，无论你是不是在“编辑模式”，都可以跳转到下一张卡片。\n在AntiMicroX窗口中鼠标点击按键，在弹出的窗口中点击“高级选项”，又弹出一个窗口，在“分配”栏里点击“小方块”（里面出现\u0026quot;\u0026hellip;\u0026quot;），这时候在键盘上输入想设定的按键。设定两个按键，那么点击游戏手柄上的按键时，这两个按键会依次执行。\n我的按键设定 设定原则是，使用越多的按键放在越容易按的位置。\n使用手柄时我习惯竖着拿。除了十字方向键（我不用），最不方便按的是左肩键，其次是右肩键，然后是开始键和选择键。\n因此，我的设定是：\n左肩键，评分5。一是用的少，二来对一张卡片评分5时需要调整手的握姿，这样就会很慎重、很有仪式感。如果这种情况下还非要把一张卡片评分为5，说明真的掌握的很好了。\n右肩键，评分2。答错时按的。\nA，评分3/ENTER。最容易按的键。因为在评分时，按Enter键的效果和按3是一样的，所以设定为Enter，这样在复习时就不用频繁移动手指了。\nX，评分1。\nB，评分4。\nY，ESC+Enter，切换到下一张卡片。\n为什么A设定了Enter，这里还要再设定一个ESC+Enter呢？或者能不能都用ESC+Enter呢？你复习的时候亲手去操作一下就明白了。评分时按ESC+Enter没效果；阅读并编辑卡片时，按Enter不会跳转到下一张卡片，而是在卡片里添加一个空行。\n这是一件很主观的事情，怎么舒服怎么来。\n全文完。\n","date":"Dec 30","permalink":"https://o5o.me/post/supermemo-gamepad/","tags":["SuperMemo"],"title":"游戏手柄用于SuperMemo复习"},{"categories":["Python"],"contents":"编写一个名为is_abecedarian 的函数, 如果单词中的字符以字符表的顺序出现 (允许重复字符),则返回True。有多少个具备这种特征的单词?\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 def word_abcde(word): alphabets = \u0026#34;abcdefghijklmnopqrstuvwxyz\u0026#34; i = 0 front = 0 #前一个字母的序数 mine = 0 #当前字母的序数 while i \u0026lt; len(word): index = 0 while index \u0026lt; len(alphabets): # print(i,word[i],index,alphabets[index]) if word[i] == alphabets[index]: mine = index if mine \u0026lt; front: return False else: front = mine break index += 1 i += 1 return True def is_abecedarian(file_in): count = 0 for line in file_in: word = line.strip() if word_abcde(word): count += 1 #print(word) print(count) fin = open(\u0026#39;words.txt\u0026#39;) is_abecedarian(fin) 我所使用的这个单词表里，这样的单词有596个。\n","date":"Dec 29","permalink":"https://o5o.me/post/think_python_exercise_9.6/","tags":null,"title":"Think Python Exercise 9.6"},{"categories":["Python"],"contents":"编写一个名为uses_all的函数,接受一个单词和一个必须使用的字符组成的字符串。如果该单词包括此字符串中的全部字符至少一次,则返回True。你能统计出多少单词包含了所有的元音字符aeiou吗?如果换成aeiouy 呢?\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 def uses_all(word, muststr): for i in muststr: count = 0 index = 0 while index \u0026lt; len(word): if i == word[index]: break index += 1 if index == len(word): return False return True def count_word(file_in, als): count = 0 for line in file_in: word = line.strip() if uses_all(word, als): count += 1 print(count,\u0026#34;个单词包含了\u0026#34;,als,\u0026#34;所有的字符\u0026#34;) fin = open(\u0026#39;words.txt\u0026#39;) count_word(fin, \u0026#34;aeiouy\u0026#34;) 运行结果：\n598 个单词包含了 aeiou 所有的字符\n42 个单词包含了 aeiouy 所有的字符\n可以发现，uses_all函数和9.4的uses_only函数的实现一模一样，其实没必要再写一遍。\n","date":"Dec 29","permalink":"https://o5o.me/post/think_python_exercise_9.5/","tags":null,"title":"Think Python Exercise 9.5"},{"categories":["Python"],"contents":"编写一个名为 avoids 的函数，接受一个单词和一个指定禁止使用字符的字符串，如果单词中不包含任意被禁止的字符，则返回True 。\n修改你的程序，提示用户输入一个禁止使用的字符，然后打印不包含这些字符的单词的数量。你能找到一个5个禁止使用字符的组合，使得其排除的单词数目最少么？\n你能找到一个\u0026quot;5个禁止使用字符\u0026quot;的组合，使得其排除的单词数目最少么？ 分析：从26个字母中挑选5个字母构成一个组合，打印不包含这些字母的单词的数量，看哪个组合下被排除出去的单词数目最少。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 def avoids(word,ause): #ause，avoid use for i in ause: for letter in word: if letter == i: return False return True def has_no_string(file_in, nals): #nals指的是no alphabets，字母 count_nals = 0 #不含用户指定的各个字符的单词的个数 for line in file_in: word = line.strip() if avoids(word,nals): count_nals += 1 print(\u0026#34;不含\u0026#34;,nals,\u0026#34;的单词有\u0026#34;,count_nals,\u0026#34;个\u0026#34;) text = input(\u0026#34;请输入一个禁止使用的字符串，字符串里的字母都不会出现在单词中\\n\u0026#34;) fin = open(\u0026#39;words.txt\u0026#39;) has_no_string(fin,text) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 def avoids(word,ause): #ause，avoid use for i in ause: for letter in word: if letter == i: return False return True def has_no_string(file_in, nals): #nals指的是no alphabets，字母 count_nals = 0 #不含用户指定的各个字符的单词的个数 for line in file_in: word = line.strip() if avoids(word,nals): count_nals += 1 # print(\u0026#34;不含\u0026#34;,nals,\u0026#34;的单词有\u0026#34;,count_nals,\u0026#34;个\u0026#34;) return count_nals def alp5group(file_in): #5个字母的组合，起名困难 alphabets = \u0026#34;abcdefghijklmnopqrstuvwxyz\u0026#34; count_word = 0 # 不含指定的5个字母的单词的数量 namegroup = \u0026#39;\u0026#39; # 不含5个字符的组合，单词最多 i = 0 while i \u0026lt; len(alphabets): group = \u0026#39;\u0026#39; group += alphabets[i] j = 1 while j \u0026lt; len(alphabets[i:]): group += alphabets[i+j] k = 1 while k \u0026lt; len(alphabets[i+j:]): group += alphabets[i+j+k] l = 1 while l \u0026lt; len(alphabets[i+j+k:]): group += alphabets[i+j+k+l] m = 1 while m \u0026lt; len(alphabets[i+j+k+l:]): group += alphabets[i+j+k+l+m] count = has_no_string(file_in,group) if count \u0026gt; count_word: count_word = count namegroup = group m += 1 l += 1 k += 1 j += 1 i += 1 print(\u0026#34;组合\u0026#34;,namegroup,\u0026#34;被排除出去的单词数目最少，单词数量为\u0026#34;,count_word) fin = open(\u0026#39;words.txt\u0026#39;) alp5group(fin) 下面是使用 in 操作符优化后的方案，可以用 in 真的太幸福了😭。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 def avoids(word,ause): #ause，avoid use for i in ause: if i in word: return False return True fin = open(\u0026#39;words.txt\u0026#39;) text = input(\u0026#34;请输入一个禁止使用的字符串，字符串里的字母都不会出现在单词中\\n\u0026#34;) count = 0 #单词总数 count_n = 0 #不含用户输入字符的单词的个数 for line in fin: word = line.strip() count += 1 if avoids(word,text): count_n += 1 print(\u0026#34;不含\u0026#34;,text,\u0026#34;的单词有\u0026#34;,count_n,\u0026#34;个，单词一共：\u0026#34;,count) ","date":"Dec 29","permalink":"https://o5o.me/post/think_python_exercise_9.4/","tags":null,"title":"Think Python Exercise 9.4"},{"categories":["Python"],"contents":"编写一个名为 avoids 的函数，接受一个单词和一个指定禁止使用字符的字符串，如果单词中不包含任意被禁止的字符，则返回True 。\n修改你的程序，提示用户输入一个禁止使用的字符，然后打印不包含这些字符的单词的数量。你能找到一个5个禁止使用字符的组合，使得其排除的单词数目最少么？\n你能找到一个\u0026quot;5个禁止使用字符\u0026quot;的组合，使得其排除的单词数目最少么？ 分析：从26个字母中挑选5个字母构成一个组合，打印不包含这些字母的单词的数量，看哪个组合下被排除出去的单词数目最少。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 def avoids(word,ause): #ause，avoid use for i in ause: for letter in word: if letter == i: return False return True def has_no_string(file_in, nals): #nals指的是no alphabets，字母 count_nals = 0 #不含用户指定的各个字符的单词的个数 for line in file_in: word = line.strip() if avoids(word,nals): count_nals += 1 print(\u0026#34;不含\u0026#34;,nals,\u0026#34;的单词有\u0026#34;,count_nals,\u0026#34;个\u0026#34;) text = input(\u0026#34;请输入一个禁止使用的字符串，字符串里的字母都不会出现在单词中\\n\u0026#34;) fin = open(\u0026#39;words.txt\u0026#39;) has_no_string(fin,text) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 def avoids(word,ause): #ause，avoid use for i in ause: for letter in word: if letter == i: return False return True def has_no_string(file_in, nals): #nals指的是no alphabets，字母 count_nals = 0 #不含用户指定的各个字符的单词的个数 for line in file_in: word = line.strip() if avoids(word,nals): count_nals += 1 # print(\u0026#34;不含\u0026#34;,nals,\u0026#34;的单词有\u0026#34;,count_nals,\u0026#34;个\u0026#34;) return count_nals def alp5group(file_in): #5个字母的组合，起名困难 alphabets = \u0026#34;abcdefghijklmnopqrstuvwxyz\u0026#34; count_word = 0 # 不含指定的5个字母的单词的数量 namegroup = \u0026#39;\u0026#39; # 不含5个字符的组合，单词最多 i = 0 while i \u0026lt; len(alphabets): group = \u0026#39;\u0026#39; group += alphabets[i] j = 1 while j \u0026lt; len(alphabets[i:]): group += alphabets[i+j] k = 1 while k \u0026lt; len(alphabets[i+j:]): group += alphabets[i+j+k] l = 1 while l \u0026lt; len(alphabets[i+j+k:]): group += alphabets[i+j+k+l] m = 1 while m \u0026lt; len(alphabets[i+j+k+l:]): group += alphabets[i+j+k+l+m] count = has_no_string(file_in,group) if count \u0026gt; count_word: count_word = count namegroup = group m += 1 l += 1 k += 1 j += 1 i += 1 print(\u0026#34;组合\u0026#34;,namegroup,\u0026#34;被排除出去的单词数目最少，单词数量为\u0026#34;,count_word) fin = open(\u0026#39;words.txt\u0026#39;) alp5group(fin) 下面是使用 in 操作符优化后的方案，可以用 in 真的太幸福了😭。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 def avoids(word,ause): #ause，avoid use for i in ause: if i in word: return False return True fin = open(\u0026#39;words.txt\u0026#39;) text = input(\u0026#34;请输入一个禁止使用的字符串，字符串里的字母都不会出现在单词中\\n\u0026#34;) count = 0 #单词总数 count_n = 0 #不含用户输入字符的单词的个数 for line in fin: word = line.strip() count += 1 if avoids(word,text): count_n += 1 print(\u0026#34;不含\u0026#34;,text,\u0026#34;的单词有\u0026#34;,count_n,\u0026#34;个，单词一共：\u0026#34;,count) ","date":"Dec 29","permalink":"https://o5o.me/post/think_python_exercise_9.3/","tags":null,"title":"Think Python Exercise 9.3"},{"categories":["Python"],"contents":"1939年，Ernest Vincent Wright出版了一本名为 《Gadsby》 的小说，该小说里完全没有使用字符“e”。由于“e”是最常用的英文字符，因此这并不容易做到。\n事实上，不使用这个最常用的符号(字符e)来构建一个孤立的想法是很难的。开始进展缓慢，但是经过有意识的、长时间的训练，你可以逐渐地熟练。\n好啦，不再说题外话了（让我们开始编程练习）。\n写一个叫做has_no_e的函数，如果给定的单词中不包含字符“e”，其返回 True 。\n修改上一节中的程序，只打印不包含“e”的单词，并且计算列表中不含“e”单词的比例。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 fin = open(\u0026#39;words.txt\u0026#39;) def has_no_e(file_in): count_ne = 0 #不含e的单词的个数 count = 0 #总单词个数 for line in file_in: word = line.strip() index = 0 while index \u0026lt; len(word): if word[index] == \u0026#39;e\u0026#39;: break else: index = index + 1 if index == len(word): # print(word) #因为单词比较多，不一个个列出来了 count_ne = count_ne + 1 count = count + 1 print(\u0026#34;不含e的单词有\u0026#34;,count_ne,\u0026#34;个\u0026#34;,\u0026#34;单词一共有\u0026#34;,count,\u0026#34;个\u0026#34;,\u0026#34;不含“e”单词的比例为\u0026#34;,count_ne/count*100,\u0026#34;%\u0026#34;) has_no_e(fin) 上面是一个字母一个字母判断单词是不是包含‘e’的，下面是在 if 中使用 in 操作符简化后的方案：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 def has_no_e(word): if \u0026#39;e\u0026#39; not in word: return True else: return False fin = open(\u0026#39;words.txt\u0026#39;) count = 0 #单词总数 count_ne = 0 #不含e的单词数 for line in fin: word = line.strip() count += 1 if has_no_e(word): count_ne += 1 #print(word) print(\u0026#34;不含e的单词有\u0026#34;,count_ne,\u0026#34;个\u0026#34;,\u0026#34;单词一共有\u0026#34;,count,\u0026#34;个\u0026#34;,\u0026#34;不含“e”单词的比例为\u0026#34;,count_ne/count*100,\u0026#34;%\u0026#34;) 所得结果都是一样的：\n不含e的单词有 37641 个 单词一共有 113809 个 不含“e”单词的比例为 33.07383423103621 %\n","date":"Dec 29","permalink":"https://o5o.me/post/think_python_exercise_9.2/","tags":null,"title":"Think Python Exercise 9.2"},{"categories":["Python"],"contents":"编程写一个程序，使得它可以读取 words.txt　，然后只打印出那些长度超过20个字符的单词(不包括空格)。\n1 2 3 4 5 6 fin = open(\u0026#39;words.txt\u0026#39;) for line in fin: word = line.strip() if len(word) \u0026gt; 20: print(word) ","date":"Dec 28","permalink":"https://o5o.me/post/think_python_exercise_9.1/","tags":null,"title":"Think Python Exercise 9.1"},{"categories":null,"contents":"","date":"Jan 01","permalink":"https://o5o.me/articles/","tags":null,"title":"Articles"}]