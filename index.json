[{"categories":["Python"],"contents":"编写一个名为 draw_rect 的函数,该函数接受一个 Turtle 对象和一个 Rectangle 对象,使用Turtle 画出该矩形。参考第 四 章中使用 Turtle 的示例。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 import turtle class Point: \u0026#34;\u0026#34;\u0026#34;表示一个二维的点 \u0026#34;\u0026#34;\u0026#34; class Rectangle: \u0026#34;\u0026#34;\u0026#34;Represents a rectangle. attributes: width, height, corner.\u0026#34;\u0026#34;\u0026#34; def draw_rect(t,rect): t.pu() #在移动到矩形左下角的过程中，不画出痕迹（提笔，put up） t.goto(rect.corner.x, rect.corner.y) t.pd() #落笔（put down） for i in range(2): t.fd(box.width) t.lt(90) t.fd(box.height) t.lt(90) bob = turtle.Turtle() box = Rectangle() box.width = 100.0 box.height = 200.0 box.corner = Point() box.corner.x = 100 box.corner.y = 90 draw_rect(bob,box) turtle.mainloop() 编写一个名为 draw_circle 的函数, 该函数接受一个 Turtle 对象和 Circle 对象, 并画出该圆。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 import turtle, math class Point: \u0026#34;\u0026#34;\u0026#34;表示一个二维的点 \u0026#34;\u0026#34;\u0026#34; class Circle: \u0026#34;\u0026#34;\u0026#34;属性：圆心center、半径radius 圆心是一个Point类 半径是一个数字 \u0026#34;\u0026#34;\u0026#34; #下面几个函数，用了4.1题画圆的代码 def polyline(t, n, length, angle): \u0026#34;\u0026#34;\u0026#34;Draws n line segments. t: Turtle object n: number of line segments length: length of each segment angle: degrees between segments \u0026#34;\u0026#34;\u0026#34; for i in range(n): t.fd(length) t.lt(angle) def polygon(t, n, length): \u0026#34;\u0026#34;\u0026#34;Draws a polygon with n sides. t: Turtle n: number of sides length: length of each side. \u0026#34;\u0026#34;\u0026#34; angle = 360.0/n polyline(t, n, length, angle) def arc(t, r, angle): \u0026#34;\u0026#34;\u0026#34;Draws an arc with the given radius and angle. t: Turtle r: radius angle: angle subtended by the arc, in degrees \u0026#34;\u0026#34;\u0026#34; arc_length = 2 * math.pi * r * abs(angle) / 360 #角度变为绝对值 n = int(arc_length / 4) + 3 #之前是int(arc_length / 3) + 1 step_length = arc_length / n step_angle = float(angle) / n # making a slight left turn before starting reduces # the error caused by the linear approximation of the arc # 在开始前稍微左转可以减少由直线逼近弧线所引起的误差 t.lt(step_angle/2) polyline(t, n, step_length, step_angle) t.rt(step_angle/2) def circle(t, r): \u0026#34;\u0026#34;\u0026#34;Draws a circle with the given radius. t: Turtle r: radius \u0026#34;\u0026#34;\u0026#34; arc(t, r, 360) def draw_circle(t,circ): t.pu() #在移动到圆心的过程中，不画出痕迹（提笔，put up） t.goto(circ.center.x, circ.center.y) t.pd() #落笔（put down） circle(t, circ.radius) bob = turtle.Turtle() tom = Circle() tom.center = Point() tom.center.x = 150 tom.center.y = 100 tom.radius = 75 draw_circle(bob,tom) turtle.mainloop() ","date":"Jan 09","permalink":"https://o5o.me/post/think_python_exercise_15.2/","tags":null,"title":"Think Python Exercise 15.2"},{"categories":["Python"],"contents":" 15.1.1 定义一个叫做Circle类, 类的属性是圆心 (center) 和半径 (radius), 其中, 圆心 (center) 是一个 Point 类,而半径 (radius) 是一个数字。\n实例化一个圆心 (center) 为 (150, 100) ,半径 (radius) 为 75 的Circle 对象。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Circle: \u0026#34;\u0026#34;\u0026#34;属性：圆心center、半径radius 圆心是一个Point类 半径是一个数字 \u0026#34;\u0026#34;\u0026#34; class Point: \u0026#34;\u0026#34;\u0026#34;表示一个二维的点 \u0026#34;\u0026#34;\u0026#34; bob = Circle() bob.center = Point() bob.center.x = 150 bob.center.y = 100 bob.radius = 75 15.1.2 编写一个名称为point_in_circle的函数,该函数可以接受一个圆类 (Circle) 对象和点类 (Point) 对象, 然后判断该点是否在圆内。在圆内则返回True 。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 import math class Circle: \u0026#34;\u0026#34;\u0026#34;属性：圆心center、半径radius 圆心是一个Point类 半径是一个数字 \u0026#34;\u0026#34;\u0026#34; class Point: \u0026#34;\u0026#34;\u0026#34;表示一个二维的点 \u0026#34;\u0026#34;\u0026#34; def point_in_circle(cir,poi): distance = math.sqrt((poi.x-cir.center.x)**2+(poi.y-cir.center.y)**2)#求点到圆心的距离来判断点是否在圆内 if distance \u0026lt;= cir.radius: return True else: return False bob = Circle() bob.center = Point() bob.center.x = 150 bob.center.y = 100 bob.radius = 75 tom = Point() tom.x = 100 tom.y = 101 point_in_circle(bob,tom) 15.1.3 编写一个名称为rect_in_circle的函数,该函数接受一个圆类 (Circle) 对象和矩形(Rectangle) 对象,如果该矩形上的点完全在圆内或者在圆上则返回True。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 import math class Point: \u0026#34;\u0026#34;\u0026#34;表示一个二维的点 \u0026#34;\u0026#34;\u0026#34; class Circle: \u0026#34;\u0026#34;\u0026#34;属性：圆心center、半径radius 圆心是一个Point类 半径是一个数字 \u0026#34;\u0026#34;\u0026#34; class Rectangle: \u0026#34;\u0026#34;\u0026#34;Represents a rectangle. attributes: width, height, corner.\u0026#34;\u0026#34;\u0026#34; def point_in_circle(cir,poi): distance = math.sqrt((poi.x-cir.center.x)**2+(poi.y-cir.center.y)**2)#求点到圆心的距离来判断点是否在圆内 if distance \u0026lt;= cir.radius: return True else: return False def rect_in_circle(cir,rect): #根据矩形左下角的坐标及长宽，得到其他三个点的坐标 topleft = Point() topleft.x = rect.corner.x topleft.y = rect.corner.y + rect.height topright = Point() topright.x = rect.corner.x + rect.width topright.y = rect.corner.y + rect.height bottomright = Point() bottomright.x = rect.corner.x + rect.width bottomright.y = rect.corner.y # 如果矩形的四个点都在圆内或圆上，就可以认为矩形在圆内或圆上 if point_in_circle(cir,topleft) and point_in_circle(cir,topright) and point_in_circle(cir, bottomright) and point_in_circle(cir, rect.corner): return True else: return False bob = Circle() bob.center = Point() bob.center.x = 150 bob.center.y = 100 bob.radius = 75 box = Rectangle() box.width = 100.0 box.height = 200.0 box.corner = Point() box.corner.x = 0.0 box.corner.y = 0.0 rect_in_circle(bob,box) 写到这里插句题外话，我在写代码的时候遇到两次这个类似报错：“AttributeError: \u0026lsquo;Rectangle\u0026rsquo; object has no attribute \u0026lsquo;x\u0026rsquo;”，但我咋看，我定义的函数咋没问题。最后发现，确实不是函数的问题，而是我调用错了函数。因为练习题与练习题之间是有关联的，我是直接在上一题的代码基础上来做这道题，在调用函数的时候，我错误地用了上一题的函数，调用了这一题这个函数对应的参数，所以就报错了。\n15.1.4 编写一个名为 rect_circle_overlap 函数,该函数接受一个圆类对象和一个矩形类对象,如果矩形有任意一个角落在圆内则返回True 。或者写一个更具有挑战性的版本, 如果该矩形有任何部分落在圆内返回True 。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 import math class Point: \u0026#34;\u0026#34;\u0026#34;表示一个二维的点 \u0026#34;\u0026#34;\u0026#34; class Circle: \u0026#34;\u0026#34;\u0026#34;属性：圆心center、半径radius 圆心是一个Point类 半径是一个数字 \u0026#34;\u0026#34;\u0026#34; class Rectangle: \u0026#34;\u0026#34;\u0026#34;Represents a rectangle. attributes: width, height, corner.\u0026#34;\u0026#34;\u0026#34; def point_in_circle(cir,poi): distance = math.sqrt((poi.x-cir.center.x)**2+(poi.y-cir.center.y)**2)#求点到圆心的距离来判断点是否在圆内 if distance \u0026lt;= cir.radius: return True else: return False def rect_circle_overlap(cir, rect): #根据矩形左下角的坐标及长宽，得到其他三个点的坐标 topleft = Point() topleft.x = rect.corner.x topleft.y = rect.corner.y + rect.height topright = Point() topright.x = rect.corner.x + rect.width topright.y = rect.corner.y + rect.height bottomright = Point() bottomright.x = rect.corner.x + rect.width bottomright.y = rect.corner.y # 矩形是否有角落在圆内 if point_in_circle(cir,topleft) or point_in_circle(cir,topright) or point_in_circle(cir, bottomright) or point_in_circle(cir, rect.corner): return True else: return False bob = Circle() bob.center = Point() bob.center.x = 150 bob.center.y = 100 bob.radius = 75 box = Rectangle() box.width = 100.0 box.height = 200.0 box.corner = Point() box.corner.x = 100 box.corner.y = 90 rect_circle_overlap(bob,box) 这里也就是把上一段代码里的 and 换成了 or、改了个函数名。函数其他部分一点都没变。\n","date":"Jan 04","permalink":"https://o5o.me/post/think_python_exercise_15.1/","tags":null,"title":"Think Python Exercise 15.1"},{"categories":["Python"],"contents":"编写一个叫做distance_between_points的函数，它接受两个Point作为参数，然后返回这两个点之间的距离。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 import math class Point: \u0026#34;\u0026#34;\u0026#34;表示一个二维的点 \u0026#34;\u0026#34;\u0026#34; def distance_between_points(p1,p2): return math.sqrt((p1.x - p2.x)**2+(p1.y - p2.y)**2) Po1 = Point() Po2 = Point() Po1.x = 5 Po1.y = 3 Po2.x = 6 Po2.y = 2 distance_between_points(Po1,Po2) 编写一个叫做move_rectangle的函数，接受一个Rectangle以及两个数字dx和dy。它把corner的x坐标加上dx，把corner的y坐标加上dy，从而改变矩形的位置。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 def print_point(p): print(\u0026#39;(%g, %g)\u0026#39; % (p.x, p.y)) class Point: \u0026#34;\u0026#34;\u0026#34;表示一个二维的点 \u0026#34;\u0026#34;\u0026#34; class Rectangle: \u0026#34;\u0026#34;\u0026#34;Represents a rectangle. attributes: width, height, corner.\u0026#34;\u0026#34;\u0026#34; def move_rectangle(rect,dx,dy): rect.corner.x += dx rect.corner.y += dy box = Rectangle() box.width = 100.0 box.height = 200.0 box.corner = Point() box.corner.x = 0.0 box.corner.y = 0.0 move_rectangle(box,20,30) print_point(box.corner) ","date":"Jan 04","permalink":"https://o5o.me/post/think_python_exercise_15.0/","tags":null,"title":"Think Python Exercise 15.0"},{"categories":["Python"],"contents":"将 习题6.2 中的 Ackermann 函数备忘录化(memoize), 看看备忘录化(memoization)是否可以支持解决更大的参数。没有提示!\n储存之前计算过的值以便今后使用，这个操作就称为备忘录化。\n做这道题首先要理解书上关于斐波那契数列的例子。\n计算斐波那契数列的代码：\n1 2 3 4 5 6 7 def fibonacci(n): if n == 0: return 0 elif n == 1: return 1 else: return fibonacci(n-1) + fibonacci(n-2) 备忘录化后的代码：\n1 2 3 4 5 6 7 8 9 known = {0:0, 1:1} def fibonacci(n): if n in known: return known[n] res = fibonacci(n-1) + fibonacci(n-2) known[n] = res return res 按照同样的思路，我们可以把计算的ack函数的值储存到字典里，后面再计算时先看之前是不是曾计算过，如果计算过，直接调用已有结果即可。\n原ack函数代码：\n1 2 3 4 5 6 7 8 def ackermann(m,n): #来自6.2 if m == 0: return n+1 if n == 0: return ackermann(m-1,1) return ackermann(m-1, ackermann(m,n-1)) print(ackermann(3,4)) 备忘录化后的ack代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 known = {} def ackermann(m,n): if (m,n) in known: return known[m,n] if m == 0: res = n+1 known[m,n] = res return res if n == 0: res = ackermann(m-1,1) known[m,n] = res return res res = ackermann(m-1, ackermann(m,n-1)) known[m,n] = res return res print(ackermann(3,4)) 可以注意到我用了元组作为字典的键，元组是下一章学的，这里用是因为我觉得没有比元组更合适的了。\n在 jupyter lab 里可以通过在代码第一行写%%time查看代码运行时间，经比较，可以发现备忘录化后的计算速度快了很多很多：\n1 2 3 4 5 6 7 8 9 %%time def ackermann(m,n): if m == 0: return n+1 if n == 0: return ackermann(m-1,1) return ackermann(m-1, ackermann(m,n-1)) print(ackermann(3,6)) 509 CPU times: user 55 ms, sys: 4.78 ms, total: 59.8 ms Wall time: 66.4 ms 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 %%time known = {} def ackermann(m,n): if (m,n) in known: return known[m,n] if m == 0: res = n+1 known[m,n] = res return res if n == 0: res = ackermann(m-1,1) known[m,n] = res return res res = ackermann(m-1, ackermann(m,n-1)) known[m,n] = res return res print(ackermann(3,6)) 509 CPU times: user 3.09 ms, sys: 1.51 ms, total: 4.59 ms Wall time: 5.48 ms 再大的数我就不试了。你感兴趣可以试试ackermann(4,3)/手动狗头。\n","date":"Jan 03","permalink":"https://o5o.me/post/think_python_exercise_11.3_ackermann/","tags":null,"title":"Think Python Exercise 11.3 阿克曼函数"},{"categories":["Python"],"contents":"Ackermann 函数 $A(m, n)$ 的定义如下:\n$$ A(m, n)=\\left{\\begin{array}{ll} n+1 \u0026amp; \\text { if } m=0 \\ A(m-1,1) \u0026amp; \\text { if } m\u0026gt;0 \\text { and } n=0 \\ A(m-1, A(m, n-1)) \u0026amp; \\text { if } m\u0026gt;0 \\text { and } n\u0026gt;0 \\end{array}\\right. $$\n查看维基百科的定义, 编写一个叫作ack的函数来计算 Ackermann 函数。使用你的函 数计算ack(3,4), 其结果应该为 125 。如果 $m$ 和 $n$ 的值较大时, 会发生什么?\n拙见：\n1 2 3 4 5 6 7 8 9 def ack(m,n): if m == 0: return n+1 elif m \u0026gt; 0 and n == 0: return ack(m-1,1) elif m \u0026gt; 0 and n \u0026gt; 0: return ack(m-1,ack(m,n-1)) ack(3,4) 似乎看上去平平无奇，把它的计算过程展示出来：\n1 2 3 4 5 6 7 8 9 10 11 12 def ack(m,n): if m == 0: print(n+1) return n+1 elif m \u0026gt; 0 and n == 0: print(\u0026#39;ack(\u0026#39;,m-1,\u0026#39;,\u0026#39;,1,\u0026#39;)\u0026#39;) return ack(m-1,1) elif m \u0026gt; 0 and n \u0026gt; 0: print(\u0026#39;ack(\u0026#39;,m-1,\u0026#39;,ack(\u0026#39;,m,\u0026#39;,\u0026#39;,n-1,\u0026#39;))\u0026#39;) return ack(m-1,ack(m,n-1)) ack(3,4) 你可以自己动手运行一下看看，实际上进行了上万次递归。\n作者的写法更简洁一些：\n1 2 3 4 5 6 7 8 def ackermann(m,n): if m == 0: return n+1 if n == 0: return ackermann(m-1,1) return ackermann(m-1, ackermann(m,n-1)) print(ackermann(3,4)) （补充说明一下，我的代码是在jupyter lab里运行的，所以不用使用print函数也能把结果显示出来。）\n","date":"Jan 03","permalink":"https://o5o.me/post/think_python_exercise_6.2_ackermann/","tags":null,"title":"Think Python Exercise 6.2 阿克曼函数"},{"categories":["Python"],"contents":"画出下面程序的堆栈图。这个程序的最终输出是什么?\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 def b(z): prod = a(z, z) print(z, prod) return prod def a(x, y): x = x + 1 return x * y def c(x, y, z): total = x + y + z square = b(total)**2 return square x = 1 y = x + 1 print(c(x, y+3, x+y)) 程序的最终输出：8100\n应该没有特别的意义吧？\n","date":"Jan 03","permalink":"https://o5o.me/post/think_python_exercise_6.1/","tags":null,"title":"Think Python Exercise 6.1"},{"categories":["Python"],"contents":"查看字典方法setdefault的文档, 并使用该方法写一个更简洁的invert_dict。\n原来的函数的定义：\n1 2 3 4 5 6 7 8 9 10 11 def invert_dict(d): \u0026#34;\u0026#34;\u0026#34;倒转一个字典，将原字典的值作为键，原字典的键作为值。 \u0026#34;\u0026#34;\u0026#34; inverse = dict() for key in d: val = d[key] if val not in inverse: inverse[val] = [key] #反转后，一个键可能对应多个值，所以把值放到列表里 else: inverse[val].append(key) #相当于给列表追加一个值。键val的值是一个列表。 return inverse 文档链接：这里\nsetdefault(key[, default]), 如果字典存在键 key ，返回它的值。如果不存在，插入值为 default 的键 key ，并返回 default 。 default 默认为 None。\n1 2 3 4 5 6 7 8 9 10 def invert_dict(d): \u0026#34;\u0026#34;\u0026#34;倒转一个字典，将原字典的值作为键，原字典的键作为值。 \u0026#34;\u0026#34;\u0026#34; inverse = dict() for key in d: inverse[d[key]]=inverse.setdefault(d[key],[])+[key] return inverse A = {\u0026#39;a\u0026#39;:2,\u0026#39;b\u0026#39;:3,\u0026#39;c\u0026#39;:2} invert_dict(A) 做这种题有助于提高自信。不建议看答案，看完你会有：“为啥我就没想到”这种想法，进一步怀疑自己的智商。\n","date":"Jan 03","permalink":"https://o5o.me/post/think_python_exercise_11.2/","tags":null,"title":"Think Python Exercise 11.2 字典方法setdefault"},{"categories":["Python"],"contents":"编写一函数,读取words.txt中的单词并存储为字典中的键。值是什么无所谓。然后,你可以使用in操作符检查一个字符串是否在字典中。\n如果你做过练习 10.10 ,可以比较一下in操作符和二分查找的速度。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 def make_word_list(): word_list = [] fin = open(\u0026#39;words.txt\u0026#39;) for line in fin: word = line.strip() word_list.append(word) return word_list def dictword(w_li): word_dict = dict() for word in w_li: word_dict[word] = \u0026#39;ok\u0026#39; #题目说值是什么无所谓 return word_dict word_list = make_word_list() word_dict = dictword(word_list) \u0026#39;aha\u0026#39; in word_dict 我就不比较in操作符和二分查找的速度了。\n","date":"Jan 03","permalink":"https://o5o.me/post/think_python_exercise_11.1/","tags":null,"title":"Think Python Exercise 11.1"},{"categories":["Python"],"contents":"两个单词中如果一个是另一个的反转, 则二者被称为是 ‘‘反转词对’’。 编写一个函数,找出单词表中所有的反转词对。\n解答：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 def read_word1(file_in): #来自10.9 word_list = [] for line in file_in: word = line.strip() word_list.append(word) return word_list def in_bisect(t,a): #来自10.10 \u0026#34;\u0026#34;\u0026#34;列表t，单词a，看单词是否在列表内，在的话返回单词的位置。 列表里的单词，必须是已经按字母顺序排好序的。 \u0026#34;\u0026#34;\u0026#34; s1 = int((len(t))/2) s = s1 #如果a在t内，s保存a的序数 while s1 \u0026gt; 0: if a == t[s1]: return s elif a \u0026gt; t[s1]: t = t[s1:] s1 = int(len(t)/2) #在循环过程中，确保s和s1所指的是同一个元素。 #print(a,\u0026#34;的位置大于\u0026#34;,s) s += s1 else: t = t[:s1] s1 = int(len(t)/2) #print(a,\u0026#34;的位置小于等于\u0026#34;,s) s -= s1 return None def findpairs(word_li): i = 0 for word in word_li: drow = word[::-1] #将单词里的字母按照相反的顺序排列 k = in_bisect(word_li[i:],drow) #写word_list[i:]目的是不让程序往前去找所谓的“反转词” if k: print(word,\u0026#39;和\u0026#39;,word_li[k+i]) i += 1 fin = open(\u0026#39;words.txt\u0026#39;) word_list = read_word1(fin) findpairs(word_list) 我在10.10题写的in_bisect函数有误差，导致上面的代码虽然能找到‘‘反转词对’，但在输出的时候有偏差。今天很晚了(0:44)，后面有机会再改吧。\n下面我用了Python的bisect模块：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 import bisect def read_word1(file_in): #来自10.9 word_list = [] for line in file_in: word = line.strip() word_list.append(word) return word_list def findpairs(word_li): for i in range(len(word_li)): drow = word_li[i][::-1] #将单词里的字母按照相反的顺序排列 k = bisect.bisect(word_li[i:],drow) #写word_list[i:]目的是不让程序往前去找所谓的“反转词” if drow == word_li[i+k-1]: print(i,word_li[i],\u0026#39;和\u0026#39;,i+k-1,word_li[i+k-1]) fin = open(\u0026#39;words.txt\u0026#39;) word_list = read_word1(fin) findpairs(word_list) 输出看起来很美好，但是我稍微变一下，它就不正常了：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 import bisect def read_word1(file_in): #来自10.9 word_list = [] for line in file_in: word = line.strip() word_list.append(word) return word_list def findpairs(word_li): for i in range(len(word_li)): drow = word_li[i][::-1] #将单词里的字母按照相反的顺序排列 k = bisect.bisect(word_li[i:],drow) #写word_list[i:]目的是不让程序往前去找所谓的“反转词” if k: print(i,word_li[i],\u0026#39;和\u0026#39;,i+k-1,word_li[i+k-1]) fin = open(\u0026#39;words.txt\u0026#39;) word_list = read_word1(fin) findpairs(word_list) 我把if里的drow == word_li[i+k-1]改成k，输出就不正常了，打印出来的一对单词 就不是‘‘反转词对’’了。而且因为单词表里的单词很多（十几万个），电脑还会卡死。\n看看作者答案是怎么写的吧：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 from __future__ import print_function, division from inlist import in_bisect, make_word_list def reverse_pair(word_list, word): rev_word = word[::-1] return in_bisect(word_list, rev_word) if __name__ == \u0026#39;__main__\u0026#39;: word_list = make_word_list() for word in word_list: if reverse_pair(word_list,word): print(word, word[::-1]) 有点失望，作者的代码完全没有涉及到下标的加加减减。\n","date":"Jan 02","permalink":"https://o5o.me/post/think_python_exercise_10.11/","tags":null,"title":"Think Python Exercise 10.11"},{"categories":["Python"],"contents":"使用in运算符可以检查一个单词是否在单词表中, 但这很慢, 因为它是按顺序查找单词。\n由于单词是按照字母顺序排序的,我们可以使用两分法 (也称二叉树搜索) 来加快速度, 类似于在字典中查找单词的方法。你从中间开始,如果你要找的单词在中间的单词之前,你查找前半部分,否则你查找后半部分。\n不管怎样, 你都会将搜索范围减小一半。 如果单词表有 113,809 个单词, 你只需要 17 步就可以找到这个单词,或着得出单词不存在的结论。\n编写一个叫做in_bisect的函数,接受一个已排序的列表和一个目标值作为参数,返回该值在列表中的位置,如果不存在则返回None。\n或者你可以阅读bisect模块的文档并使用它!\n解答：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 def in_bisect(t,a): \u0026#34;\u0026#34;\u0026#34;列表t，单词a，看单词是否在列表内，在的话返回单词的位置。 列表里的单词，必须是已经按字母顺序排好序的。 \u0026#34;\u0026#34;\u0026#34; s1 = int((len(t))/2) s = s1 #如果a在列表内，s保存a的下标 while s1 \u0026gt; 0: if a == t[s1]: return s elif a \u0026gt; t[s1]: t = t[s1:] s1 = int(len(t)/2) #在循环过程中，确保s和s1所指的是同一个元素。 #print(a,\u0026#34;的位置大于\u0026#34;,s) s += s1 else: t = t[:s1] s1 = int(len(t)/2) #print(a,\u0026#34;的位置小于等于\u0026#34;,s) s -= s1 return None t1 = [\u0026#39;a\u0026#39;,\u0026#39;b\u0026#39;,\u0026#39;c\u0026#39;,\u0026#39;d\u0026#39;,\u0026#39;e\u0026#39;,\u0026#39;f\u0026#39;,\u0026#39;g\u0026#39;,\u0026#39;h\u0026#39;,\u0026#39;i\u0026#39;,\u0026#39;j\u0026#39;,\u0026#39;k\u0026#39;,\u0026#39;l\u0026#39;,\u0026#39;m\u0026#39;,\u0026#39;n\u0026#39;,\u0026#39;o\u0026#39;,\u0026#39;p\u0026#39;,\u0026#39;q\u0026#39;] in_bisect(t1,\u0026#39;c\u0026#39;) s和s1这两个变量，保存的是列表元素的下标。在循环过程中，确保s和s1所指的是同一个元素，即：s保存的是元素在完整列表里的下标，s1保存的是元素在切片后的列表里的下标，在两个列表里，第s个元素和第s1个元素（都从0开始）是同一个元素。\n因为涉及到除法然后取整，写代码的时候老是担心误差，总想对下标加个1或减个1，所得到的结果越来越离谱，后来干脆不加不减，反倒顺顺利利的。真的就是做多错多。代码虽然是我写出来的，但实际上我对它的运行过程并不是了如指掌。\n我画了一个图来跟踪代码运行时的状态，不能叫堆栈图，就单纯是为了跟踪变量在一次循环后会如何变化。\n这是作者的代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 import bisect def make_word_list(): word_list = [] fin = open(\u0026#39;words.txt\u0026#39;) for line in fin: word = line.strip() word_list.append(word) return word_list def in_bisect(word_list, word): \u0026#34;\u0026#34;\u0026#34;通过二分法，检查一个单词是否在一个列表里 前置条件：列表里的单词是已排序的 returns：如果单词在，返回True，否则返回False \u0026#34;\u0026#34;\u0026#34; if len(word_list) == 0: return False i = len(word_list)//2 if word_list[i] == word: return True if word_list[i] \u0026gt; word: return in_bisect(word_list[:i],word) else: return in_bisect(word_list[i+1:],word) def in_bisect_cheat(word_list,word): i = bisect.bisect_left(word_list,word) if i == len(word_list): return False return word_list[i] == word if __name__ == \u0026#39;__main__\u0026#39;: word_list = make_word_list() for word in [\u0026#39;aa\u0026#39;, \u0026#39;alien\u0026#39;, \u0026#39;allen\u0026#39;, \u0026#39;zymurgy\u0026#39;]: print(word, \u0026#39;in list\u0026#39;, in_bisect(word_list, word)) for word in [\u0026#39;aa\u0026#39;, \u0026#39;alien\u0026#39;, \u0026#39;allen\u0026#39;, \u0026#39;zymurgy\u0026#39;]: print(word, \u0026#39;in list\u0026#39;, in_bisect_cheat(word_list, word)) 用了递归，比我写的高明很多。我的代码一比较，就跟直肠子似的，没有一点弯弯绕。\n但是作者并没有返回单词在列表的下标，只是简单返回一个True或False。\n","date":"Jan 02","permalink":"https://o5o.me/post/think_python_exercise_10.10/","tags":null,"title":"Think Python Exercise 10.10 二分法"},{"categories":["Python"],"contents":"编写一个叫做middle的函数,接受一个列表作为参数,并返回一个除了第一个和最后一个元素的列表。例如:\n\u0026gt;\u0026gt;\u0026gt; t = [1, 2, 3, 4] \u0026gt;\u0026gt;\u0026gt; middle(t) [2, 3] 解答：\n1 2 3 4 5 def middle(t): return t[1:-1] t1 = [1,2,3,4] middle(t1) ","date":"Jan 02","permalink":"https://o5o.me/post/think_python_exercise_10.3/","tags":null,"title":"Think Python Exercise 10.3"},{"categories":["Python"],"contents":"编写一个叫做 has_duplicates 的函数，接受一个列表作为参数，如果一个元素在列表中出现了不止一次，则返回 True 。这个函数不能改变原列表。\n解答：\n1 2 3 4 5 6 7 8 9 10 11 12 def has_duplicates(t): p = [] for i in t: if i not in p: p.append(i) else: return False return True t1 = [1,2,3] has_duplicates(t1) ","date":"Jan 02","permalink":"https://o5o.me/post/think_python_exercise_10.7/","tags":null,"title":"Think Python Exercise 10.7"},{"categories":null,"contents":"Roam Research是一个笔记软件，Anki是一个间隔重复软件。我在RR里写的笔记有复习需求，在Anki里的卡片有编辑、整理需求，所以以前的我就用Keyboard Maestro这个工具写了一个动作（Macro）来帮我将二者联系起来。\nRR的笔记可以导出为Anki卡片（卡片仅用于复习、展示，所有的编辑都在笔记上完成），笔记更新，卡片能同步更新，笔记和卡片能相互跳转。\n可以按下面的顺序进行配置（所需文件在文章最后），手把手教学请看视频：\n【详细配置】Keyboard Maestro动作实现Roam Research笔记和Anki卡片的双向链接、跳转和同步更新，配置指南\nAnki模板导入、修改 要改的地方就一处：修改模板里的RR graph名称。不改的话就没办法从Anki跳转回RR了。\nKM动作导入、修改 要改的地方也就只有一处：把你的Anki牌组的名字填进去。\nAnki插件安装 anki connect，插件代码：2055492159\n禁用App Nap 从Mac OS X Mavericks开始，操作系统中引入了名为App Nap的功能。此功能导致某些打开（但不可见）的应用程序处于挂起状态。由于此行为会导致Anki Connect在前台有另一个窗口时停止工作，因此应禁用Anki的App Nap1。\n在终端运行下面的命令即可。\n1 2 3 defaults write net.ankiweb.dtop NSAppSleepDisabled -bool true defaults write net.ichi2.anki NSAppSleepDisabled -bool true defaults write org.qt-project.Qt.QtWebEngineCore NSAppSleepDisabled -bool true 最后 这就配置完成了，是不是很简单？quicker版的动作配置更简单，除了下载插件，啥都不用配置，自动配置。想想以前真的傻，我给quicker版的这个动作加了批量导入、多种挖空标记、多种方式排列的笔记导入、自动从Anki获取牌组列表、自动添加Anki模板等等功能，这些功能在我现在看来用途很小很小，但当时却花了大量时间去改动作、修bug，浪费了很多时间在完全没必要的事情上。\n模板、动作下载链接: 百度网盘，提取码: 3tvu\n希望能给看到这里的你带来一些帮助。\nNotes for MacOS Users\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"Jan 02","permalink":"https://o5o.me/post/rr_km_anki_configuration_tutorial/","tags":["Anki","RoamResearch","KeyboardMaestro","bilibili"],"title":"Roam Research和Anki联用：动作配置"},{"categories":["Python"],"contents":" 画一个执行 circle(bob,radius) 时的堆栈图（stack diagram），说明程序的各个状态。你可以手动进行计算，也可以在代码中加入打印语句。 “重构”一节中给出的 arc 函数版本并不太精确，因为圆形的线性近似（linear approximation）永远处在真正的圆形之外。因此，Turtle 总是和正确的终点相差几个像素。我的答案中展示了降低这个错误影响的一种方法。阅读其中的代码，看看你是否能够理解。如果你画一个堆栈图的话，你可能会更容易明白背后的原理。 先放上代码，得到代码过程可以看Think Python Exercise 4.0。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 import turtle import math def polyline(t,length,n,angle): for i in range(n): t.fd(length) t.lt(angle) def arc(t,r,angle): \u0026#34;\u0026#34;\u0026#34;angle取值范围是1~360，度数。 画出圆的一部分。 \u0026#34;\u0026#34;\u0026#34; arc_length = 2 * math.pi * r * angle / 360 n = int(arc_length / 3) + 1 step_length = arc_length / n step_angle = angle / n polyline(t,step_length,n,step_angle) def circle(t,r): arc(t,r,360) #circle是arc函数在角度angle取360时的特例 bob = turtle.Turtle() circle(bob,100) turtle.mainloop() 我画的堆栈图如下：\n来看看作者重构的代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 \u0026#34;\u0026#34;\u0026#34;This module contains a code example related to Think Python, 2nd Edition by Allen Downey http://thinkpython2.com Copyright 2015 Allen Downey License: http://creativecommons.org/licenses/by/4.0/ \u0026#34;\u0026#34;\u0026#34; from __future__ import print_function, division import math import turtle def square(t, length): \u0026#34;\u0026#34;\u0026#34;Draws a square with sides of the given length. Returns the Turtle to the starting position and location. \u0026#34;\u0026#34;\u0026#34; for i in range(4): t.fd(length) t.lt(90) def polyline(t, n, length, angle): \u0026#34;\u0026#34;\u0026#34;Draws n line segments. t: Turtle object n: number of line segments length: length of each segment angle: degrees between segments \u0026#34;\u0026#34;\u0026#34; for i in range(n): t.fd(length) t.lt(angle) def polygon(t, n, length): \u0026#34;\u0026#34;\u0026#34;Draws a polygon with n sides. t: Turtle n: number of sides length: length of each side. \u0026#34;\u0026#34;\u0026#34; angle = 360.0/n polyline(t, n, length, angle) def arc(t, r, angle): \u0026#34;\u0026#34;\u0026#34;Draws an arc with the given radius and angle. t: Turtle r: radius angle: angle subtended by the arc, in degrees \u0026#34;\u0026#34;\u0026#34; arc_length = 2 * math.pi * r * abs(angle) / 360 #角度变为绝对值 n = int(arc_length / 4) + 3 #之前是int(arc_length / 3) + 1 step_length = arc_length / n step_angle = float(angle) / n # making a slight left turn before starting reduces # the error caused by the linear approximation of the arc # 在开始前稍微左转可以减少由直线逼近弧线所引起的误差 t.lt(step_angle/2) polyline(t, n, step_length, step_angle) t.rt(step_angle/2) def circle(t, r): \u0026#34;\u0026#34;\u0026#34;Draws a circle with the given radius. t: Turtle r: radius \u0026#34;\u0026#34;\u0026#34; arc(t, r, 360) # the following condition checks whether we are # running as a script, in which case run the test code, # or being imported, in which case don\u0026#39;t. if __name__ == \u0026#39;__main__\u0026#39;: bob = turtle.Turtle() # draw a circle centered on the origin radius = 100 bob.pu() #抬笔 bob.fd(radius) bob.lt(90) bob.pd() #落笔 circle(bob, radius) # wait for the user to close the window turtle.mainloop() 我画的堆栈图：\n代码主要的变化在于，作者换了种方式来计算用于近似圆的多边形的边数，所需边数更少了；在开始画画之前，让turtle稍微左转（多边形外角角度的一半），减少由直线逼近弧线所引起的误差。\n目前就分析出这么多。\n","date":"Jan 01","permalink":"https://o5o.me/post/think_python_exercise_4.1/","tags":null,"title":"Think Python Exercise 4.1"},{"categories":["Python"],"contents":" 写一个名为 square 的函数，接受一个名为 t 的形参，t 是一个海龟。这个函数应用这只海龟画一个正方形。 写一个函数调用，将 bob 作为实参传给 square ，然后再重新运行程序。\n1 2 3 4 5 6 7 8 9 10 11 12 import turtle def square(t): for i in range(4): t.fd(100) t.lt(90) bob = turtle.Turtle() square(bob) turtle.mainloop() 给 square 增加另一个名为 length 的形参。修改函数体，使得正方形边的长度是 length ，然后修改函数调用，提供第二个实参。 重新运行程序。用一系列 length 值测试你的程序。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import turtle def square(t,length): for i in range(4): t.fd(length) t.lt(90) bob = turtle.Turtle() square(bob,100) square(bob,120) square(bob,150) square(bob,200) turtle.mainloop() 复制 square ，并将函数改名为 polygon 。增加另外一个名为 n 的形参并修改函数体，让它画一个正n边形（n-sided regular polygon）。提示：正n边形的外角是$360/n$度。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 import turtle def polygon(t,length,n): for i in range(n): t.fd(length) t.lt(360/n) bob = turtle.Turtle() polygon(bob,100,6) polygon(bob,100,8) polygon(bob,100,15) turtle.mainloop() 看了答案后，觉得把360/n放到循环外面比较好，这样的话只需要计算一次。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import turtle def polygon(t,length,n): angle = 360 / n for i in range(n): t.fd(length) t.lt(angle) bob = turtle.Turtle() polygon(bob,100,6) polygon(bob,100,8) polygon(bob,100,15) turtle.mainloop() 编写一个名为 circle 的函数，它接受一个海龟t和半径r作为形参， 然后以合适的边长和边数调用 polygon ，画一个近似圆形。 用一系列r值测试你的函数。 提示：算出圆的周长，并确保 length * n = circumference 。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 import turtle import math def polygon(t,length,n): for i in range(n): t.fd(length) t.lt(360/n) def circle(t,r): \u0026#34;\u0026#34;\u0026#34;t是一只乌龟。r是所要画的圆的半径。 根据公式$2 \\pi r / n$确定用于近似圆的多边形的边长，n是多边形的边数。 \u0026#34;\u0026#34;\u0026#34; circumference = 2 * math.pi * r #周长 n = 200 #多边形边数，我想不到选多少边数合适，直接设200，画一个200边形 length = circumference / n polygon(t,length,n) bob = turtle.Turtle() circle(bob,150) #半径r设为150 turtle.mainloop() 答案是这样来确定n的值（多边形的边数）的：周长除以3，取整后加1，即n = int(circumference/3)+1，也就是近似为周长的三分之一，圆的半径的两倍。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 import turtle import math def polygon(t,length,n): angle = 360 / n for i in range(n): t.fd(length) t.lt(angle) def circle(t,r): \u0026#34;\u0026#34;\u0026#34;t是一只乌龟。r是所要画的圆的半径。 根据公式$2 \\pi r / n$确定用于近似圆的多边形的边长，n是多边形的边数。 \u0026#34;\u0026#34;\u0026#34; circumference = 2 * math.pi * r #周长 n = int(circumference/3)+1 #改的是这句 length = circumference / n polygon(t,length,n) bob = turtle.Turtle() circle(bob,150) #半径r设为150 turtle.mainloop() 完成一个更泛化（general）的 circle 函数，称其为 arc ，接受一个额外的参数 angle ，确定画多完整的圆。angle 的单位是度，因此当 angle=360 时， arc 应该画一个完整的圆。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 import turtle import math def polyline(t,length,n,m): \u0026#34;\u0026#34;\u0026#34;n是多边形的边数，m是指画出多边形的前多少条边 n和m必须为整数。 \u0026#34;\u0026#34;\u0026#34; for i in range(m): t.fd(length) t.lt(360/n) def arc(t,r,angle): \u0026#34;\u0026#34;\u0026#34;angle取值范围是1~360，度数。 画出圆的一部分。 \u0026#34;\u0026#34;\u0026#34; circumference = 2 * math.pi * r #周长 n = 200 #多边形边数，我想不到选多少边数合适，直接设200 length = circumference / n #多边形边长 m = int(n * angle / 360) # 画出多边形的前m条边 polyline(t,length,n,m) bob = turtle.Turtle() arc(bob,150,30) arc(bob,100,150) arc(bob,150,270) turtle.mainloop() 我是先算出来圆的周长，然后算出用于近似这个圆的多边形的边数，然后再算出近似圆的一部分需要的多边形的边数；\n答案是先算圆的一部分对应的长度，根据这个长度得到用边数为n的多边形去近似圆，然后得到一边的长度，以及多边形的外角的角度。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 import turtle import math def polyline(t,length,n,angle): for i in range(n): t.fd(length) t.lt(angle) def arc(t,r,angle): \u0026#34;\u0026#34;\u0026#34;angle取值范围是1~360，度数。 画出圆的一部分。 \u0026#34;\u0026#34;\u0026#34; arc_length = 2 * math.pi * r * angle / 360 n = int(arc_length / 3) + 1 step_length = arc_length / n step_angle = angle / n polyline(t,step_length,n,step_angle) bob = turtle.Turtle() arc(bob,150,30) arc(bob,100,150) arc(bob,150,270) turtle.mainloop() 根据这一题的代码，可以重写第四题的circle函数。circle函数可以看作是arc函数的一个特例。\n1 2 def circle(t,r): arc(t,r,360) ","date":"Jan 01","permalink":"https://o5o.me/post/think_python_exercise_4.0/","tags":null,"title":"Think Python Exercise 4.0"},{"categories":["Python"],"contents":"下面程序的输出是什么？画出展示程序每次打印输出时的堆栈图。\n1 2 3 4 5 6 7 def recurse(n, s): if n == 0: print(s) else: recurse(n-1, n+s) recurse(3, 0) 如果你这样调用函数： recurse(-1,0) ，会有什么结果？ 请写一个文档字符串，解释调用该函数时需要了解的全部信息（仅此而已）。 解答：\n我用obsidian的Excalidraw插件画了一个。\n如果这样调用函数： recurse(-1,0)，Python会抛出一个递归错误：超过最大递归深度。\n\u0026gt;\u0026gt;\u0026gt; recurse(-1,0) Traceback (most recent call last): File \u0026#34;\u0026lt;stdin\u0026gt;\u0026#34;, line 1, in \u0026lt;module\u0026gt; File \u0026#34;\u0026lt;stdin\u0026gt;\u0026#34;, line 5, in recurse File \u0026#34;\u0026lt;stdin\u0026gt;\u0026#34;, line 5, in recurse File \u0026#34;\u0026lt;stdin\u0026gt;\u0026#34;, line 5, in recurse [Previous line repeated 996 more times] RecursionError: maximum recursion depth exceeded 写一个文档字符串，解释调用该函数时需要了解的全部信息\n1 2 3 4 5 6 7 8 9 10 11 def recurse(n, s): \u0026#34;\u0026#34;\u0026#34;将s与前n个正整数（从1到n）相加， n是一个正整数， s可以是任意数字 \u0026#34;\u0026#34;\u0026#34; if n == 0: print(s) else: recurse(n-1, n+s) recurse(3, -5) ","date":"Jan 01","permalink":"https://o5o.me/post/think_python_exercise_5.4/","tags":null,"title":"Think Python Exercise 5.4"},{"categories":["RegEx"],"contents":"最近在用SuperMemo渐进阅读旋元佑的《英语魔法师之语法俱乐部》这本语法书。我的阅读前流程是这样的：（括号内的是所用工具）\n将epub电子书按章节分割（calibre-EpubSplit） 将需要阅读的章节导入SuperMemo（Quicker、pandoc、AutoHotkey） 在SuperMemo内将该章节分割成更小的卡片（鼠标右键-阅读-分割-分割文章） 统一将所得的所有卡片设为新材料（根卡片鼠标右键-处理选中分支-学习-忘记） 菜单栏-学习-阶段-新学材料（也可等当天复习完后根据提示进入） 问题在于，我所拥有的这本epub电子书，html标签很乱，导致我在导入SM后无法正确根据html标签分割文章，因此在导入SM前需要先整理epub文件的html标签。这也就是这篇文章的由来。\n截取这本书的一个片段：\n1 \u0026lt;p class=\u0026#34;calibre_16\u0026#34;\u0026gt;以上谈的是修饰动词专用的“方法、状态副词”，以及它在句中位置的变化原则。接下来看看其他种类的副词。\u0026lt;/p\u0026gt;\u0026lt;blockquote class=\u0026#34;calibre_5\u0026#34;\u0026gt;\u0026lt;blockquote class=\u0026#34;calibre2\u0026#34;\u0026gt;\u0026lt;blockquote class=\u0026#34;calibre2\u0026#34;\u0026gt;\u0026lt;blockquote class=\u0026#34;calibre2\u0026#34;\u0026gt;\u0026lt;blockquote class=\u0026#34;calibre_21\u0026#34;\u0026gt;\u0026lt;span class=\u0026#34;calibre1\u0026#34;\u0026gt;\u0026lt;span class=\u0026#34;bold\u0026#34;\u0026gt;\u0026lt;span class=\u0026#34;calibre_12\u0026#34;\u0026gt;强调语气的副词（Intensifiers)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\u0026lt;/blockquote\u0026gt;\u0026lt;/blockquote\u0026gt;\u0026lt;/blockquote\u0026gt;\u0026lt;/blockquote\u0026gt;\u0026lt;a id=\u0026#34;filepos295095\u0026#34;\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/blockquote\u0026gt;\u0026lt;p class=\u0026#34;calibre_24\u0026#34;\u0026gt;这一类副词有一个特色：它在使用上很有弹性，\u0026lt;span class=\u0026#34;bold\u0026#34;\u0026gt;四种主要词类，包括名词、动词、形容词与副词都可以用它来修饰。\u0026lt;/span\u0026gt;认识这一点，才算真正弄清楚形容词与副词间的分工。这一类的副词又可以细分为以下三种：\u0026lt;/p\u0026gt; 所要做的是把下面这一段变为：\u0026lt;h2\u0026gt;强调语气的副词（Intensifiers)\u0026lt;/h2\u0026gt;，这样我就可以在SM里很方便地按h2标签分割内容。\n1 \u0026lt;blockquote class=\u0026#34;calibre2\u0026#34;\u0026gt;\u0026lt;blockquote class=\u0026#34;calibre2\u0026#34;\u0026gt;\u0026lt;blockquote class=\u0026#34;calibre2\u0026#34;\u0026gt;\u0026lt;blockquote class=\u0026#34;calibre_21\u0026#34;\u0026gt;\u0026lt;span class=\u0026#34;calibre1\u0026#34;\u0026gt;\u0026lt;span class=\u0026#34;bold\u0026#34;\u0026gt;\u0026lt;span class=\u0026#34;calibre_12\u0026#34;\u0026gt;强调语气的副词（Intensifiers)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\u0026lt;/blockquote\u0026gt;\u0026lt;/blockquote\u0026gt;\u0026lt;/blockquote\u0026gt;\u0026lt;/blockquote\u0026gt; 可以看到，一共是4个blockquote标签，3个span标签，那么我们可以先设法用正则匹配出一个起始blockquote标签，然后重复4次，匹配出一个起始span标签，然后重复3词，就能匹配出所有的起始标签了。\n(\u0026lt;blockquote\\s[^\u0026gt;]*\u0026#34;\u0026gt;){4}(\u0026lt;span\\s[^\u0026gt;]*\u0026#34;\u0026gt;){3} 同样的道理，匹配所有的闭合标签。\n(\u0026lt;\\/span\u0026gt;){3}(\u0026lt;/blockquote\u0026gt;){4} 最后，标题可以用(.*?)匹配，把它们组合在一起，就成功匹配出了这段html代码。\n(\u0026lt;blockquote\\s[^\u0026gt;]*\u0026#34;\u0026gt;){4}(\u0026lt;span\\s[^\u0026gt;]*\u0026#34;\u0026gt;){3}(.*?)(\u0026lt;\\/span\u0026gt;){3}(\u0026lt;/blockquote\u0026gt;){4} 将其用下面的内容替换，内容就整理好了。\n\\n\u0026lt;h2\u0026gt;$3\u0026lt;/h2\u0026gt;\\n 上面的正则，经过我的实践，是比较经济实惠的。以后如果有更好的方案，本文会继续更新。\n","date":"Dec 31","permalink":"https://o5o.me/post/regexps_match_html_tags/","tags":["SuperMemo","Epub"],"title":"正则表达式匹配HTML标签"},{"categories":["Python"],"contents":"如果可以通过重排一个单词中字母的顺序，得到另外一个单词，那么称这两个单词是变位词。编写一个叫做 is_anagram 的函数，接受两个字符串作为参数， 如果它们是变位词则返回 True 。\n解答：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 def is_anagram(s1,s2): t1 = list(s1) t2 = list(s2) #先把字符串转换成列表 if len(t1) == len(t2): #如果两个字符串长度都不一样，那么肯定不是变位词了 t1.sort() t2.sort() #按照同样的方式重新排序后，如果二者元素对应相等，那么它们就是变位词了 for i in range(len(t1)): if t1[i] == t2[i]: pass else: return False return True else: return False is_anagram(\u0026#39;abc\u0026#39;,\u0026#39;bac\u0026#39;) ","date":"Dec 31","permalink":"https://o5o.me/post/think_python_exercise_10.6/","tags":null,"title":"Think Python Exercise 10.6"},{"categories":["Python"],"contents":"编写一个叫做is_sorted的函数，接受一个列表作为参数，如果列表是递增排列的则返回 True ，否则返回False。 例如：\n\u0026gt;\u0026gt;\u0026gt; is_sorted([1, 2, 2]) True \u0026gt;\u0026gt;\u0026gt; is_sorted([\u0026#39;b\u0026#39;, \u0026#39;a\u0026#39;]) False 分析：\n可以先对列表用.sort()方法进行递增排列，如果递增排列后的列表和原列表的元素都对应相同，说明原列表本身就是递增排列的。\n一个错误的写法：\n1 2 3 4 5 6 7 8 9 def is_sorted(t): t_copy = t[:] print(t_copy) if t_copy == t.sort(): return True else: return False is_sorted([1, 2, 2]) 程序没有报错，但它仍是错的，因为，我们要比较的是两个列表里的元素对应相同，而不是看这两个变量是不是指向同一个列表。t_copy和t.sort()肯定不指向同一个列表，但它们的元素对应相同。因此我们不能用t_copy == t.sort()这样的方法来比较。可以这样做：\n1 2 3 4 5 6 7 8 9 10 11 def is_sorted(t): t_copy = t[:] for i in range(len(t)): if t_copy[i] == t[i]: #如果递增排列后的列表和原列表的元素都对应相同，说明原列表本身就是递增排列的 pass else: return False return True is_sorted([1, 2, 2]) 还可以用另一种方法实现：从第二个元素开始，依次和前面一个元素比较大小。\n字符串也可以进行大小比较。英文字母按字母顺序从小到大；所有的大写字母在小写字母前面，所以如果进行大小比较的话，'A'\u0026lt;'Z'\u0026lt;'a'\u0026lt;'z'。\n1 2 3 4 5 6 7 8 9 10 def is_sorted(t): for i in range(1,len(t)): #从1开始，而不是从0开始生成序列 if t[i] \u0026gt;= t[i-1]: #如果从第二个元素开始，每一个元素都比它前面一个元素大，说明这个列表就是递增的 pass else: return False return True is_sorted([1, 2, 2]) ","date":"Dec 31","permalink":"https://o5o.me/post/think_python_exercise_10.5/","tags":null,"title":"Think Python Exercise 10.5"},{"categories":["Python"],"contents":"编写一个叫做 chop 的函数，接受一个列表作为参数，移除第一个和最后一个元素，并返回None。例如：\n\u0026gt;\u0026gt;\u0026gt; t = [1, 2, 3, 4] \u0026gt;\u0026gt;\u0026gt; chop(t) \u0026gt;\u0026gt;\u0026gt; t [2, 3] 分析：\n一顿操作猛如虎：（错的）\n1 2 3 4 5 6 7 8 def chop(t): t = t[1:-1] t1 = [1, 2, 3, 4] chop(t1) t1 为什么t1没变化？是我列表切片用错了吗，再试试：（还是错的）\n1 2 3 4 5 6 7 8 def chop(t): t = t[1:len(t)-2] t1 = [1, 2, 3, 4] chop(t1) t1 可以看到，t1还是没变化，为什么？为什么这样是错的？\n不要被迷惑了，当一个列表t1传递给一个函数时，t1和形参t共同指向同一个列表，但当函数内部t重新赋值后，t指向了一个新的列表，而t1依然指向原来的列表，那么当函数运行结束后，t1的值当然还是原来的啦。\n由于题目要求函数不能有返回值，可以使用下面的做法：\n1 2 3 4 5 6 7 8 9 def chop(t): del t[0] del t[-1] t1 = [1, 2, 3, 4] chop(t1) t1 如果函数可以有返回值，可以这样写：\n1 2 3 4 5 6 7 8 def chop(t): return t[1:-1] t1 = [1, 2, 3, 4] t1 = chop(t1) t1 ","date":"Dec 31","permalink":"https://o5o.me/post/think_python_exercise_10.4/","tags":null,"title":"Think Python Exercise 10.4"},{"categories":["Python"],"contents":"编写一个函数，读取文件 words.txt ，建立一个列表,其中每个单词为一个元素。\n编写两个版本，一个使用 append 方法，另一个使用 t = t + [x] 。那个版本运行得慢？为什么？\n解答：\n在 jupyter 中的一个代码单元（cell）中，代码第一行写上%%time或%%timeit，即可计算代码的运行时间。\n版本1：\n1 2 3 4 5 6 7 8 9 10 11 12 %%time def read_word1(file_in): word_list = [] for line in file_in: word = line.strip() word_list.append(word) return word_list fin = open(\u0026#39;words.txt\u0026#39;) a = read_word1(fin) 运行结果：\nCPU times: user 85.3 ms, sys: 0 ns, total: 85.3 ms Wall time: 88.4 ms\n版本2：\n1 2 3 4 5 6 7 8 9 10 11 12 %%time def read_word2(file_in): word_list = [] for line in file_in: word = line.strip() word_list = word_list + [word] #相当于word_list这个列表和一个只有一个元素的列表合并 return word_list fin = open(\u0026#39;words.txt\u0026#39;) a = read_word2(fin) 运行结果：\nCPU times: user 1min 1s, sys: 13.5 ms, total: 1min 1s Wall time: 1min 1s\n结果很显然，即便不准确测量也能感知到，第二个版本的代码相比第一个慢了很多。\n第一版的代码，每次循环，仅仅是操作一个元素，把它追加到列表末端；而第二版的代码，每次循环都要进行一次两个列表的拼接。\n","date":"Dec 31","permalink":"https://o5o.me/post/think_python_exercise_10.9/","tags":null,"title":"Think Python Exercise 10.9"},{"categories":["Python"],"contents":"编写一个叫做 cumsum 的函数，接受一个由数值组成的列表，并返回累加和；即一个新列表，其中第i个元素是原列表中前i+1个元素的和（注意i是从0开始的）。 例如：\n\u0026gt;\u0026gt;\u0026gt; t = [1, 2, 3] \u0026gt;\u0026gt;\u0026gt; cumsum(t) [1, 3, 6] 解答：\n1 2 3 4 5 6 7 8 9 10 11 12 def cumsum(t): numsum = [] for i in range(len(t)): numsum.append(sum(t[:i+1])) #对t的前i+1个元素求和（注意i是从0开始，所以第i个元素是第i+1个元素），然后追加到新列表里 return numsum t = [1, 2, 3] print(cumsum(t)) t = [3,3,6,9,10] print(cumsum(t)) ","date":"Dec 31","permalink":"https://o5o.me/post/think_python_exercise_10.2/","tags":null,"title":"Think Python Exercise 10.2"},{"categories":["Python"],"contents":"编写一个叫做 nested_sum 的函数，接受一个由一些整数列表构成的列表作为参数，并将所有嵌套列表中的元素相加。例如：\n\u0026gt;\u0026gt;\u0026gt; t = [[1, 2], [3], [4, 5, 6]] \u0026gt;\u0026gt;\u0026gt; nested_sum(t) 21 解答：\n可以分别对每个子列表求和，再对得到的各个和求和。也可以先把各个子列表合并起来，然后对得到的列表求和。\n1 2 3 4 5 6 7 8 9 def nested_sum(t): c = [] for i in t: c = c + i #把t列表里的各个列表合并成一个列表 return sum(c) t = [[1, 2], [3], [4, 5, 6]] nested_sum(t) ","date":"Dec 31","permalink":"https://o5o.me/post/think_python_exercise_10.1/","tags":null,"title":"Think Python Exercise 10.1"},{"categories":["SRS"],"contents":"在用SuperMemo复习时，一边要移动鼠标，浏览卡片内容，一边要用键盘评分、修改卡片内容，容易手忙脚乱。把评分常用的按键和其他一些按键映射到游戏手柄上可以稍微方便一点。\n游戏手柄：八位堂Zero2小手柄。 软件：AntiMicroX\n手柄连接计算机 看说明书即可。\n在AntiMicroX中设定快捷键 打开软件后，点手柄上的按键，可以看到有的按键映射是错的，点软件窗口左下角的“游戏控制器映射”，先矫正一遍。\n然后在软件主窗口中找到你想设定快捷键的按键（可以通过按手柄上的对应按键确定它的位置），鼠标点击，设定快捷键即可。\n在我的SuperMemo中，目前是有很多的摘录卡片，以及很少的填空题卡片。我习惯于一边复习一边编辑卡片内容，比如把一段紧凑的话分成一行一行的句子，修改一些措辞。\n在SM中，当我的鼠标点击了卡片，可以看作我进入了“编辑模式”，如果这张卡片看完了，想进入下一张卡片，我需要先退出“编辑模式”（按ESC），再按回车键。可以把这两个键简化为一个键，在游戏手柄上按一次，无论你是不是在“编辑模式”，都可以跳转到下一张卡片。\n在AntiMicroX窗口中鼠标点击按键，在弹出的窗口中点击“高级选项”，又弹出一个窗口，在“分配”栏里点击“小方块”（里面出现\u0026quot;\u0026hellip;\u0026quot;），这时候在键盘上输入想设定的按键。设定两个按键，那么点击游戏手柄上的按键时，这两个按键会依次执行。\n我的按键设定 设定原则是，使用越多的按键放在越容易按的位置。\n使用手柄时我习惯竖着拿。除了十字方向键（我不用），最不方便按的是左肩键，其次是右肩键，然后是开始键和选择键。\n因此，我的设定是：\n左肩键，评分5。一是用的少，二来对一张卡片评分5时需要调整手的握姿，这样就会很慎重、很有仪式感。如果这种情况下还非要把一张卡片评分为5，说明真的掌握的很好了。\n右肩键，评分2。答错时按的。\nA，评分3/ENTER。最容易按的键。因为在评分时，按Enter键的效果和按3是一样的，所以设定为Enter，这样在复习时就不用频繁移动手指了。\nX，评分1。\nB，评分4。\nY，ESC+Enter，切换到下一张卡片。\n为什么A设定了Enter，这里还要再设定一个ESC+Enter呢？或者能不能都用ESC+Enter呢？你复习的时候亲手去操作一下就明白了。评分时按ESC+Enter没效果；阅读并编辑卡片时，按Enter不会跳转到下一张卡片，而是在卡片里添加一个空行。\n这是一件很主观的事情，怎么舒服怎么来。\n全文完。\n","date":"Dec 30","permalink":"https://o5o.me/post/supermemo-gamepad/","tags":["SuperMemo"],"title":"游戏手柄用于SuperMemo复习"},{"categories":["Python"],"contents":"编写一个名为is_abecedarian 的函数, 如果单词中的字符以字符表的顺序出现 (允许重复字符),则返回True。有多少个具备这种特征的单词?\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 def word_abcde(word): alphabets = \u0026#34;abcdefghijklmnopqrstuvwxyz\u0026#34; i = 0 front = 0 #前一个字母的序数 mine = 0 #当前字母的序数 while i \u0026lt; len(word): index = 0 while index \u0026lt; len(alphabets): # print(i,word[i],index,alphabets[index]) if word[i] == alphabets[index]: mine = index if mine \u0026lt; front: return False else: front = mine break index += 1 i += 1 return True def is_abecedarian(file_in): count = 0 for line in file_in: word = line.strip() if word_abcde(word): count += 1 #print(word) print(count) fin = open(\u0026#39;words.txt\u0026#39;) is_abecedarian(fin) 我所使用的这个单词表里，这样的单词有596个。\n","date":"Dec 29","permalink":"https://o5o.me/post/think_python_exercise_9.6/","tags":null,"title":"Think Python Exercise 9.6"},{"categories":["Python"],"contents":"编写一个名为uses_all的函数,接受一个单词和一个必须使用的字符组成的字符串。如果该单词包括此字符串中的全部字符至少一次,则返回True。你能统计出多少单词包含了所有的元音字符aeiou吗?如果换成aeiouy 呢?\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 def uses_all(word, muststr): for i in muststr: count = 0 index = 0 while index \u0026lt; len(word): if i == word[index]: break index += 1 if index == len(word): return False return True def count_word(file_in, als): count = 0 for line in file_in: word = line.strip() if uses_all(word, als): count += 1 print(count,\u0026#34;个单词包含了\u0026#34;,als,\u0026#34;所有的字符\u0026#34;) fin = open(\u0026#39;words.txt\u0026#39;) count_word(fin, \u0026#34;aeiouy\u0026#34;) 运行结果：\n598 个单词包含了 aeiou 所有的字符\n42 个单词包含了 aeiouy 所有的字符\n可以发现，uses_all函数和9.4的uses_only函数的实现一模一样，其实没必要再写一遍。\n","date":"Dec 29","permalink":"https://o5o.me/post/think_python_exercise_9.5/","tags":null,"title":"Think Python Exercise 9.5"},{"categories":["Python"],"contents":"编写一个名为 avoids 的函数，接受一个单词和一个指定禁止使用字符的字符串，如果单词中不包含任意被禁止的字符，则返回True 。\n修改你的程序，提示用户输入一个禁止使用的字符，然后打印不包含这些字符的单词的数量。你能找到一个5个禁止使用字符的组合，使得其排除的单词数目最少么？\n你能找到一个\u0026quot;5个禁止使用字符\u0026quot;的组合，使得其排除的单词数目最少么？ 分析：从26个字母中挑选5个字母构成一个组合，打印不包含这些字母的单词的数量，看哪个组合下被排除出去的单词数目最少。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 def avoids(word,ause): #ause，avoid use for i in ause: for letter in word: if letter == i: return False return True def has_no_string(file_in, nals): #nals指的是no alphabets，字母 count_nals = 0 #不含用户指定的各个字符的单词的个数 for line in file_in: word = line.strip() if avoids(word,nals): count_nals += 1 print(\u0026#34;不含\u0026#34;,nals,\u0026#34;的单词有\u0026#34;,count_nals,\u0026#34;个\u0026#34;) text = input(\u0026#34;请输入一个禁止使用的字符串，字符串里的字母都不会出现在单词中\\n\u0026#34;) fin = open(\u0026#39;words.txt\u0026#39;) has_no_string(fin,text) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 def avoids(word,ause): #ause，avoid use for i in ause: for letter in word: if letter == i: return False return True def has_no_string(file_in, nals): #nals指的是no alphabets，字母 count_nals = 0 #不含用户指定的各个字符的单词的个数 for line in file_in: word = line.strip() if avoids(word,nals): count_nals += 1 # print(\u0026#34;不含\u0026#34;,nals,\u0026#34;的单词有\u0026#34;,count_nals,\u0026#34;个\u0026#34;) return count_nals def alp5group(file_in): #5个字母的组合，起名困难 alphabets = \u0026#34;abcdefghijklmnopqrstuvwxyz\u0026#34; count_word = 0 # 不含指定的5个字母的单词的数量 namegroup = \u0026#39;\u0026#39; # 不含5个字符的组合，单词最多 i = 0 while i \u0026lt; len(alphabets): group = \u0026#39;\u0026#39; group += alphabets[i] j = 1 while j \u0026lt; len(alphabets[i:]): group += alphabets[i+j] k = 1 while k \u0026lt; len(alphabets[i+j:]): group += alphabets[i+j+k] l = 1 while l \u0026lt; len(alphabets[i+j+k:]): group += alphabets[i+j+k+l] m = 1 while m \u0026lt; len(alphabets[i+j+k+l:]): group += alphabets[i+j+k+l+m] count = has_no_string(file_in,group) if count \u0026gt; count_word: count_word = count namegroup = group m += 1 l += 1 k += 1 j += 1 i += 1 print(\u0026#34;组合\u0026#34;,namegroup,\u0026#34;被排除出去的单词数目最少，单词数量为\u0026#34;,count_word) fin = open(\u0026#39;words.txt\u0026#39;) alp5group(fin) 下面是使用 in 操作符优化后的方案，可以用 in 真的太幸福了😭。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 def avoids(word,ause): #ause，avoid use for i in ause: if i in word: return False return True fin = open(\u0026#39;words.txt\u0026#39;) text = input(\u0026#34;请输入一个禁止使用的字符串，字符串里的字母都不会出现在单词中\\n\u0026#34;) count = 0 #单词总数 count_n = 0 #不含用户输入字符的单词的个数 for line in fin: word = line.strip() count += 1 if avoids(word,text): count_n += 1 print(\u0026#34;不含\u0026#34;,text,\u0026#34;的单词有\u0026#34;,count_n,\u0026#34;个，单词一共：\u0026#34;,count) ","date":"Dec 29","permalink":"https://o5o.me/post/think_python_exercise_9.4/","tags":null,"title":"Think Python Exercise 9.4"},{"categories":["Python"],"contents":"编写一个名为 avoids 的函数，接受一个单词和一个指定禁止使用字符的字符串，如果单词中不包含任意被禁止的字符，则返回True 。\n修改你的程序，提示用户输入一个禁止使用的字符，然后打印不包含这些字符的单词的数量。你能找到一个5个禁止使用字符的组合，使得其排除的单词数目最少么？\n你能找到一个\u0026quot;5个禁止使用字符\u0026quot;的组合，使得其排除的单词数目最少么？ 分析：从26个字母中挑选5个字母构成一个组合，打印不包含这些字母的单词的数量，看哪个组合下被排除出去的单词数目最少。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 def avoids(word,ause): #ause，avoid use for i in ause: for letter in word: if letter == i: return False return True def has_no_string(file_in, nals): #nals指的是no alphabets，字母 count_nals = 0 #不含用户指定的各个字符的单词的个数 for line in file_in: word = line.strip() if avoids(word,nals): count_nals += 1 print(\u0026#34;不含\u0026#34;,nals,\u0026#34;的单词有\u0026#34;,count_nals,\u0026#34;个\u0026#34;) text = input(\u0026#34;请输入一个禁止使用的字符串，字符串里的字母都不会出现在单词中\\n\u0026#34;) fin = open(\u0026#39;words.txt\u0026#39;) has_no_string(fin,text) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 def avoids(word,ause): #ause，avoid use for i in ause: for letter in word: if letter == i: return False return True def has_no_string(file_in, nals): #nals指的是no alphabets，字母 count_nals = 0 #不含用户指定的各个字符的单词的个数 for line in file_in: word = line.strip() if avoids(word,nals): count_nals += 1 # print(\u0026#34;不含\u0026#34;,nals,\u0026#34;的单词有\u0026#34;,count_nals,\u0026#34;个\u0026#34;) return count_nals def alp5group(file_in): #5个字母的组合，起名困难 alphabets = \u0026#34;abcdefghijklmnopqrstuvwxyz\u0026#34; count_word = 0 # 不含指定的5个字母的单词的数量 namegroup = \u0026#39;\u0026#39; # 不含5个字符的组合，单词最多 i = 0 while i \u0026lt; len(alphabets): group = \u0026#39;\u0026#39; group += alphabets[i] j = 1 while j \u0026lt; len(alphabets[i:]): group += alphabets[i+j] k = 1 while k \u0026lt; len(alphabets[i+j:]): group += alphabets[i+j+k] l = 1 while l \u0026lt; len(alphabets[i+j+k:]): group += alphabets[i+j+k+l] m = 1 while m \u0026lt; len(alphabets[i+j+k+l:]): group += alphabets[i+j+k+l+m] count = has_no_string(file_in,group) if count \u0026gt; count_word: count_word = count namegroup = group m += 1 l += 1 k += 1 j += 1 i += 1 print(\u0026#34;组合\u0026#34;,namegroup,\u0026#34;被排除出去的单词数目最少，单词数量为\u0026#34;,count_word) fin = open(\u0026#39;words.txt\u0026#39;) alp5group(fin) 下面是使用 in 操作符优化后的方案，可以用 in 真的太幸福了😭。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 def avoids(word,ause): #ause，avoid use for i in ause: if i in word: return False return True fin = open(\u0026#39;words.txt\u0026#39;) text = input(\u0026#34;请输入一个禁止使用的字符串，字符串里的字母都不会出现在单词中\\n\u0026#34;) count = 0 #单词总数 count_n = 0 #不含用户输入字符的单词的个数 for line in fin: word = line.strip() count += 1 if avoids(word,text): count_n += 1 print(\u0026#34;不含\u0026#34;,text,\u0026#34;的单词有\u0026#34;,count_n,\u0026#34;个，单词一共：\u0026#34;,count) ","date":"Dec 29","permalink":"https://o5o.me/post/think_python_exercise_9.3/","tags":null,"title":"Think Python Exercise 9.3"},{"categories":["Python"],"contents":"1939年，Ernest Vincent Wright出版了一本名为 《Gadsby》 的小说，该小说里完全没有使用字符“e”。由于“e”是最常用的英文字符，因此这并不容易做到。\n事实上，不使用这个最常用的符号(字符e)来构建一个孤立的想法是很难的。开始进展缓慢，但是经过有意识的、长时间的训练，你可以逐渐地熟练。\n好啦，不再说题外话了（让我们开始编程练习）。\n写一个叫做has_no_e的函数，如果给定的单词中不包含字符“e”，其返回 True 。\n修改上一节中的程序，只打印不包含“e”的单词，并且计算列表中不含“e”单词的比例。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 fin = open(\u0026#39;words.txt\u0026#39;) def has_no_e(file_in): count_ne = 0 #不含e的单词的个数 count = 0 #总单词个数 for line in file_in: word = line.strip() index = 0 while index \u0026lt; len(word): if word[index] == \u0026#39;e\u0026#39;: break else: index = index + 1 if index == len(word): # print(word) #因为单词比较多，不一个个列出来了 count_ne = count_ne + 1 count = count + 1 print(\u0026#34;不含e的单词有\u0026#34;,count_ne,\u0026#34;个\u0026#34;,\u0026#34;单词一共有\u0026#34;,count,\u0026#34;个\u0026#34;,\u0026#34;不含“e”单词的比例为\u0026#34;,count_ne/count*100,\u0026#34;%\u0026#34;) has_no_e(fin) 上面是一个字母一个字母判断单词是不是包含‘e’的，下面是在 if 中使用 in 操作符简化后的方案：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 def has_no_e(word): if \u0026#39;e\u0026#39; not in word: return True else: return False fin = open(\u0026#39;words.txt\u0026#39;) count = 0 #单词总数 count_ne = 0 #不含e的单词数 for line in fin: word = line.strip() count += 1 if has_no_e(word): count_ne += 1 #print(word) print(\u0026#34;不含e的单词有\u0026#34;,count_ne,\u0026#34;个\u0026#34;,\u0026#34;单词一共有\u0026#34;,count,\u0026#34;个\u0026#34;,\u0026#34;不含“e”单词的比例为\u0026#34;,count_ne/count*100,\u0026#34;%\u0026#34;) 所得结果都是一样的：\n不含e的单词有 37641 个 单词一共有 113809 个 不含“e”单词的比例为 33.07383423103621 %\n","date":"Dec 29","permalink":"https://o5o.me/post/think_python_exercise_9.2/","tags":null,"title":"Think Python Exercise 9.2"},{"categories":["Python"],"contents":"编程写一个程序，使得它可以读取 words.txt　，然后只打印出那些长度超过20个字符的单词(不包括空格)。\n1 2 3 4 5 6 fin = open(\u0026#39;words.txt\u0026#39;) for line in fin: word = line.strip() if len(word) \u0026gt; 20: print(word) ","date":"Dec 28","permalink":"https://o5o.me/post/think_python_exercise_9.1/","tags":null,"title":"Think Python Exercise 9.1"},{"categories":null,"contents":"","date":"Jan 01","permalink":"https://o5o.me/articles/","tags":null,"title":"Articles"}]