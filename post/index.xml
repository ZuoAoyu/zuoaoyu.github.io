<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on o5o</title><link>https://o5o.me/post/</link><description>Recent content in Posts on o5o</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Thu, 09 Feb 2023 12:54:42 +0800</lastBuildDate><atom:link href="https://o5o.me/post/index.xml" rel="self" type="application/rss+xml"/><item><title>Django给模型字段重命名</title><link>https://o5o.me/post/django_rename_field/</link><pubDate>Thu, 09 Feb 2023 12:54:42 +0800</pubDate><guid>https://o5o.me/post/django_rename_field/</guid><description>在Django中，一个模型就是一个类，模型里的字段就是类的属性，因此本文的标题也可以写作：Django重命名类属性。
如果模型刚写好，还没在数据库中创建表，把代码里所有的旧字段名改为新字段名即可。
如果已经修改了数据库，首先在代码里将旧字段名修改为新字段名；然后需要在数据库里对表列进行重命名。在Django里不用直接操作数据库，在终端里运行命令makemigrations，Django会识别出来你是想给data_added重命名，之后再在终端运行命令migrate即可。
1 2 3 4 5 6 7 8 9 10 11 (/home/aoyu/AoyuCondaEnv/AoyuBlog) aoyu@aoyuSurface:~/AoyuPythonProjects/AoyuBlog$ python manage.py makemigrations aoyu_blog_logs Was topic.data_added renamed to topic.date_added (a DateTimeField)? [y/N] y Migrations for &amp;#39;aoyu_blog_logs&amp;#39;: aoyu_blog_logs/migrations/0004_rename_data_added_topic_date_added.py - Rename field data_added on topic to date_added (/home/aoyu/AoyuCondaEnv/AoyuBlog) aoyu@aoyuSurface:~/AoyuPythonProjects/AoyuBlog$ python manage.py migrate Operations to perform: Apply all migrations: admin, aoyu_blog_logs, auth, contenttypes, sessions Running migrations: Applying aoyu_blog_logs.0004_rename_data_added_topic_date_added... OK</description></item><item><title>Think Python Exercise 5.6 科赫曲线</title><link>https://o5o.me/post/think_python_exercise_5.6_koch_curve/</link><pubDate>Mon, 06 Feb 2023 16:52:28 +0800</pubDate><guid>https://o5o.me/post/think_python_exercise_5.6_koch_curve/</guid><description>这是一道很有趣的题目。我感觉这一题的代码我写得还不够优雅。
Exercise 5.6. 科赫曲线 (Koch Curve) 是一个看起来类似不规则碎片的几何体 (fractal)。要画一个长度为 x 的科赫曲线，你只需要：
画一个长度为 x/3 的科赫曲线。 左转 60 度。 画一个长度为 x/3 的科赫曲线。 右转 60 度。 画一个长度为 x/3 的科赫曲线。 左转 60 度。 画一个长度为 x/3 的科赫曲线。 例外情况是 x 小于 3 的情形：此时，你只需要画一道长度为 x 的直线。
写一个名为 koch 的函数，接受一个海龟和一个长度作为形参，然后使用海龟画一条给定长度的科赫曲线。 写一个名为 snowflake 的函数，画出三条科赫曲线，构成雪花的轮廓。 科赫曲线能够以多种方式泛化。 点击此处查看例子，并实现你最喜欢的那种方式。 我的答案：
第一小题，
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 import turtle def koch(t, l): &amp;#34;&amp;#34;&amp;#34; 画出来一条科赫曲线 :param t: 一个turtle实例 :param l: 曲线长度 :return: None &amp;#34;&amp;#34;&amp;#34; if l &amp;lt; 3: t.</description></item><item><title>SQL分组过滤</title><link>https://o5o.me/post/nowcoder_sql19/</link><pubDate>Sun, 05 Feb 2023 20:50:26 +0800</pubDate><guid>https://o5o.me/post/nowcoder_sql19/</guid><description>题目：SQL19 分组过滤练习题
这一题是将行（用户、record）根据university进行分组，最后返回的不是用户的数据，而是分组（university、大学）的数据。
因此在过滤的时候，不是过滤行，而是过滤分组，所以要用having操作符，而不是where操作符。
返回的结果还应该保留三位小数，所以使用round()函数。
我的解答：
1 2 3 4 SELECT university, ROUND(AVG(question_cnt),3) as avg_question_cnt, ROUND(AVG(answer_cnt),3) as avg_answer_cnt FROM user_profile GROUP BY university HAVING avg_question_cnt &amp;lt;5 or avg_answer_cnt &amp;lt; 20</description></item><item><title>Python练习题NP47牛牛的绩点</title><link>https://o5o.me/post/nowcoder_np47/</link><pubDate>Fri, 03 Feb 2023 19:25:07 +0800</pubDate><guid>https://o5o.me/post/nowcoder_np47/</guid><description>描述 牛牛在门头沟大学学习，一学年过去了，需要根据他的成绩计算他的平均绩点，假如绩点与等级的对应关系如下表所示。请根据输入的等级和学分数，计算牛牛的均绩（每门课学分乘上单门课绩点，求和后对学分求均值）。
A 4.0 B 3.0 C 2.0 D 1.0 F 0 这一题来自牛客网，题目链接：here
输入描述： 连续输入一行等级一行学分，遇到等级为False则结束输入。
输出描述： 均绩保留两位小数。
示例1 输入： A 3 B 4 C 2 False 输出： 3.11 我的解答 最初的解答：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 d={&amp;#39;A&amp;#39;:4.0,&amp;#39;B&amp;#39;:3.0,&amp;#39;C&amp;#39;:2.0,&amp;#39;D&amp;#39;:1.0,&amp;#39;F&amp;#39;:0} b=[] c=[] i=1 while True: a = input() if a != &amp;#34;False&amp;#34; and i%2 == 1: b.</description></item><item><title>Ubuntu自建Anki同步服务</title><link>https://o5o.me/post/anki_self_hosted_sync_server_ubuntu/</link><pubDate>Tue, 31 Jan 2023 22:42:21 +0800</pubDate><guid>https://o5o.me/post/anki_self_hosted_sync_server_ubuntu/</guid><description>Anki更新2.1.57版本后，内置支持自建同步服务。之前都是需要以插件的形式实现，且搭建后往往只适用于旧版本的Anki，选择了自建同步服务就意味着放弃追求新版本和新功能。
只需要几行代码就可以搭建自己的Anki同步服务了：
screen -S anki-aoyu python3 -m venv ~/syncserver ~/syncserver/bin/pip install anki SYNC_USER1=aoyu:123456 ~/syncserver/bin/python -m anki.syncserver 我的系统版本是Ubuntu22.04，安装过程是相当顺畅的。很大概率你需要先运行apt install python3.10-venv，之后才能python3 -m venv ~/syncserver，不过你不需要提前考虑到这一点，报错后会提醒你安装的。
SYNC_USER1后面跟的是账户名和密码，在Anki里用这个账号登录。
你需要在Anki软件设置Self-hosted sync server项里填写http://服务器ip:8080/，之后就可以使用自己的同步服务了。
可以用 Nginx 做一个反代，我能想到的优点有：不让8080端口暴露到网络上；给anki的同步服务绑定一个域名，好记；可以启用https。这里就不写了，懒。
screen命令的使用可参考：SSH远程会话管理工具 - screen使用教程 - VPS侦探 (vpser.net)
安装参考：Sync Server - Anki Manual (ankiweb.net)</description></item><item><title>Leetcode 183 从不订购的客户</title><link>https://o5o.me/post/leetcode_183_customers_who_never_order/</link><pubDate>Tue, 31 Jan 2023 20:59:00 +0800</pubDate><guid>https://o5o.me/post/leetcode_183_customers_who_never_order/</guid><description>题目：183. 从不订购的客户
我的解答 1 2 3 4 5 SELECT Name AS Customers FROM Customers WHERE NOT ID IN ( SELECT CustomerId FROM Orders);</description></item><item><title>Leetcode 182 查找重复的电子邮箱</title><link>https://o5o.me/post/leetcode_182_duplicate_emails/</link><pubDate>Tue, 31 Jan 2023 20:53:00 +0800</pubDate><guid>https://o5o.me/post/leetcode_182_duplicate_emails/</guid><description>题目：182. 查找重复的电子邮箱
我的解答 1 2 3 4 5 6 7 8 # Write your MySQL query statement below SELECT name AS Employee FROM ( SELECT a.name AS name, a.salary AS mySalary, b.salary AS manaSalary FROM Employee a, Employee b WHERE a.managerId = b.id ) as b WHERE mySalary &amp;gt; manaSalary; 更好的答案：
自联结 1 2 3 4 SELECT e1.name AS Employee FROM Employee AS e1, Employee AS e2 WHERE e1.managerID = e2.</description></item><item><title>Leetcode 181 超过经理收入的员工</title><link>https://o5o.me/post/leetcode_181_employees_earning_more_than-their_managers/</link><pubDate>Tue, 31 Jan 2023 20:34:00 +0800</pubDate><guid>https://o5o.me/post/leetcode_181_employees_earning_more_than-their_managers/</guid><description>题目：181. 超过经理收入的员工
我的解答 1 2 3 4 5 6 7 8 # Write your MySQL query statement below SELECT name AS Employee FROM ( SELECT a.name AS name, a.salary AS mySalary, b.salary AS manaSalary FROM Employee a, Employee b WHERE a.managerId = b.id ) as b WHERE mySalary &amp;gt; manaSalary; 更好的答案：
自联结 1 2 3 4 SELECT e1.name AS Employee FROM Employee AS e1, Employee AS e2 WHERE e1.managerID = e2.</description></item><item><title>Leetcode 180 连续出现的数字</title><link>https://o5o.me/post/leetcode_180_consecutive_numbers/</link><pubDate>Tue, 31 Jan 2023 20:12:00 +0800</pubDate><guid>https://o5o.me/post/leetcode_180_consecutive_numbers/</guid><description>题目：180. 连续出现的数字
我的解答 使用变量
1 2 3 4 5 6 7 8 9 SELECT DISTINCT num AS ConsecutiveNums FROM ( SELECT num, (CASE WHEN @prev = num THEN @cur := @cur +1 WHEN @prev := num THEN @cur := 1 END) AS ran FROM Logs, (SELECT @prev := NULL, @cur := 0) AS r ) AS t WHERE t.ran &amp;gt;= 3</description></item><item><title>Leetcode 178 分数排名</title><link>https://o5o.me/post/leetcode_178_rank_scores/</link><pubDate>Tue, 31 Jan 2023 16:20:00 +0800</pubDate><guid>https://o5o.me/post/leetcode_178_rank_scores/</guid><description>题目：178. 分数排名
我的解答 使用了MySQL提供的函数 1 2 3 SELECT score, DENSE_RANK() OVER(ORDER BY score DESC) AS &amp;#39;rank&amp;#39; FROM Scores; 因为别名rank和rank函数冲突了，所以加个引号。
使用变量 SELECT score, CAST((CASE WHEN @prev = score THEN @curRank WHEN @prev := score THEN @curRank := @curRank +1 WHEN score = 0 THEN @curRank := @curRank + 1 END) AS SIGNED) AS &amp;#39;rank&amp;#39; FROM scores, (SELECT @curRank := 0, @prev := NULL) AS r ORDER BY score DESC; 变量prev指向的是先前一行记录里的score，变量curRank是当前这个分数的排名。
这一段的描述可能不够准确：首先查询得到每一条记录的score并按降序排序，而后，从上到下，第一个score是4.00，设为1，第二个score也是4.00，也设为1，第三个是3.85，设为1+1=2，依次类推。根据我所了解的，SQL的执行顺序中，ORDER BY是在SELECT执行之后才执行的。但是，上述过程很明显利用了排序后的结果，所以这一点我就很困惑。如果用主查询和子查询来理解，主查询执行完之后，对于返回的每一行结果再执行子查询，似乎可行，但代码中的子查询是出现在FROM后面的，而条件判断是主查询里面的。这里我依旧很困惑。</description></item><item><title>Leetcode 177 第N高的薪水</title><link>https://o5o.me/post/leetcode_177_nth_highest_salary/</link><pubDate>Sat, 28 Jan 2023 20:51:00 +0800</pubDate><guid>https://o5o.me/post/leetcode_177_nth_highest_salary/</guid><description>题目：177. 第N高的薪水
我的解答 1 2 3 4 5 6 7 8 9 10 11 12 CREATE FUNCTION getNthHighestSalary(N INT) RETURNS INT BEGIN SET N = N - 1; RETURN ( # Write your MySQL query statement below. SELECT IFNULL( (SELECT DISTINCT salary FROM Employee ORDER BY salary DESC LIMIT 1 OFFSET N),NULL) AS getNthHighestSalary ); END 在 LIMIT 和 OFFSET 内不能进行运算，所以在开头首先让N减1。
注意语句末尾的分号。
注意指定别名语句AS getNthHighestSalary末尾并没有括号。</description></item><item><title>Leetcode 176 第二高的薪水</title><link>https://o5o.me/post/leetcode_176_second_highest_salary/</link><pubDate>Sat, 28 Jan 2023 20:23:00 +0800</pubDate><guid>https://o5o.me/post/leetcode_176_second_highest_salary/</guid><description>题目：176. 第二高的薪水
我的解答 下面这个最初的解答被判定为错，乐扣没显示是哪些测试用例错了，所以也没办法改进。
1 2 3 4 5 6 7 # Write your MySQL query statement below SELECT MAX(salary) AS SecondHignestSalary FROM Employee WHERE salary &amp;lt; ( SELECT MAX(salary) FROM Employee ); 下面这个解答是成功通过的：
1 2 3 4 5 SELECT IFNULL( (SELECT DISTINCT salary FROM Employee ORDER BY salary DESC LIMIT 1 OFFSET 1),NULL) AS SecondHighestSalary; DISTINCT参数用于让查询结果中相同的值只出现一次。
DESC关键字用于让查询结果按降序进行排序。
IFNULL()函数用于判断第一个表达式是否为 NULL，如果为 NULL 则返回第二个参数的值。
LIMIT 和 OFFSET 用于对查询结果进行分页，每次返回查询结果的一部分。</description></item><item><title>Leetcode 175 组合两个表</title><link>https://o5o.me/post/leetcode_175_combine_two_tables/</link><pubDate>Sat, 28 Jan 2023 19:48:52 +0800</pubDate><guid>https://o5o.me/post/leetcode_175_combine_two_tables/</guid><description>题目：175. 组合两个表
我的解答 1 2 3 # Write your MySQL query statement below SELECT FirstName AS firstName, LastName AS lastName, City AS city, State AS state From Person LEFT OUTER JOIN Address ON Person.PersonId = Address.PersonId;</description></item><item><title>Supermemo出现弹窗Which interval do you want to use?</title><link>https://o5o.me/post/supermemo_which_interval_do_you_want_to_use/</link><pubDate>Fri, 27 Jan 2023 21:56:22 +0800</pubDate><guid>https://o5o.me/post/supermemo_which_interval_do_you_want_to_use/</guid><description>我日常用于复习的 SuperMemo 是中文懒人包版本，前几天打算学 AdvEng2018 牌组，担心合并牌组时导致文件损坏，所以就又用了另一个SM软件来单独学AdvEng2018，同时也想是用用英文SM，汉化版软件里有些翻译的中文选项我不理解，可以对照着看。
复习时经常出现一个对话框：Which interval do you want to use?
用SM的懒人包版本复习时则没这个弹窗。
出现这个弹窗的原因是，软件想告诉你，按照默认的算法，下次安排这张卡片的复习要到几十天之后了，这个时间间隔太长了，问你要不要换个时间间隔短一点的算法。
让它不显示的办法：默认是，如果一张卡片的复习间隔超过14天就会显示这个弹窗，我们把这个天数调大一些就好了。
流程：Toolkit - Options -&amp;gt; Learning - Algorithm SM-18 Alerts - Interval [days]，默认是14，改大一点，例如改为3000.
参考：Which interval do you want to use - SuperMemopedia</description></item><item><title>Python报错libGL error: failed to load driver</title><link>https://o5o.me/post/python_libgl_error_driver_iris_swrast/</link><pubDate>Thu, 26 Jan 2023 17:34:57 +0800</pubDate><guid>https://o5o.me/post/python_libgl_error_driver_iris_swrast/</guid><description>运行下述代码后报错：
1 2 import pygame pygame.init() 完整报错：
libGL error: MESA-LOADER: failed to open iris: /usr/lib/dri/iris_dri.so: cannot open shared object file: No such file or directory (search paths /usr/lib/x86_64-linux-gnu/dri:\$${ORIGIN}/dri:/usr/lib/dri, suffix _dri) libGL error: failed to load driver: iris libGL error: MESA-LOADER: failed to open swrast: /usr/lib/dri/swrast_dri.so: cannot open shared object file: No such file or directory (search paths /usr/lib/x86_64-linux-gnu/dri:\$${ORIGIN}/dri:/usr/lib/dri, suffix _dri) libGL error: failed to load driver: swrast X Error of failed request: BadValue (integer parameter out of range for operation) Major opcode of failed request: 149 (GLX) Minor opcode of failed request: 3 (X_GLXCreateContext) Value in failed request: 0x0 Serial number of failed request: 101 Current serial number in output stream: 102 提示在/usr/lib/dri/找不到iris和swrast驱动。而在/usr/lib/x86_64-linux-gnu/dri这个目录下，两个驱动都有。</description></item><item><title>Pycharm内搜狗输入法候选框不跟随光标</title><link>https://o5o.me/post/pycharm_fcitx_sogou_not_follow_cursor/</link><pubDate>Thu, 26 Jan 2023 14:09:58 +0800</pubDate><guid>https://o5o.me/post/pycharm_fcitx_sogou_not_follow_cursor/</guid><description>搜狗输入法基于fcitx。所有的JetBrains的IDE对所有的fcitx输入法都有这个问题。
解决方法，从这里下载文件直接替换PyCharm安装路径里的jbr目录（我的在/opt/pycharm-community-2022.3.1/jbr/）。
经测试有效。不过候选框会出现在光标的上方，而不是光标下方，还行，能用。</description></item><item><title>Supermemo将内容导入到了错误的概念组怎么办</title><link>https://o5o.me/post/supermemo_wrong_branch/</link><pubDate>Tue, 24 Jan 2023 20:35:21 +0800</pubDate><guid>https://o5o.me/post/supermemo_wrong_branch/</guid><description>首先在目录树（Alt+C）中移动卡片分支到正确的概念组下面。
接下来设定Reference信息中的“Concept group”为正确信息：
在卡片分支上点鼠标右键，“处理选中分支”，“设置概念分组”，在弹出的窗口中，在窗口左侧给正确的概念组打对钩，在窗口下方那一排按钮中点击“确定”。
完成。</description></item><item><title>Pycharm和Ubuntu快捷键冲突解决</title><link>https://o5o.me/post/pycharm_ubuntu_shortcut_conflict/</link><pubDate>Tue, 24 Jan 2023 18:56:00 +0800</pubDate><guid>https://o5o.me/post/pycharm_ubuntu_shortcut_conflict/</guid><description>在PyCharm中，快捷键Ctrl+Alt+T的作用是“环绕方式&amp;hellip;，使用一些模板代码环绕所选代码段”。
而在Ubuntu中，快捷键Ctrl+Alt+T的作用是“打开终端”。
解决冲突的方式是修改二者其中之一的快捷键。
修改PyCharm的这一个快捷键：文件-设置-&amp;gt;按键映射-搜索“环绕”-在快捷键那一项上点鼠标右键-移除Ctrl+Alt+T-添加键盘快捷键。
修改Ubuntu（22.10）的这一个快捷键：设置-&amp;gt;键盘-&amp;gt;键盘快捷键-查看及自定义快捷键-&amp;gt;在搜索框中搜索“ctrl+”找到快捷键“Ctrl+Alt+T”-在那一项上面单击鼠标左键-在键盘上输入以设定新快捷键。
我的选择是修改Ubuntu的这一个快捷键，因为我截止目前还没养成用快捷键打开终端的习惯。</description></item><item><title>Supermemo学习某分支下的新卡片</title><link>https://o5o.me/post/supermemo_learn_new_elements_that_belong_to_a_given_branch/</link><pubDate>Tue, 24 Jan 2023 00:03:13 +0800</pubDate><guid>https://o5o.me/post/supermemo_learn_new_elements_that_belong_to_a_given_branch/</guid><description>标题中的“新卡片”指的是在SuperMemo的“目录窗口（Contents Window）”中被标记为“浅蓝色”的卡片。
我想要学习 Advanced English 2018 牌组包里的“Grammar”分支下的卡片，这个牌组包里的“新卡片”非常非常多，有几万张，包含单词、语法、发音、拼写等等，如果按默认复习队列一锅粥地学，很不系统，因此我才想着先学Grammar语法部分。
一番尝试及朋友推荐，得到下面几种实现的方法。方法1就不推荐了，方法2和方法3按需取用。我选择的是方法2。
方法1 一番尝试及在朋友帮助下，目前找到的可行的方法是将“新卡片”（浅蓝色）变为“已记”（问答卡片，深蓝色）。
操作过程：打开“目录窗口”（Alt+C） -&amp;gt; 展开至想要学习的分支 -&amp;gt; 在那个分支标题上点鼠标右键 -&amp;gt; “处理选中分支（Process branch）” -&amp;gt; “已记（）”。在弹出的新窗口中（Which interval should be chosen in scheduling）选~~“One day interval”，那个分支下的卡片就会在一天内出现~~（我这里的理解可能是错误的）。
总结：把未学的卡片设置为已学过的卡片，进入复习队列。
方法2 由于我想要学的AdvEng2018是一个单独的kno文件，我把想要学的部分卡片从里面导出到另一个kno文件（我日常学习用的）里面，那也就实现了本文标题所称的效果。
操作过程：打开“目录窗口”（Alt+C） -&amp;gt; 展开至想要学习的分支 -&amp;gt; 在那个分支标题上点鼠标右键 -&amp;gt; “导出（export）” -&amp;gt; “Transfer elements Shift+Ctrl+T” -&amp;gt; 在弹出的窗口中选想要导入的那个kno文件 -&amp;gt; 问你 Do you want to transfer elements? 选yes -&amp;gt; 问你 Do you want to integrate all files with the target file system? 选yes。这样就导入成功了。
总结：把某一个“牌组”下的部分卡片导入到另一个“牌组”当中。
方法3 思路：SuperMemo的作用是给一张张卡片排序形成“队列”，按排定的顺序将卡片推送给用户进行学习。那么我们只要将某一分支下的卡片的顺序调整到“队列”前面，就达到了学习某一分支下的卡片的目的。</description></item><item><title>在Pycharm的代码编辑区显示一条竖线提醒换行</title><link>https://o5o.me/post/pycharm_pep8_code_editor_vertical_line/</link><pubDate>Sun, 22 Jan 2023 17:52:23 +0800</pubDate><guid>https://o5o.me/post/pycharm_pep8_code_editor_vertical_line/</guid><description>在PyCharm的代码编辑区域显示一条竖线，提醒自己每行的代码尽量不要超过80字符。这是PEP8中有关行长的指南。
文件-设置-&amp;gt;编辑器-代码样式-&amp;gt;常规-“视觉参考线”，设为80, 120，然后保存。在编辑代码时，右侧就会显示两条竖线，一个在第80个字符的位置，一个在第120个字符的位置。
可以勾选“强制换行位置”（默认为120字符）后的“键入时换行”，这样，当行长到达120字符时就会强制换行。</description></item><item><title>Python Crash Course 4</title><link>https://o5o.me/post/python_crash_course_4/</link><pubDate>Sun, 22 Jan 2023 16:32:01 +0800</pubDate><guid>https://o5o.me/post/python_crash_course_4/</guid><description>主要是练习列表解析式。以下练习均使用列表解析式完成。
练习4.3 数到20，使用一个for循环打印数1~20（含）。
1 print([value for value in range(1,21)]) 练习4.4 一百万
创建一个包含数 1～1 000 000 的列表，再使用一个 for 循环将这些数打印出来。（如果输出的时间太长，按 Ctrl + C 停止输出或关闭输出窗口。）
print([value for value in range(1,1_000_001)]) 不要尝试去运行上面的代码，能理解即可。
练习4.5 一百万求和
创建一个包含数 1～1 000 000的列表，再使用 min()和 max() 核实该列表确实是从 1 开始、到 1 000 000 结束的。另外，对这个列表调用函数 sum()， 看看 Python 将一百万个数相加需要多长时间。
1 2 3 4 list1 = [i for i in range(1,1_000_001)] print(min(list1)) print(max(list1)) print(sum(list1)) 练习4.6 奇数
通过给函数 range() 指定第三个参数来创建一个列表，其中包含 1～20 的奇数，再使用一个 for 循环将这些数打印出来。</description></item><item><title>本地运行hugo server时页面空白</title><link>https://o5o.me/post/hugo_server_localhost_page_empty/</link><pubDate>Wed, 18 Jan 2023 20:16:57 +0800</pubDate><guid>https://o5o.me/post/hugo_server_localhost_page_empty/</guid><description>我今天新装了ubuntu，把hugo博客仓库clone到本地，运行hugo server后，终端里显示貌似一切正常，但打开http://localhost:1313却是一片空白。
原因是我只把博客内容克隆了下来，但子模块却忘记了克隆。
补救措施：在仓库里运行git submodule update --init即可。
由于我本地的public目录还是空的，所以我需要运行hugo server --disableFastRender，然后就一切正常了。
参考：Git 工具 - 子模块</description></item><item><title>PyCharm创建conda项目时提示CondaError: Unable to create prefix directory</title><link>https://o5o.me/post/pycharm_condaerror_anaconda/</link><pubDate>Wed, 18 Jan 2023 20:00:35 +0800</pubDate><guid>https://o5o.me/post/pycharm_condaerror_anaconda/</guid><description>原因是我没有把anaconda安装在默认位置（/home目录里），而是装在了/opt目录里，我以普通用户的身份运行PyCharm，没有权限访问/opt目录，所以有了这个错误提示。
解决办法：在/home/用户目录里我建了一个文件夹来放conda环境。</description></item><item><title>AttributeError: object has no attribute</title><link>https://o5o.me/post/python_attributeerror_object_has_no_attribute/</link><pubDate>Tue, 17 Jan 2023 13:50:22 +0800</pubDate><guid>https://o5o.me/post/python_attributeerror_object_has_no_attribute/</guid><description>今天写的程序运行时提示：AttributeError: 'BaiduImageSpider' object has no attribute 'url'，让我百思不得其解。
最后发现是我把__init__写成了__int__，DeBug也没发现这个错误。</description></item><item><title>Chrome网页源代码自动换行</title><link>https://o5o.me/post/chrome_view_source/</link><pubDate>Fri, 13 Jan 2023 22:09:41 +0800</pubDate><guid>https://o5o.me/post/chrome_view_source/</guid><description>我觉得我遇到了 Baader-Meinhof 现象1。
今天在写爬虫的时候，突然想到，如果Chrome的网页源代码页面的代码能自动换行就好了。我就去网上搜有没有方法能让源代码自动换行显示。
一番搜寻没有结果，然后我就打算放弃，然后我不经意往一个已经打开的网页源代码页面一瞟，赫然有一个“自动换行”复选框静静显示在那里。
天地良心，我以前真的是没有注意到过那里还有那么一个按钮，而现在它却那么显眼。
Frequency illusion - Wikipedia&amp;#160;&amp;#x21a9;&amp;#xfe0e;</description></item><item><title>爬虫运行报错：UnicodeEncodeError: 'latin-1' codec can't encode characters</title><link>https://o5o.me/post/spider_unicodeencodeerror_latin-1/</link><pubDate>Fri, 13 Jan 2023 13:58:29 +0800</pubDate><guid>https://o5o.me/post/spider_unicodeencodeerror_latin-1/</guid><description>写了一个简单的爬虫程序，从百度图片下载图片，但运行时报错：UnicodeEncodeError: 'latin-1' codec can't encode characters in position 41-44: ordinal not in range(256)
程序反反复复检查了好几遍，最终确定是cookie的问题。
我是从自己的 Chrome 浏览器里直接拷贝的cookie值粘贴到程序里的，没注意从Chrome直接复制的cookie会先解码再给你。就是说，程序里需要的cookie是不带中文的（中文先进行编码，比如把古力娜扎编码为%E5%8F%A4%E5%8A%9B%E5%A8%9C%E6%89%8E），但从Chrome复制出来的cookie带中文。
Chrome这是好心办坏事吗。</description></item><item><title>Think Python Exercise 3.3</title><link>https://o5o.me/post/think_python_exercise_3.3/</link><pubDate>Tue, 10 Jan 2023 21:42:59 +0800</pubDate><guid>https://o5o.me/post/think_python_exercise_3.3/</guid><description>注意:请使用我们目前学过的语句和特性来完成本题。
编写一个能画出如下网格 (grid) 的函数: + - - - - + - - - - + | | | | | | | | | | | | + - - - - + - - - - + | | | | | | | | | | | | + - - - - + - - - - + 提示:你可以使用一个用逗号分隔的值序列,在一行中打印出多个值:
print(&amp;#39;+&amp;#39;, &amp;#39;−&amp;#39;) print 函数默认会自动换行,但是你可以阻止这个行为,只需要像下面这样将行结尾变成一个空格:
print(&amp;#39;+&amp;#39;, end=&amp;#39; &amp;#39;) print(&amp;#39;−&amp;#39;) 这两个语句的输出结果是+ −。</description></item><item><title>Think Python Exercise 3.2</title><link>https://o5o.me/post/think_python_exercise_3.2/</link><pubDate>Tue, 10 Jan 2023 21:30:47 +0800</pubDate><guid>https://o5o.me/post/think_python_exercise_3.2/</guid><description>函数对象是一个可以赋值给变量的值, 也可以作为实参传递。 例如, do_twice 函数接受函数对象作为实参,并调用这个函数对象两次:
def do_twice(f): f() f() 下面这个示例使用 do_twice 来调用名为 print_spam 的函数两次。
def print_spam (): print(&amp;#39;spam &amp;#39;) do_twice(print_spam) 将这个示例写入脚本,并测试。 修改do_twice,使其接受两个实参,一个是函数对象,另一个是值。然后调用这一函数对象两次,将那个值传递给函数对象作为实参。 从本章前面一些的示例中, 将 print_twice 函数的定义复制到脚本中。 使用修改过的 do_twice ,调用print_twice 两次,将 spam 传递给它作为实参。 定义一个名为 do_four 的新函数,其接受一个函数对象和一个值作为实参。调用这个函数对象四次,将那个值作为形参传递给它。函数体中应该只有两条语句,而不是四条。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 def do_twice(f, argus): f(argus) f(argus) def print_twice(bruce): print(bruce) print(bruce) def do_four(f, argus): do_twice(f, argus) do_twice(f, argus) do_twice(print_twice, &amp;#39;spam&amp;#39;) #do_four(print_twice, &amp;#34;spam&amp;#34;)</description></item><item><title>Think Python Exercise 3.1</title><link>https://o5o.me/post/think_python_exercise_3.1/</link><pubDate>Tue, 10 Jan 2023 21:23:43 +0800</pubDate><guid>https://o5o.me/post/think_python_exercise_3.1/</guid><description>编写一个名为 right_justify 的函数, 函数接受一个名为 s 的字符串作为形参, 并在打印足够多的前导空格 (leading space) 之后打印这个字符串,使得字符串的最后一个字母位于显示屏的第 70 列。
提示: 使用字符串拼接 (string concatenation) 和重复。 另外, Python 提供了一个名叫len 的内建函数,可以返回一个字符串的长度,因此len(&amp;lsquo;allen&amp;rsquo;) 的值是 5。
1 2 3 4 5 6 7 def right_justify(s): print(&amp;#39; &amp;#39;*(70-len(s)),s) s1 = &amp;#34;good morning&amp;#34; s2 = &amp;#34;nice to meet you&amp;#34; right_justify(s1) right_justify(s2)</description></item><item><title>Think Python Exercise 17.2</title><link>https://o5o.me/post/think_python_exercise_17.2/</link><pubDate>Tue, 10 Jan 2023 16:15:37 +0800</pubDate><guid>https://o5o.me/post/think_python_exercise_17.2/</guid><description>这道习题中包含了 Python 中最常见、最难找出来的错误。编写一个叫 Kangaroo 的类,包含以下方法:
一个__init__ 方法,初始化一个叫 pounch_contents 的属性为空列表。 一个叫put_in_pounch 的方法,将一个任意类型的对象加入pounch_contents。 一个__str__ 方法,返回 Kangaroo 对象的字符串表示和 pounch 中的内容。 创建两个 Kangaroo 对象, 将它们命名为 kanga 和 roo , 然后将 roo 加入 kanga 的 pounch 列表, 以此测试你写的代码。
这是我在不完全理解题目时写的代码（请不要参考）：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Kangaroo: def __init__(self): self.pounch_contents = [] def put_in_pounch(self, ayobj): self.pounch_contents.append(ayobj) def __str__(self): return str(self.pounch_contents) kanga = Kangaroo() roo = Kangaroo() kanga.put_in_pounch(roo) print(kanga) 其实这是一个找bug的练习。作者想让我们使用pylint这个工具找出他的代码里的bug。</description></item><item><title>Think Python Exercise 17.0</title><link>https://o5o.me/post/think_python_exercise_17.0/</link><pubDate>Tue, 10 Jan 2023 12:51:08 +0800</pubDate><guid>https://o5o.me/post/think_python_exercise_17.0/</guid><description>我们做个练习, 将 time_to_int (见 16.4 节) 重写为方法。你或许也想将 int_to_time 改写为方法,但是那样做并没有什么意义,因为没有调用它的对象。
原 int_to_time 函数见练习16.0。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Time: &amp;#34;&amp;#34;&amp;#34;Represents the time of day.&amp;#34;&amp;#34;&amp;#34; def print_time(self): print(&amp;#34;%.2d:%.2d:%.2d&amp;#34; % (self.hour, self.minute, self.second)) def time_to_int(self): minutes = self.hour * 60 + self.minute seconds = minutes * 60 + self.second return seconds start = Time() start.hour = 9 start.minute = 45 start.second = 20 start.</description></item><item><title>Think Python Exercise 17.1</title><link>https://o5o.me/post/think_python_exercise_17.1/</link><pubDate>Tue, 10 Jan 2023 12:44:03 +0800</pubDate><guid>https://o5o.me/post/think_python_exercise_17.1/</guid><description>修改 Time 类的属性, 使用一个整数代表自午夜零点开始的秒数。然后修改类的方法 (和int_to_time 函数),使其适用于新的实现。你不用修改 main 函数中的测试代码。完成之后, 程序的输出应该和之前保持一致。
分析：作者的意思是，Time 类的属性，修改后只有“秒”这一个（小时、分钟都没了），同时，修改后Time类接收的参数和返回的值都保持不变。
作者提供的用于修改的代码：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 &amp;#34;&amp;#34;&amp;#34;This module contains a code example related to Think Python, 2nd Edition by Allen Downey http://thinkpython2.</description></item><item><title>Think Python Exercise 16.2</title><link>https://o5o.me/post/think_python_exercise_16.2/</link><pubDate>Tue, 10 Jan 2023 10:23:15 +0800</pubDate><guid>https://o5o.me/post/think_python_exercise_16.2/</guid><description>datetime 模块提供的 time 对象,和本章的 Time 对象类似, 但前者提供了更丰富的方法和操作符。
使用 datetime 模块来编写一个程序,获取当前日期并打印当天是周几。 编写一个程序,接受一个生日作为输入,并打印用户的年龄以及距离下个生日所需要的天数、小时数、分钟数和秒数。 对于两个不在同一天出生的人来说,总有一天,一个人的出生天数是另一个人的两倍。我们把这一天称为 ‘‘双倍日’’。编写一个程序,接受两个不同的出生日期, 并计算他们的 ‘‘双倍日’’。 再增加点挑战,编写一个更通用的版本,用于计算一个人出生天数是另一个人 n 倍的日子。 题1
1 2 3 4 5 6 7 from datetime import date today = date.today() #print(dir(today)) #打印属性、方法列表 print(&amp;#34;今天是星期%d.&amp;#34; % (today.weekday()+1)) # weekday返回的值是从0开始的，所以+1 题2
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 from datetime import datetime def days_until_birthday(birthday): &amp;#34;&amp;#34;&amp;#34;距离下一次生日还有多长时间&amp;#34;&amp;#34;&amp;#34; today = datetime.</description></item><item><title>Think Python Exercise 16.1</title><link>https://o5o.me/post/think_python_exercise_16.1/</link><pubDate>Tue, 10 Jan 2023 10:10:48 +0800</pubDate><guid>https://o5o.me/post/think_python_exercise_16.1/</guid><description>写一个叫做 mul_time 的函数,接收一个 Time 对象和一个数,并返回一个新的 Time 对象,包含原始时间和数的乘积。
然后使用 mul_time 编写一个函数,接受一个表示比赛完赛时间的 Time 对象以及一个表示距离的数字,并返回一个用于表示平均配速 (每英里所需时间) 的 Time 对象。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class Time: &amp;#34;&amp;#34;&amp;#34;用于记录时间 属性：hour, minute, second &amp;#34;&amp;#34;&amp;#34; def print_time(ti): print(&amp;#34;%.2d:%.2d:%.2d&amp;#34; % (ti.hour,ti.minute,ti.second)) #记得加括号 def time_to_int(time): minutes = time.hour * 60 + time.minute seconds = minutes * 60 + time.</description></item><item><title>Think Python Exercise 16.1</title><link>https://o5o.me/post/think_python_exercise_16.0/</link><pubDate>Mon, 09 Jan 2023 16:59:37 +0800</pubDate><guid>https://o5o.me/post/think_python_exercise_16.0/</guid><description>编写一个叫做 print_time 的函数,接收一个 Time 对象并用 时:分:秒 的格式打印它。提示: 格式化序列 %.2d 可以至少两位数的形式打印一个整数,如果不足则在前面补 0。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Time: &amp;#34;&amp;#34;&amp;#34;用于记录时间 属性：hour, minute, second &amp;#34;&amp;#34;&amp;#34; def print_time(ti): print(&amp;#34;%.2d:%.2d:%.2d&amp;#34; % (ti.hour,ti.minute,ti.second)) #记得加括号 time1 = Time() time1.hour = 11 time1.minute = 59 time1.second = 30 print_time(time1) 编写一个叫做 is_after 的布尔函数,接收两个 Time 对象,t1 和 t2 ,若 t1 的时间在 t2 之后,则返回 True ,否则返回 False。挑战:不要使用 if 语句。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Time: &amp;#34;&amp;#34;&amp;#34;用于记录时间 属性：hour, minute, second &amp;#34;&amp;#34;&amp;#34; def print_time(ti): print(&amp;#34;%.</description></item><item><title>Think Python Exercise 15.2</title><link>https://o5o.me/post/think_python_exercise_15.2/</link><pubDate>Mon, 09 Jan 2023 16:11:59 +0800</pubDate><guid>https://o5o.me/post/think_python_exercise_15.2/</guid><description>编写一个名为 draw_rect 的函数,该函数接受一个 Turtle 对象和一个 Rectangle 对象,使用Turtle 画出该矩形。参考第 四 章中使用 Turtle 的示例。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 import turtle class Point: &amp;#34;&amp;#34;&amp;#34;表示一个二维的点 &amp;#34;&amp;#34;&amp;#34; class Rectangle: &amp;#34;&amp;#34;&amp;#34;Represents a rectangle. attributes: width, height, corner.&amp;#34;&amp;#34;&amp;#34; def draw_rect(t,rect): t.pu() #在移动到矩形左下角的过程中，不画出痕迹（提笔，put up） t.goto(rect.corner.x, rect.corner.y) t.pd() #落笔（put down） for i in range(2): t.</description></item><item><title>Think Python Exercise 15.1</title><link>https://o5o.me/post/think_python_exercise_15.1/</link><pubDate>Wed, 04 Jan 2023 21:30:00 +0800</pubDate><guid>https://o5o.me/post/think_python_exercise_15.1/</guid><description>15.1.1 定义一个叫做Circle类, 类的属性是圆心 (center) 和半径 (radius), 其中, 圆心 (center) 是一个 Point 类,而半径 (radius) 是一个数字。
实例化一个圆心 (center) 为 (150, 100) ,半径 (radius) 为 75 的Circle 对象。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Circle: &amp;#34;&amp;#34;&amp;#34;属性：圆心center、半径radius 圆心是一个Point类 半径是一个数字 &amp;#34;&amp;#34;&amp;#34; class Point: &amp;#34;&amp;#34;&amp;#34;表示一个二维的点 &amp;#34;&amp;#34;&amp;#34; bob = Circle() bob.center = Point() bob.center.x = 150 bob.center.y = 100 bob.radius = 75 15.1.2 编写一个名称为point_in_circle的函数,该函数可以接受一个圆类 (Circle) 对象和点类 (Point) 对象, 然后判断该点是否在圆内。在圆内则返回True 。</description></item><item><title>Think Python Exercise 15.0</title><link>https://o5o.me/post/think_python_exercise_15.0/</link><pubDate>Wed, 04 Jan 2023 12:25:00 +0800</pubDate><guid>https://o5o.me/post/think_python_exercise_15.0/</guid><description>编写一个叫做distance_between_points的函数，它接受两个Point作为参数，然后返回这两个点之间的距离。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 import math class Point: &amp;#34;&amp;#34;&amp;#34;表示一个二维的点 &amp;#34;&amp;#34;&amp;#34; def distance_between_points(p1,p2): return math.sqrt((p1.x - p2.x)**2+(p1.y - p2.y)**2) Po1 = Point() Po2 = Point() Po1.x = 5 Po1.y = 3 Po2.x = 6 Po2.y = 2 distance_between_points(Po1,Po2) 编写一个叫做move_rectangle的函数，接受一个Rectangle以及两个数字dx和dy。它把corner的x坐标加上dx，把corner的y坐标加上dy，从而改变矩形的位置。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 def print_point(p): print(&amp;#39;(%g, %g)&amp;#39; % (p.</description></item><item><title>Think Python Exercise 11.3 阿克曼函数</title><link>https://o5o.me/post/think_python_exercise_11.3_ackermann/</link><pubDate>Tue, 03 Jan 2023 22:39:00 +0800</pubDate><guid>https://o5o.me/post/think_python_exercise_11.3_ackermann/</guid><description>将 习题6.2 中的 Ackermann 函数备忘录化(memoize), 看看备忘录化(memoization)是否可以支持解决更大的参数。没有提示!
储存之前计算过的值以便今后使用，这个操作就称为备忘录化。
做这道题首先要理解书上关于斐波那契数列的例子。
计算斐波那契数列的代码：
1 2 3 4 5 6 7 def fibonacci(n): if n == 0: return 0 elif n == 1: return 1 else: return fibonacci(n-1) + fibonacci(n-2) 备忘录化后的代码：
1 2 3 4 5 6 7 8 9 known = {0:0, 1:1} def fibonacci(n): if n in known: return known[n] res = fibonacci(n-1) + fibonacci(n-2) known[n] = res return res 按照同样的思路，我们可以把计算的ack函数的值储存到字典里，后面再计算时先看之前是不是曾计算过，如果计算过，直接调用已有结果即可。
原ack函数代码：
1 2 3 4 5 6 7 8 def ackermann(m,n): #来自6.</description></item><item><title>Think Python Exercise 6.2 阿克曼函数</title><link>https://o5o.me/post/think_python_exercise_6.2_ackermann/</link><pubDate>Tue, 03 Jan 2023 21:25:57 +0800</pubDate><guid>https://o5o.me/post/think_python_exercise_6.2_ackermann/</guid><description>Ackermann 函数 $A(m, n)$ 的定义如下:
$$ A(m, n)=\left{\begin{array}{ll} n+1 &amp;amp; \text { if } m=0 \ A(m-1,1) &amp;amp; \text { if } m&amp;gt;0 \text { and } n=0 \ A(m-1, A(m, n-1)) &amp;amp; \text { if } m&amp;gt;0 \text { and } n&amp;gt;0 \end{array}\right. $$
查看维基百科的定义, 编写一个叫作ack的函数来计算 Ackermann 函数。使用你的函 数计算ack(3,4), 其结果应该为 125 。如果 $m$ 和 $n$ 的值较大时, 会发生什么?
拙见：
1 2 3 4 5 6 7 8 9 def ack(m,n): if m == 0: return n+1 elif m &amp;gt; 0 and n == 0: return ack(m-1,1) elif m &amp;gt; 0 and n &amp;gt; 0: return ack(m-1,ack(m,n-1)) ack(3,4) 似乎看上去平平无奇，把它的计算过程展示出来：</description></item><item><title>Think Python Exercise 6.1</title><link>https://o5o.me/post/think_python_exercise_6.1/</link><pubDate>Tue, 03 Jan 2023 21:05:57 +0800</pubDate><guid>https://o5o.me/post/think_python_exercise_6.1/</guid><description>画出下面程序的堆栈图。这个程序的最终输出是什么?
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 def b(z): prod = a(z, z) print(z, prod) return prod def a(x, y): x = x + 1 return x * y def c(x, y, z): total = x + y + z square = b(total)**2 return square x = 1 y = x + 1 print(c(x, y+3, x+y)) 程序的最终输出：8100
应该没有特别的意义吧？</description></item><item><title>Think Python Exercise 11.2 字典方法setdefault</title><link>https://o5o.me/post/think_python_exercise_11.2/</link><pubDate>Tue, 03 Jan 2023 18:28:00 +0800</pubDate><guid>https://o5o.me/post/think_python_exercise_11.2/</guid><description>查看字典方法setdefault的文档, 并使用该方法写一个更简洁的invert_dict。
原来的函数的定义：
1 2 3 4 5 6 7 8 9 10 11 def invert_dict(d): &amp;#34;&amp;#34;&amp;#34;倒转一个字典，将原字典的值作为键，原字典的键作为值。 &amp;#34;&amp;#34;&amp;#34; inverse = dict() for key in d: val = d[key] if val not in inverse: inverse[val] = [key] #反转后，一个键可能对应多个值，所以把值放到列表里 else: inverse[val].append(key) #相当于给列表追加一个值。键val的值是一个列表。 return inverse 文档链接：这里
setdefault(key[, default]), 如果字典存在键 key ，返回它的值。如果不存在，插入值为 default 的键 key ，并返回 default 。 default 默认为 None。
1 2 3 4 5 6 7 8 9 10 def invert_dict(d): &amp;#34;&amp;#34;&amp;#34;倒转一个字典，将原字典的值作为键，原字典的键作为值。 &amp;#34;&amp;#34;&amp;#34; inverse = dict() for key in d: inverse[d[key]]=inverse.</description></item><item><title>Think Python Exercise 11.1</title><link>https://o5o.me/post/think_python_exercise_11.1/</link><pubDate>Tue, 03 Jan 2023 18:12:23 +0800</pubDate><guid>https://o5o.me/post/think_python_exercise_11.1/</guid><description>编写一函数,读取words.txt中的单词并存储为字典中的键。值是什么无所谓。然后,你可以使用in操作符检查一个字符串是否在字典中。
如果你做过练习 10.10 ,可以比较一下in操作符和二分查找的速度。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 def make_word_list(): word_list = [] fin = open(&amp;#39;words.txt&amp;#39;) for line in fin: word = line.strip() word_list.append(word) return word_list def dictword(w_li): word_dict = dict() for word in w_li: word_dict[word] = &amp;#39;ok&amp;#39; #题目说值是什么无所谓 return word_dict word_list = make_word_list() word_dict = dictword(word_list) &amp;#39;aha&amp;#39; in word_dict 我就不比较in操作符和二分查找的速度了。</description></item><item><title>Think Python Exercise 10.11</title><link>https://o5o.me/post/think_python_exercise_10.11/</link><pubDate>Mon, 02 Jan 2023 23:14:23 +0800</pubDate><guid>https://o5o.me/post/think_python_exercise_10.11/</guid><description>两个单词中如果一个是另一个的反转, 则二者被称为是 ‘‘反转词对’’。 编写一个函数,找出单词表中所有的反转词对。
解答：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 def read_word1(file_in): #来自10.9 word_list = [] for line in file_in: word = line.strip() word_list.append(word) return word_list def in_bisect(t,a): #来自10.10 &amp;#34;&amp;#34;&amp;#34;列表t，单词a，看单词是否在列表内，在的话返回单词的位置。 列表里的单词，必须是已经按字母顺序排好序的。 &amp;#34;&amp;#34;&amp;#34; s1 = int((len(t))/2) s = s1 #如果a在t内，s保存a的序数 while s1 &amp;gt; 0: if a == t[s1]: return s elif a &amp;gt; t[s1]: t = t[s1:] s1 = int(len(t)/2) #在循环过程中，确保s和s1所指的是同一个元素。 #print(a,&amp;#34;的位置大于&amp;#34;,s) s += s1 else: t = t[:s1] s1 = int(len(t)/2) #print(a,&amp;#34;的位置小于等于&amp;#34;,s) s -= s1 return None def findpairs(word_li): i = 0 for word in word_li: drow = word[::-1] #将单词里的字母按照相反的顺序排列 k = in_bisect(word_li[i:],drow) #写word_list[i:]目的是不让程序往前去找所谓的“反转词” if k: print(word,&amp;#39;和&amp;#39;,word_li[k+i]) i += 1 fin = open(&amp;#39;words.</description></item><item><title>Think Python Exercise 10.10 二分法</title><link>https://o5o.me/post/think_python_exercise_10.10/</link><pubDate>Mon, 02 Jan 2023 21:29:30 +0800</pubDate><guid>https://o5o.me/post/think_python_exercise_10.10/</guid><description>使用in运算符可以检查一个单词是否在单词表中, 但这很慢, 因为它是按顺序查找单词。
由于单词是按照字母顺序排序的,我们可以使用两分法 (也称二叉树搜索) 来加快速度, 类似于在字典中查找单词的方法。你从中间开始,如果你要找的单词在中间的单词之前,你查找前半部分,否则你查找后半部分。
不管怎样, 你都会将搜索范围减小一半。 如果单词表有 113,809 个单词, 你只需要 17 步就可以找到这个单词,或着得出单词不存在的结论。
编写一个叫做in_bisect的函数,接受一个已排序的列表和一个目标值作为参数,返回该值在列表中的位置,如果不存在则返回None。
或者你可以阅读bisect模块的文档并使用它!
解答：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 def in_bisect(t,a): &amp;#34;&amp;#34;&amp;#34;列表t，单词a，看单词是否在列表内，在的话返回单词的位置。 列表里的单词，必须是已经按字母顺序排好序的。 &amp;#34;&amp;#34;&amp;#34; s1 = int((len(t))/2) s = s1 #如果a在列表内，s保存a的下标 while s1 &amp;gt; 0: if a == t[s1]: return s elif a &amp;gt; t[s1]: t = t[s1:] s1 = int(len(t)/2) #在循环过程中，确保s和s1所指的是同一个元素。 #print(a,&amp;#34;的位置大于&amp;#34;,s) s += s1 else: t = t[:s1] s1 = int(len(t)/2) #print(a,&amp;#34;的位置小于等于&amp;#34;,s) s -= s1 return None t1 = [&amp;#39;a&amp;#39;,&amp;#39;b&amp;#39;,&amp;#39;c&amp;#39;,&amp;#39;d&amp;#39;,&amp;#39;e&amp;#39;,&amp;#39;f&amp;#39;,&amp;#39;g&amp;#39;,&amp;#39;h&amp;#39;,&amp;#39;i&amp;#39;,&amp;#39;j&amp;#39;,&amp;#39;k&amp;#39;,&amp;#39;l&amp;#39;,&amp;#39;m&amp;#39;,&amp;#39;n&amp;#39;,&amp;#39;o&amp;#39;,&amp;#39;p&amp;#39;,&amp;#39;q&amp;#39;] in_bisect(t1,&amp;#39;c&amp;#39;) s和s1这两个变量，保存的是列表元素的下标。在循环过程中，确保s和s1所指的是同一个元素，即：s保存的是元素在完整列表里的下标，s1保存的是元素在切片后的列表里的下标，在两个列表里，第s个元素和第s1个元素（都从0开始）是同一个元素。</description></item><item><title>Think Python Exercise 10.3</title><link>https://o5o.me/post/think_python_exercise_10.3/</link><pubDate>Mon, 02 Jan 2023 21:22:48 +0800</pubDate><guid>https://o5o.me/post/think_python_exercise_10.3/</guid><description>编写一个叫做middle的函数,接受一个列表作为参数,并返回一个除了第一个和最后一个元素的列表。例如:
&amp;gt;&amp;gt;&amp;gt; t = [1, 2, 3, 4] &amp;gt;&amp;gt;&amp;gt; middle(t) [2, 3] 解答：
1 2 3 4 5 def middle(t): return t[1:-1] t1 = [1,2,3,4] middle(t1)</description></item><item><title>Think Python Exercise 10.7</title><link>https://o5o.me/post/think_python_exercise_10.7/</link><pubDate>Mon, 02 Jan 2023 20:31:00 +0800</pubDate><guid>https://o5o.me/post/think_python_exercise_10.7/</guid><description>编写一个叫做 has_duplicates 的函数，接受一个列表作为参数，如果一个元素在列表中出现了不止一次，则返回 True 。这个函数不能改变原列表。
解答：
1 2 3 4 5 6 7 8 9 10 11 12 def has_duplicates(t): p = [] for i in t: if i not in p: p.append(i) else: return True return False t1 = [1,2,3] has_duplicates(t1)</description></item><item><title>Roam Research和Anki联用：动作配置</title><link>https://o5o.me/post/rr_km_anki_configuration_tutorial/</link><pubDate>Mon, 02 Jan 2023 01:07:10 +0800</pubDate><guid>https://o5o.me/post/rr_km_anki_configuration_tutorial/</guid><description>Roam Research是一个笔记软件，Anki是一个间隔重复软件。我在RR里写的笔记有复习需求，在Anki里的卡片有编辑、整理需求，所以以前的我就用Keyboard Maestro这个工具写了一个动作（Macro）来帮我将二者联系起来。
RR的笔记可以导出为Anki卡片（卡片仅用于复习、展示，所有的编辑都在笔记上完成），笔记更新，卡片能同步更新，笔记和卡片能相互跳转。
可以按下面的顺序进行配置（所需文件在文章最后），手把手教学请看视频：
【详细配置】Keyboard Maestro动作实现Roam Research笔记和Anki卡片的双向链接、跳转和同步更新，配置指南
Anki模板导入、修改 要改的地方就一处：修改模板里的RR graph名称。不改的话就没办法从Anki跳转回RR了。
KM动作导入、修改 要改的地方也就只有一处：把你的Anki牌组的名字填进去。
Anki插件安装 anki connect，插件代码：2055492159
禁用App Nap 从Mac OS X Mavericks开始，操作系统中引入了名为App Nap的功能。此功能导致某些打开（但不可见）的应用程序处于挂起状态。由于此行为会导致Anki Connect在前台有另一个窗口时停止工作，因此应禁用Anki的App Nap1。
在终端运行下面的命令即可。
1 2 3 defaults write net.ankiweb.dtop NSAppSleepDisabled -bool true defaults write net.ichi2.anki NSAppSleepDisabled -bool true defaults write org.qt-project.Qt.QtWebEngineCore NSAppSleepDisabled -bool true 最后 这就配置完成了，是不是很简单？quicker版的动作配置更简单，除了下载插件，啥都不用配置，自动配置。想想以前真的傻，我给quicker版的这个动作加了批量导入、多种挖空标记、多种方式排列的笔记导入、自动从Anki获取牌组列表、自动添加Anki模板等等功能，这些功能在我现在看来用途很小很小，但当时却花了大量时间去改动作、修bug，浪费了很多时间在完全没必要的事情上。
模板、动作下载链接: 百度网盘，提取码: 3tvu
希望能给看到这里的你带来一些帮助。
Notes for MacOS Users&amp;#160;&amp;#x21a9;&amp;#xfe0e;</description></item><item><title>Think Python Exercise 4.1</title><link>https://o5o.me/post/think_python_exercise_4.1/</link><pubDate>Sun, 01 Jan 2023 18:23:34 +0800</pubDate><guid>https://o5o.me/post/think_python_exercise_4.1/</guid><description>画一个执行 circle(bob,radius) 时的堆栈图（stack diagram），说明程序的各个状态。你可以手动进行计算，也可以在代码中加入打印语句。 “重构”一节中给出的 arc 函数版本并不太精确，因为圆形的线性近似（linear approximation）永远处在真正的圆形之外。因此，Turtle 总是和正确的终点相差几个像素。我的答案中展示了降低这个错误影响的一种方法。阅读其中的代码，看看你是否能够理解。如果你画一个堆栈图的话，你可能会更容易明白背后的原理。 先放上代码，得到代码过程可以看Think Python Exercise 4.0。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 import turtle import math def polyline(t,length,n,angle): for i in range(n): t.fd(length) t.lt(angle) def arc(t,r,angle): &amp;#34;&amp;#34;&amp;#34;angle取值范围是1~360，度数。 画出圆的一部分。 &amp;#34;&amp;#34;&amp;#34; arc_length = 2 * math.pi * r * angle / 360 n = int(arc_length / 3) + 1 step_length = arc_length / n step_angle = angle / n polyline(t,step_length,n,step_angle) def circle(t,r): arc(t,r,360) #circle是arc函数在角度angle取360时的特例 bob = turtle.</description></item><item><title>Think Python Exercise 4.0</title><link>https://o5o.me/post/think_python_exercise_4.0/</link><pubDate>Sun, 01 Jan 2023 16:04:43 +0800</pubDate><guid>https://o5o.me/post/think_python_exercise_4.0/</guid><description>写一个名为 square 的函数，接受一个名为 t 的形参，t 是一个海龟。这个函数应用这只海龟画一个正方形。 写一个函数调用，将 bob 作为实参传给 square ，然后再重新运行程序。
1 2 3 4 5 6 7 8 9 10 11 12 import turtle def square(t): for i in range(4): t.fd(100) t.lt(90) bob = turtle.Turtle() square(bob) turtle.mainloop() 给 square 增加另一个名为 length 的形参。修改函数体，使得正方形边的长度是 length ，然后修改函数调用，提供第二个实参。 重新运行程序。用一系列 length 值测试你的程序。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import turtle def square(t,length): for i in range(4): t.</description></item><item><title>Think Python Exercise 5.4</title><link>https://o5o.me/post/think_python_exercise_5.4/</link><pubDate>Sun, 01 Jan 2023 13:04:59 +0800</pubDate><guid>https://o5o.me/post/think_python_exercise_5.4/</guid><description>下面程序的输出是什么？画出展示程序每次打印输出时的堆栈图。
1 2 3 4 5 6 7 def recurse(n, s): if n == 0: print(s) else: recurse(n-1, n+s) recurse(3, 0) 如果你这样调用函数： recurse(-1,0) ，会有什么结果？ 请写一个文档字符串，解释调用该函数时需要了解的全部信息（仅此而已）。 解答：
我用obsidian的Excalidraw插件画了一个。
如果这样调用函数： recurse(-1,0)，Python会抛出一个递归错误：超过最大递归深度。
&amp;gt;&amp;gt;&amp;gt; recurse(-1,0) Traceback (most recent call last): File &amp;#34;&amp;lt;stdin&amp;gt;&amp;#34;, line 1, in &amp;lt;module&amp;gt; File &amp;#34;&amp;lt;stdin&amp;gt;&amp;#34;, line 5, in recurse File &amp;#34;&amp;lt;stdin&amp;gt;&amp;#34;, line 5, in recurse File &amp;#34;&amp;lt;stdin&amp;gt;&amp;#34;, line 5, in recurse [Previous line repeated 996 more times] RecursionError: maximum recursion depth exceeded 写一个文档字符串，解释调用该函数时需要了解的全部信息</description></item><item><title>正则表达式匹配HTML标签</title><link>https://o5o.me/post/regexps_match_html_tags/</link><pubDate>Sat, 31 Dec 2022 22:25:25 +0800</pubDate><guid>https://o5o.me/post/regexps_match_html_tags/</guid><description>最近在用SuperMemo渐进阅读旋元佑的《英语魔法师之语法俱乐部》这本语法书。我的阅读前流程是这样的：（括号内的是所用工具）
将epub电子书按章节分割（calibre-EpubSplit） 将需要阅读的章节导入SuperMemo（Quicker、pandoc、AutoHotkey） 在SuperMemo内将该章节分割成更小的卡片（鼠标右键-阅读-分割-分割文章） 统一将所得的所有卡片设为新材料（根卡片鼠标右键-处理选中分支-学习-忘记） 菜单栏-学习-阶段-新学材料（也可等当天复习完后根据提示进入） 问题在于，我所拥有的这本epub电子书，html标签很乱，导致我在导入SM后无法正确根据html标签分割文章，因此在导入SM前需要先整理epub文件的html标签。这也就是这篇文章的由来。
截取这本书的一个片段：
1 &amp;lt;p class=&amp;#34;calibre_16&amp;#34;&amp;gt;以上谈的是修饰动词专用的“方法、状态副词”，以及它在句中位置的变化原则。接下来看看其他种类的副词。&amp;lt;/p&amp;gt;&amp;lt;blockquote class=&amp;#34;calibre_5&amp;#34;&amp;gt;&amp;lt;blockquote class=&amp;#34;calibre2&amp;#34;&amp;gt;&amp;lt;blockquote class=&amp;#34;calibre2&amp;#34;&amp;gt;&amp;lt;blockquote class=&amp;#34;calibre2&amp;#34;&amp;gt;&amp;lt;blockquote class=&amp;#34;calibre_21&amp;#34;&amp;gt;&amp;lt;span class=&amp;#34;calibre1&amp;#34;&amp;gt;&amp;lt;span class=&amp;#34;bold&amp;#34;&amp;gt;&amp;lt;span class=&amp;#34;calibre_12&amp;#34;&amp;gt;强调语气的副词（Intensifiers)&amp;lt;/span&amp;gt;&amp;lt;/span&amp;gt;&amp;lt;/span&amp;gt;&amp;lt;/blockquote&amp;gt;&amp;lt;/blockquote&amp;gt;&amp;lt;/blockquote&amp;gt;&amp;lt;/blockquote&amp;gt;&amp;lt;a id=&amp;#34;filepos295095&amp;#34;&amp;gt;&amp;lt;/a&amp;gt;&amp;lt;/blockquote&amp;gt;&amp;lt;p class=&amp;#34;calibre_24&amp;#34;&amp;gt;这一类副词有一个特色：它在使用上很有弹性，&amp;lt;span class=&amp;#34;bold&amp;#34;&amp;gt;四种主要词类，包括名词、动词、形容词与副词都可以用它来修饰。&amp;lt;/span&amp;gt;认识这一点，才算真正弄清楚形容词与副词间的分工。这一类的副词又可以细分为以下三种：&amp;lt;/p&amp;gt; 所要做的是把下面这一段变为：&amp;lt;h2&amp;gt;强调语气的副词（Intensifiers)&amp;lt;/h2&amp;gt;，这样我就可以在SM里很方便地按h2标签分割内容。
1 &amp;lt;blockquote class=&amp;#34;calibre2&amp;#34;&amp;gt;&amp;lt;blockquote class=&amp;#34;calibre2&amp;#34;&amp;gt;&amp;lt;blockquote class=&amp;#34;calibre2&amp;#34;&amp;gt;&amp;lt;blockquote class=&amp;#34;calibre_21&amp;#34;&amp;gt;&amp;lt;span class=&amp;#34;calibre1&amp;#34;&amp;gt;&amp;lt;span class=&amp;#34;bold&amp;#34;&amp;gt;&amp;lt;span class=&amp;#34;calibre_12&amp;#34;&amp;gt;强调语气的副词（Intensifiers)&amp;lt;/span&amp;gt;&amp;lt;/span&amp;gt;&amp;lt;/span&amp;gt;&amp;lt;/blockquote&amp;gt;&amp;lt;/blockquote&amp;gt;&amp;lt;/blockquote&amp;gt;&amp;lt;/blockquote&amp;gt; 可以看到，一共是4个blockquote标签，3个span标签，那么我们可以先设法用正则匹配出一个起始blockquote标签，然后重复4次，匹配出一个起始span标签，然后重复3词，就能匹配出所有的起始标签了。
(&amp;lt;blockquote\s[^&amp;gt;]*&amp;#34;&amp;gt;){4}(&amp;lt;span\s[^&amp;gt;]*&amp;#34;&amp;gt;){3} 同样的道理，匹配所有的闭合标签。
(&amp;lt;\/span&amp;gt;){3}(&amp;lt;/blockquote&amp;gt;){4} 最后，标题可以用(.*?)匹配，把它们组合在一起，就成功匹配出了这段html代码。
(&amp;lt;blockquote\s[^&amp;gt;]*&amp;#34;&amp;gt;){4}(&amp;lt;span\s[^&amp;gt;]*&amp;#34;&amp;gt;){3}(.*?)(&amp;lt;\/span&amp;gt;){3}(&amp;lt;/blockquote&amp;gt;){4} 将其用下面的内容替换，内容就整理好了。
\n&amp;lt;h2&amp;gt;$3&amp;lt;/h2&amp;gt;\n 上面的正则，经过我的实践，是比较经济实惠的。以后如果有更好的方案，本文会继续更新。</description></item><item><title>Think Python Exercise 10.6</title><link>https://o5o.me/post/think_python_exercise_10.6/</link><pubDate>Sat, 31 Dec 2022 18:28:02 +0800</pubDate><guid>https://o5o.me/post/think_python_exercise_10.6/</guid><description>如果可以通过重排一个单词中字母的顺序，得到另外一个单词，那么称这两个单词是变位词。编写一个叫做 is_anagram 的函数，接受两个字符串作为参数， 如果它们是变位词则返回 True 。
解答：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 def is_anagram(s1,s2): t1 = list(s1) t2 = list(s2) #先把字符串转换成列表 if len(t1) == len(t2): #如果两个字符串长度都不一样，那么肯定不是变位词了 t1.sort() t2.sort() #按照同样的方式重新排序后，如果二者元素对应相等，那么它们就是变位词了 for i in range(len(t1)): if t1[i] == t2[i]: pass else: return False return True else: return False is_anagram(&amp;#39;abc&amp;#39;,&amp;#39;bac&amp;#39;)</description></item><item><title>Think Python Exercise 10.5</title><link>https://o5o.me/post/think_python_exercise_10.5/</link><pubDate>Sat, 31 Dec 2022 17:50:04 +0800</pubDate><guid>https://o5o.me/post/think_python_exercise_10.5/</guid><description>编写一个叫做is_sorted的函数，接受一个列表作为参数，如果列表是递增排列的则返回 True ，否则返回False。 例如：
&amp;gt;&amp;gt;&amp;gt; is_sorted([1, 2, 2]) True &amp;gt;&amp;gt;&amp;gt; is_sorted([&amp;#39;b&amp;#39;, &amp;#39;a&amp;#39;]) False 分析：
可以先对列表用.sort()方法进行递增排列，如果递增排列后的列表和原列表的元素都对应相同，说明原列表本身就是递增排列的。
一个错误的写法：
1 2 3 4 5 6 7 8 9 def is_sorted(t): t_copy = t[:] print(t_copy) if t_copy == t.sort(): return True else: return False is_sorted([1, 2, 2]) 程序没有报错，但它仍是错的，因为，我们要比较的是两个列表里的元素对应相同，而不是看这两个变量是不是指向同一个列表。t_copy和t.sort()肯定不指向同一个列表，但它们的元素对应相同。因此我们不能用t_copy == t.sort()这样的方法来比较。可以这样做：
1 2 3 4 5 6 7 8 9 10 11 def is_sorted(t): t_copy = t[:] for i in range(len(t)): if t_copy[i] == t[i]: #如果递增排列后的列表和原列表的元素都对应相同，说明原列表本身就是递增排列的 pass else: return False return True is_sorted([1, 2, 2]) 还可以用另一种方法实现：从第二个元素开始，依次和前面一个元素比较大小。</description></item><item><title>Think Python Exercise 10.4</title><link>https://o5o.me/post/think_python_exercise_10.4/</link><pubDate>Sat, 31 Dec 2022 17:29:11 +0800</pubDate><guid>https://o5o.me/post/think_python_exercise_10.4/</guid><description>编写一个叫做 chop 的函数，接受一个列表作为参数，移除第一个和最后一个元素，并返回None。例如：
&amp;gt;&amp;gt;&amp;gt; t = [1, 2, 3, 4] &amp;gt;&amp;gt;&amp;gt; chop(t) &amp;gt;&amp;gt;&amp;gt; t [2, 3] 分析：
一顿操作猛如虎：（错的）
1 2 3 4 5 6 7 8 def chop(t): t = t[1:-1] t1 = [1, 2, 3, 4] chop(t1) t1 为什么t1没变化？是我列表切片用错了吗，再试试：（还是错的）
1 2 3 4 5 6 7 8 def chop(t): t = t[1:len(t)-2] t1 = [1, 2, 3, 4] chop(t1) t1 可以看到，t1还是没变化，为什么？为什么这样是错的？
不要被迷惑了，当一个列表t1传递给一个函数时，t1和形参t共同指向同一个列表，但当函数内部t重新赋值后，t指向了一个新的列表，而t1依然指向原来的列表，那么当函数运行结束后，t1的值当然还是原来的啦。
由于题目要求函数不能有返回值，可以使用下面的做法：
1 2 3 4 5 6 7 8 9 def chop(t): del t[0] del t[-1] t1 = [1, 2, 3, 4] chop(t1) t1 如果函数可以有返回值，可以这样写：</description></item><item><title>Think Python Exercise 10.9</title><link>https://o5o.me/post/think_python_exercise_10.9/</link><pubDate>Sat, 31 Dec 2022 16:59:00 +0800</pubDate><guid>https://o5o.me/post/think_python_exercise_10.9/</guid><description>编写一个函数，读取文件 words.txt ，建立一个列表,其中每个单词为一个元素。
编写两个版本，一个使用 append 方法，另一个使用 t = t + [x] 。那个版本运行得慢？为什么？
解答：
在 jupyter 中的一个代码单元（cell）中，代码第一行写上%%time或%%timeit，即可计算代码的运行时间。
版本1：
1 2 3 4 5 6 7 8 9 10 11 12 %%time def read_word1(file_in): word_list = [] for line in file_in: word = line.strip() word_list.append(word) return word_list fin = open(&amp;#39;words.txt&amp;#39;) a = read_word1(fin) 运行结果：
CPU times: user 85.3 ms, sys: 0 ns, total: 85.3 ms Wall time: 88.4 ms
版本2：
1 2 3 4 5 6 7 8 9 10 11 12 %%time def read_word2(file_in): word_list = [] for line in file_in: word = line.</description></item><item><title>Think Python Exercise 10.2</title><link>https://o5o.me/post/think_python_exercise_10.2/</link><pubDate>Sat, 31 Dec 2022 16:42:52 +0800</pubDate><guid>https://o5o.me/post/think_python_exercise_10.2/</guid><description>编写一个叫做 cumsum 的函数，接受一个由数值组成的列表，并返回累加和；即一个新列表，其中第i个元素是原列表中前i+1个元素的和（注意i是从0开始的）。 例如：
&amp;gt;&amp;gt;&amp;gt; t = [1, 2, 3] &amp;gt;&amp;gt;&amp;gt; cumsum(t) [1, 3, 6] 解答：
1 2 3 4 5 6 7 8 9 10 11 12 def cumsum(t): numsum = [] for i in range(len(t)): numsum.append(sum(t[:i+1])) #对t的前i+1个元素求和（注意i是从0开始，所以第i个元素是第i+1个元素），然后追加到新列表里 return numsum t = [1, 2, 3] print(cumsum(t)) t = [3,3,6,9,10] print(cumsum(t))</description></item><item><title>Think Python Exercise 10.1</title><link>https://o5o.me/post/think_python_exercise_10.1/</link><pubDate>Sat, 31 Dec 2022 16:22:37 +0800</pubDate><guid>https://o5o.me/post/think_python_exercise_10.1/</guid><description>编写一个叫做 nested_sum 的函数，接受一个由一些整数列表构成的列表作为参数，并将所有嵌套列表中的元素相加。例如：
&amp;gt;&amp;gt;&amp;gt; t = [[1, 2], [3], [4, 5, 6]] &amp;gt;&amp;gt;&amp;gt; nested_sum(t) 21 解答：
可以分别对每个子列表求和，再对得到的各个和求和。也可以先把各个子列表合并起来，然后对得到的列表求和。
1 2 3 4 5 6 7 8 9 def nested_sum(t): c = [] for i in t: c = c + i #把t列表里的各个列表合并成一个列表 return sum(c) t = [[1, 2], [3], [4, 5, 6]] nested_sum(t)</description></item><item><title>游戏手柄用于SuperMemo复习</title><link>https://o5o.me/post/supermemo-gamepad/</link><pubDate>Fri, 30 Dec 2022 12:23:10 +0800</pubDate><guid>https://o5o.me/post/supermemo-gamepad/</guid><description>在用SuperMemo复习时，一边要移动鼠标，浏览卡片内容，一边要用键盘评分、修改卡片内容，容易手忙脚乱。把评分常用的按键和其他一些按键映射到游戏手柄上可以稍微方便一点。
游戏手柄：八位堂Zero2小手柄。 软件：AntiMicroX
手柄连接计算机 看说明书即可。
在AntiMicroX中设定快捷键 打开软件后，点手柄上的按键，可以看到有的按键映射是错的，点软件窗口左下角的“游戏控制器映射”，先矫正一遍。
然后在软件主窗口中找到你想设定快捷键的按键（可以通过按手柄上的对应按键确定它的位置），鼠标点击，设定快捷键即可。
在我的SuperMemo中，目前是有很多的摘录卡片，以及很少的填空题卡片。我习惯于一边复习一边编辑卡片内容，比如把一段紧凑的话分成一行一行的句子，修改一些措辞。
在SM中，当我的鼠标点击了卡片，可以看作我进入了“编辑模式”，如果这张卡片看完了，想进入下一张卡片，我需要先退出“编辑模式”（按ESC），再按回车键。可以把这两个键简化为一个键，在游戏手柄上按一次，无论你是不是在“编辑模式”，都可以跳转到下一张卡片。
在AntiMicroX窗口中鼠标点击按键，在弹出的窗口中点击“高级选项”，又弹出一个窗口，在“分配”栏里点击“小方块”（里面出现&amp;quot;&amp;hellip;&amp;quot;），这时候在键盘上输入想设定的按键。设定两个按键，那么点击游戏手柄上的按键时，这两个按键会依次执行。
我的按键设定 设定原则是，使用越多的按键放在越容易按的位置。
使用手柄时我习惯竖着拿。除了十字方向键（我不用），最不方便按的是左肩键，其次是右肩键，然后是开始键和选择键。
因此，我的设定是：
左肩键，评分5。一是用的少，二来对一张卡片评分5时需要调整手的握姿，这样就会很慎重、很有仪式感。如果这种情况下还非要把一张卡片评分为5，说明真的掌握的很好了。
右肩键，评分2。答错时按的。
A，评分3/ENTER。最容易按的键。因为在评分时，按Enter键的效果和按3是一样的，所以设定为Enter，这样在复习时就不用频繁移动手指了。
X，评分1。
B，评分4。
Y，ESC+Enter，切换到下一张卡片。
为什么A设定了Enter，这里还要再设定一个ESC+Enter呢？或者能不能都用ESC+Enter呢？你复习的时候亲手去操作一下就明白了。评分时按ESC+Enter没效果；阅读并编辑卡片时，按Enter不会跳转到下一张卡片，而是在卡片里添加一个空行。
这是一件很主观的事情，怎么舒服怎么来。
全文完。</description></item><item><title>Think Python Exercise 9.6</title><link>https://o5o.me/post/think_python_exercise_9.6/</link><pubDate>Thu, 29 Dec 2022 17:45:12 +0800</pubDate><guid>https://o5o.me/post/think_python_exercise_9.6/</guid><description>编写一个名为is_abecedarian 的函数, 如果单词中的字符以字符表的顺序出现 (允许重复字符),则返回True。有多少个具备这种特征的单词?
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 def word_abcde(word): alphabets = &amp;#34;abcdefghijklmnopqrstuvwxyz&amp;#34; i = 0 front = 0 #前一个字母的序数 mine = 0 #当前字母的序数 while i &amp;lt; len(word): index = 0 while index &amp;lt; len(alphabets): # print(i,word[i],index,alphabets[index]) if word[i] == alphabets[index]: mine = index if mine &amp;lt; front: return False else: front = mine break index += 1 i += 1 return True def is_abecedarian(file_in): count = 0 for line in file_in: word = line.</description></item><item><title>Think Python Exercise 9.5</title><link>https://o5o.me/post/think_python_exercise_9.5/</link><pubDate>Thu, 29 Dec 2022 16:05:12 +0800</pubDate><guid>https://o5o.me/post/think_python_exercise_9.5/</guid><description>编写一个名为uses_all的函数,接受一个单词和一个必须使用的字符组成的字符串。如果该单词包括此字符串中的全部字符至少一次,则返回True。你能统计出多少单词包含了所有的元音字符aeiou吗?如果换成aeiouy 呢?
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 def uses_all(word, muststr): for i in muststr: count = 0 index = 0 while index &amp;lt; len(word): if i == word[index]: break index += 1 if index == len(word): return False return True def count_word(file_in, als): count = 0 for line in file_in: word = line.</description></item><item><title>Think Python Exercise 9.4</title><link>https://o5o.me/post/think_python_exercise_9.4/</link><pubDate>Thu, 29 Dec 2022 15:30:12 +0800</pubDate><guid>https://o5o.me/post/think_python_exercise_9.4/</guid><description>编写一个名为 avoids 的函数，接受一个单词和一个指定禁止使用字符的字符串，如果单词中不包含任意被禁止的字符，则返回True 。
修改你的程序，提示用户输入一个禁止使用的字符，然后打印不包含这些字符的单词的数量。你能找到一个5个禁止使用字符的组合，使得其排除的单词数目最少么？
你能找到一个&amp;quot;5个禁止使用字符&amp;quot;的组合，使得其排除的单词数目最少么？ 分析：从26个字母中挑选5个字母构成一个组合，打印不包含这些字母的单词的数量，看哪个组合下被排除出去的单词数目最少。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 def avoids(word,ause): #ause，avoid use for i in ause: for letter in word: if letter == i: return False return True def has_no_string(file_in, nals): #nals指的是no alphabets，字母 count_nals = 0 #不含用户指定的各个字符的单词的个数 for line in file_in: word = line.strip() if avoids(word,nals): count_nals += 1 print(&amp;#34;不含&amp;#34;,nals,&amp;#34;的单词有&amp;#34;,count_nals,&amp;#34;个&amp;#34;) text = input(&amp;#34;请输入一个禁止使用的字符串，字符串里的字母都不会出现在单词中\n&amp;#34;) fin = open(&amp;#39;words.</description></item><item><title>Think Python Exercise 9.3</title><link>https://o5o.me/post/think_python_exercise_9.3/</link><pubDate>Thu, 29 Dec 2022 15:28:12 +0800</pubDate><guid>https://o5o.me/post/think_python_exercise_9.3/</guid><description>编写一个名为 avoids 的函数，接受一个单词和一个指定禁止使用字符的字符串，如果单词中不包含任意被禁止的字符，则返回True 。
修改你的程序，提示用户输入一个禁止使用的字符，然后打印不包含这些字符的单词的数量。你能找到一个5个禁止使用字符的组合，使得其排除的单词数目最少么？
你能找到一个&amp;quot;5个禁止使用字符&amp;quot;的组合，使得其排除的单词数目最少么？ 分析：从26个字母中挑选5个字母构成一个组合，打印不包含这些字母的单词的数量，看哪个组合下被排除出去的单词数目最少。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 def avoids(word,ause): #ause，avoid use for i in ause: for letter in word: if letter == i: return False return True def has_no_string(file_in, nals): #nals指的是no alphabets，字母 count_nals = 0 #不含用户指定的各个字符的单词的个数 for line in file_in: word = line.strip() if avoids(word,nals): count_nals += 1 print(&amp;#34;不含&amp;#34;,nals,&amp;#34;的单词有&amp;#34;,count_nals,&amp;#34;个&amp;#34;) text = input(&amp;#34;请输入一个禁止使用的字符串，字符串里的字母都不会出现在单词中\n&amp;#34;) fin = open(&amp;#39;words.</description></item><item><title>Think Python Exercise 9.2</title><link>https://o5o.me/post/think_python_exercise_9.2/</link><pubDate>Thu, 29 Dec 2022 15:27:12 +0800</pubDate><guid>https://o5o.me/post/think_python_exercise_9.2/</guid><description>1939年，Ernest Vincent Wright出版了一本名为 《Gadsby》 的小说，该小说里完全没有使用字符“e”。由于“e”是最常用的英文字符，因此这并不容易做到。
事实上，不使用这个最常用的符号(字符e)来构建一个孤立的想法是很难的。开始进展缓慢，但是经过有意识的、长时间的训练，你可以逐渐地熟练。
好啦，不再说题外话了（让我们开始编程练习）。
写一个叫做has_no_e的函数，如果给定的单词中不包含字符“e”，其返回 True 。
修改上一节中的程序，只打印不包含“e”的单词，并且计算列表中不含“e”单词的比例。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 fin = open(&amp;#39;words.txt&amp;#39;) def has_no_e(file_in): count_ne = 0 #不含e的单词的个数 count = 0 #总单词个数 for line in file_in: word = line.strip() index = 0 while index &amp;lt; len(word): if word[index] == &amp;#39;e&amp;#39;: break else: index = index + 1 if index == len(word): # print(word) #因为单词比较多，不一个个列出来了 count_ne = count_ne + 1 count = count + 1 print(&amp;#34;不含e的单词有&amp;#34;,count_ne,&amp;#34;个&amp;#34;,&amp;#34;单词一共有&amp;#34;,count,&amp;#34;个&amp;#34;,&amp;#34;不含“e”单词的比例为&amp;#34;,count_ne/count*100,&amp;#34;%&amp;#34;) has_no_e(fin) 上面是一个字母一个字母判断单词是不是包含‘e’的，下面是在 if 中使用 in 操作符简化后的方案：</description></item><item><title>Think Python Exercise 9.1</title><link>https://o5o.me/post/think_python_exercise_9.1/</link><pubDate>Wed, 28 Dec 2022 21:48:12 +0800</pubDate><guid>https://o5o.me/post/think_python_exercise_9.1/</guid><description>编程写一个程序，使得它可以读取 words.txt　，然后只打印出那些长度超过20个字符的单词(不包括空格)。
1 2 3 4 5 6 fin = open(&amp;#39;words.txt&amp;#39;) for line in fin: word = line.strip() if len(word) &amp;gt; 20: print(word)</description></item></channel></rss>