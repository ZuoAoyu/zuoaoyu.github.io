<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on o5o</title><link>https://o5o.me/post/</link><description>Recent content in Posts on o5o</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Wed, 18 Jan 2023 20:00:35 +0800</lastBuildDate><atom:link href="https://o5o.me/post/index.xml" rel="self" type="application/rss+xml"/><item><title>PyCharm创建conda项目时提示CondaError: Unable to create prefix directory</title><link>https://o5o.me/post/pycharm_condaerror_anaconda/</link><pubDate>Wed, 18 Jan 2023 20:00:35 +0800</pubDate><guid>https://o5o.me/post/pycharm_condaerror_anaconda/</guid><description>原因是我没有把anaconda安装在默认位置（/home目录里），而是装在了/opt目录里，我以普通用户的身份运行PyCharm，没有权限访问/opt目录，所以有了这个错误提示。
解决办法：在/home/用户目录里我建了一个文件夹来放conda环境。</description></item><item><title>AttributeError: object has no attribute</title><link>https://o5o.me/post/attributeerror_object_has_no_attribute/</link><pubDate>Tue, 17 Jan 2023 13:50:22 +0800</pubDate><guid>https://o5o.me/post/attributeerror_object_has_no_attribute/</guid><description>今天写的程序运行时提示：AttributeError: 'BaiduImageSpider' object has no attribute 'url'，让我百思不得其解。
最后发现是我把__init__写成了__int__，DeBug也没发现这个错误。</description></item><item><title>Chrome网页源代码自动换行</title><link>https://o5o.me/post/chrome_view_source/</link><pubDate>Fri, 13 Jan 2023 22:09:41 +0800</pubDate><guid>https://o5o.me/post/chrome_view_source/</guid><description>我觉得我遇到了 Baader-Meinhof 现象1。
今天在写爬虫的时候，突然想到，如果Chrome的网页源代码页面的代码能自动换行就好了。我就去网上搜有没有方法能让源代码自动换行显示。
一番搜寻没有结果，然后我就打算放弃，然后我不经意往一个已经打开的网页源代码页面一瞟，赫然有一个“自动换行”复选框静静显示在那里。
天地良心，我以前真的是没有注意到过那里还有那么一个按钮，而现在它却那么显眼。
Frequency illusion - Wikipedia&amp;#160;&amp;#x21a9;&amp;#xfe0e;</description></item><item><title>爬虫运行报错：UnicodeEncodeError: 'latin-1' codec can't encode characters</title><link>https://o5o.me/post/spider_unicodeencodeerror_latin-1/</link><pubDate>Fri, 13 Jan 2023 13:58:29 +0800</pubDate><guid>https://o5o.me/post/spider_unicodeencodeerror_latin-1/</guid><description>写了一个简单的爬虫程序，从百度图片下载图片，但运行时报错：UnicodeEncodeError: 'latin-1' codec can't encode characters in position 41-44: ordinal not in range(256)
程序反反复复检查了好几遍，最终确定是cookie的问题。
我是从自己的 Chrome 浏览器里直接拷贝的cookie值粘贴到程序里的，没注意从Chrome直接复制的cookie会先解码再给你。就是说，程序里需要的cookie是不带中文的（中文先进行编码，比如把古力娜扎编码为%E5%8F%A4%E5%8A%9B%E5%A8%9C%E6%89%8E），但从Chrome复制出来的cookie带中文。
Chrome这是好心办坏事吗。</description></item><item><title>Think Python Exercise 3.3</title><link>https://o5o.me/post/think_python_exercise_3.3/</link><pubDate>Tue, 10 Jan 2023 21:42:59 +0800</pubDate><guid>https://o5o.me/post/think_python_exercise_3.3/</guid><description>注意:请使用我们目前学过的语句和特性来完成本题。
编写一个能画出如下网格 (grid) 的函数: + - - - - + - - - - + | | | | | | | | | | | | + - - - - + - - - - + | | | | | | | | | | | | + - - - - + - - - - + 提示:你可以使用一个用逗号分隔的值序列,在一行中打印出多个值:
print(&amp;#39;+&amp;#39;, &amp;#39;−&amp;#39;) print 函数默认会自动换行,但是你可以阻止这个行为,只需要像下面这样将行结尾变成一个空格:
print(&amp;#39;+&amp;#39;, end=&amp;#39; &amp;#39;) print(&amp;#39;−&amp;#39;) 这两个语句的输出结果是+ −。</description></item><item><title>Think Python Exercise 3.2</title><link>https://o5o.me/post/think_python_exercise_3.2/</link><pubDate>Tue, 10 Jan 2023 21:30:47 +0800</pubDate><guid>https://o5o.me/post/think_python_exercise_3.2/</guid><description>函数对象是一个可以赋值给变量的值, 也可以作为实参传递。 例如, do_twice 函数接受函数对象作为实参,并调用这个函数对象两次:
def do_twice(f): f() f() 下面这个示例使用 do_twice 来调用名为 print_spam 的函数两次。
def print_spam (): print(&amp;#39;spam &amp;#39;) do_twice(print_spam) 将这个示例写入脚本,并测试。 修改do_twice,使其接受两个实参,一个是函数对象,另一个是值。然后调用这一函数对象两次,将那个值传递给函数对象作为实参。 从本章前面一些的示例中, 将 print_twice 函数的定义复制到脚本中。 使用修改过的 do_twice ,调用print_twice 两次,将 spam 传递给它作为实参。 定义一个名为 do_four 的新函数,其接受一个函数对象和一个值作为实参。调用这个函数对象四次,将那个值作为形参传递给它。函数体中应该只有两条语句,而不是四条。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 def do_twice(f, argus): f(argus) f(argus) def print_twice(bruce): print(bruce) print(bruce) def do_four(f, argus): do_twice(f, argus) do_twice(f, argus) do_twice(print_twice, &amp;#39;spam&amp;#39;) #do_four(print_twice, &amp;#34;spam&amp;#34;)</description></item><item><title>Think Python Exercise 3.1</title><link>https://o5o.me/post/think_python_exercise_3.1/</link><pubDate>Tue, 10 Jan 2023 21:23:43 +0800</pubDate><guid>https://o5o.me/post/think_python_exercise_3.1/</guid><description>编写一个名为 right_justify 的函数, 函数接受一个名为 s 的字符串作为形参, 并在打印足够多的前导空格 (leading space) 之后打印这个字符串,使得字符串的最后一个字母位于显示屏的第 70 列。
提示: 使用字符串拼接 (string concatenation) 和重复。 另外, Python 提供了一个名叫len 的内建函数,可以返回一个字符串的长度,因此len(&amp;lsquo;allen&amp;rsquo;) 的值是 5。
1 2 3 4 5 6 7 def right_justify(s): print(&amp;#39; &amp;#39;*(70-len(s)),s) s1 = &amp;#34;good morning&amp;#34; s2 = &amp;#34;nice to meet you&amp;#34; right_justify(s1) right_justify(s2)</description></item><item><title>Think Python Exercise 17.2</title><link>https://o5o.me/post/think_python_exercise_17.2/</link><pubDate>Tue, 10 Jan 2023 16:15:37 +0800</pubDate><guid>https://o5o.me/post/think_python_exercise_17.2/</guid><description>这道习题中包含了 Python 中最常见、最难找出来的错误。编写一个叫 Kangaroo 的类,包含以下方法:
一个__init__ 方法,初始化一个叫 pounch_contents 的属性为空列表。 一个叫put_in_pounch 的方法,将一个任意类型的对象加入pounch_contents。 一个__str__ 方法,返回 Kangaroo 对象的字符串表示和 pounch 中的内容。 创建两个 Kangaroo 对象, 将它们命名为 kanga 和 roo , 然后将 roo 加入 kanga 的 pounch 列表, 以此测试你写的代码。
这是我在不完全理解题目时写的代码（请不要参考）：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Kangaroo: def __init__(self): self.pounch_contents = [] def put_in_pounch(self, ayobj): self.pounch_contents.append(ayobj) def __str__(self): return str(self.pounch_contents) kanga = Kangaroo() roo = Kangaroo() kanga.put_in_pounch(roo) print(kanga) 其实这是一个找bug的练习。作者想让我们使用pylint这个工具找出他的代码里的bug。</description></item><item><title>Think Python Exercise 17.0</title><link>https://o5o.me/post/think_python_exercise_17.0/</link><pubDate>Tue, 10 Jan 2023 12:51:08 +0800</pubDate><guid>https://o5o.me/post/think_python_exercise_17.0/</guid><description>我们做个练习, 将 time_to_int (见 16.4 节) 重写为方法。你或许也想将 int_to_time 改写为方法,但是那样做并没有什么意义,因为没有调用它的对象。
原 int_to_time 函数见练习16.0。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Time: &amp;#34;&amp;#34;&amp;#34;Represents the time of day.&amp;#34;&amp;#34;&amp;#34; def print_time(self): print(&amp;#34;%.2d:%.2d:%.2d&amp;#34; % (self.hour, self.minute, self.second)) def time_to_int(self): minutes = self.hour * 60 + self.minute seconds = minutes * 60 + self.second return seconds start = Time() start.hour = 9 start.minute = 45 start.second = 20 start.</description></item><item><title>Think Python Exercise 17.1</title><link>https://o5o.me/post/think_python_exercise_17.1/</link><pubDate>Tue, 10 Jan 2023 12:44:03 +0800</pubDate><guid>https://o5o.me/post/think_python_exercise_17.1/</guid><description>修改 Time 类的属性, 使用一个整数代表自午夜零点开始的秒数。然后修改类的方法 (和int_to_time 函数),使其适用于新的实现。你不用修改 main 函数中的测试代码。完成之后, 程序的输出应该和之前保持一致。
分析：作者的意思是，Time 类的属性，修改后只有“秒”这一个（小时、分钟都没了），同时，修改后Time类接收的参数和返回的值都保持不变。
作者提供的用于修改的代码：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 &amp;#34;&amp;#34;&amp;#34;This module contains a code example related to Think Python, 2nd Edition by Allen Downey http://thinkpython2.</description></item><item><title>Think Python Exercise 16.2</title><link>https://o5o.me/post/think_python_exercise_16.2/</link><pubDate>Tue, 10 Jan 2023 10:23:15 +0800</pubDate><guid>https://o5o.me/post/think_python_exercise_16.2/</guid><description>datetime 模块提供的 time 对象,和本章的 Time 对象类似, 但前者提供了更丰富的方法和操作符。
使用 datetime 模块来编写一个程序,获取当前日期并打印当天是周几。 编写一个程序,接受一个生日作为输入,并打印用户的年龄以及距离下个生日所需要的天数、小时数、分钟数和秒数。 对于两个不在同一天出生的人来说,总有一天,一个人的出生天数是另一个人的两倍。我们把这一天称为 ‘‘双倍日’’。编写一个程序,接受两个不同的出生日期, 并计算他们的 ‘‘双倍日’’。 再增加点挑战,编写一个更通用的版本,用于计算一个人出生天数是另一个人 n 倍的日子。 题1
1 2 3 4 5 6 7 from datetime import date today = date.today() #print(dir(today)) #打印属性、方法列表 print(&amp;#34;今天是星期%d.&amp;#34; % (today.weekday()+1)) # weekday返回的值是从0开始的，所以+1 题2
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 from datetime import datetime def days_until_birthday(birthday): &amp;#34;&amp;#34;&amp;#34;距离下一次生日还有多长时间&amp;#34;&amp;#34;&amp;#34; today = datetime.</description></item><item><title>Think Python Exercise 16.1</title><link>https://o5o.me/post/think_python_exercise_16.1/</link><pubDate>Tue, 10 Jan 2023 10:10:48 +0800</pubDate><guid>https://o5o.me/post/think_python_exercise_16.1/</guid><description>写一个叫做 mul_time 的函数,接收一个 Time 对象和一个数,并返回一个新的 Time 对象,包含原始时间和数的乘积。
然后使用 mul_time 编写一个函数,接受一个表示比赛完赛时间的 Time 对象以及一个表示距离的数字,并返回一个用于表示平均配速 (每英里所需时间) 的 Time 对象。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class Time: &amp;#34;&amp;#34;&amp;#34;用于记录时间 属性：hour, minute, second &amp;#34;&amp;#34;&amp;#34; def print_time(ti): print(&amp;#34;%.2d:%.2d:%.2d&amp;#34; % (ti.hour,ti.minute,ti.second)) #记得加括号 def time_to_int(time): minutes = time.hour * 60 + time.minute seconds = minutes * 60 + time.</description></item><item><title>Think Python Exercise 16.1</title><link>https://o5o.me/post/think_python_exercise_16.0/</link><pubDate>Mon, 09 Jan 2023 16:59:37 +0800</pubDate><guid>https://o5o.me/post/think_python_exercise_16.0/</guid><description>编写一个叫做 print_time 的函数,接收一个 Time 对象并用 时:分:秒 的格式打印它。提示: 格式化序列 %.2d 可以至少两位数的形式打印一个整数,如果不足则在前面补 0。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Time: &amp;#34;&amp;#34;&amp;#34;用于记录时间 属性：hour, minute, second &amp;#34;&amp;#34;&amp;#34; def print_time(ti): print(&amp;#34;%.2d:%.2d:%.2d&amp;#34; % (ti.hour,ti.minute,ti.second)) #记得加括号 time1 = Time() time1.hour = 11 time1.minute = 59 time1.second = 30 print_time(time1) 编写一个叫做 is_after 的布尔函数,接收两个 Time 对象,t1 和 t2 ,若 t1 的时间在 t2 之后,则返回 True ,否则返回 False。挑战:不要使用 if 语句。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Time: &amp;#34;&amp;#34;&amp;#34;用于记录时间 属性：hour, minute, second &amp;#34;&amp;#34;&amp;#34; def print_time(ti): print(&amp;#34;%.</description></item><item><title>Think Python Exercise 15.2</title><link>https://o5o.me/post/think_python_exercise_15.2/</link><pubDate>Mon, 09 Jan 2023 16:11:59 +0800</pubDate><guid>https://o5o.me/post/think_python_exercise_15.2/</guid><description>编写一个名为 draw_rect 的函数,该函数接受一个 Turtle 对象和一个 Rectangle 对象,使用Turtle 画出该矩形。参考第 四 章中使用 Turtle 的示例。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 import turtle class Point: &amp;#34;&amp;#34;&amp;#34;表示一个二维的点 &amp;#34;&amp;#34;&amp;#34; class Rectangle: &amp;#34;&amp;#34;&amp;#34;Represents a rectangle. attributes: width, height, corner.&amp;#34;&amp;#34;&amp;#34; def draw_rect(t,rect): t.pu() #在移动到矩形左下角的过程中，不画出痕迹（提笔，put up） t.goto(rect.corner.x, rect.corner.y) t.pd() #落笔（put down） for i in range(2): t.</description></item><item><title>Think Python Exercise 15.1</title><link>https://o5o.me/post/think_python_exercise_15.1/</link><pubDate>Wed, 04 Jan 2023 21:30:00 +0800</pubDate><guid>https://o5o.me/post/think_python_exercise_15.1/</guid><description>15.1.1 定义一个叫做Circle类, 类的属性是圆心 (center) 和半径 (radius), 其中, 圆心 (center) 是一个 Point 类,而半径 (radius) 是一个数字。
实例化一个圆心 (center) 为 (150, 100) ,半径 (radius) 为 75 的Circle 对象。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Circle: &amp;#34;&amp;#34;&amp;#34;属性：圆心center、半径radius 圆心是一个Point类 半径是一个数字 &amp;#34;&amp;#34;&amp;#34; class Point: &amp;#34;&amp;#34;&amp;#34;表示一个二维的点 &amp;#34;&amp;#34;&amp;#34; bob = Circle() bob.center = Point() bob.center.x = 150 bob.center.y = 100 bob.radius = 75 15.1.2 编写一个名称为point_in_circle的函数,该函数可以接受一个圆类 (Circle) 对象和点类 (Point) 对象, 然后判断该点是否在圆内。在圆内则返回True 。</description></item><item><title>Think Python Exercise 15.0</title><link>https://o5o.me/post/think_python_exercise_15.0/</link><pubDate>Wed, 04 Jan 2023 12:25:00 +0800</pubDate><guid>https://o5o.me/post/think_python_exercise_15.0/</guid><description>编写一个叫做distance_between_points的函数，它接受两个Point作为参数，然后返回这两个点之间的距离。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 import math class Point: &amp;#34;&amp;#34;&amp;#34;表示一个二维的点 &amp;#34;&amp;#34;&amp;#34; def distance_between_points(p1,p2): return math.sqrt((p1.x - p2.x)**2+(p1.y - p2.y)**2) Po1 = Point() Po2 = Point() Po1.x = 5 Po1.y = 3 Po2.x = 6 Po2.y = 2 distance_between_points(Po1,Po2) 编写一个叫做move_rectangle的函数，接受一个Rectangle以及两个数字dx和dy。它把corner的x坐标加上dx，把corner的y坐标加上dy，从而改变矩形的位置。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 def print_point(p): print(&amp;#39;(%g, %g)&amp;#39; % (p.</description></item><item><title>Think Python Exercise 11.3 阿克曼函数</title><link>https://o5o.me/post/think_python_exercise_11.3_ackermann/</link><pubDate>Tue, 03 Jan 2023 22:39:00 +0800</pubDate><guid>https://o5o.me/post/think_python_exercise_11.3_ackermann/</guid><description>将 习题6.2 中的 Ackermann 函数备忘录化(memoize), 看看备忘录化(memoization)是否可以支持解决更大的参数。没有提示!
储存之前计算过的值以便今后使用，这个操作就称为备忘录化。
做这道题首先要理解书上关于斐波那契数列的例子。
计算斐波那契数列的代码：
1 2 3 4 5 6 7 def fibonacci(n): if n == 0: return 0 elif n == 1: return 1 else: return fibonacci(n-1) + fibonacci(n-2) 备忘录化后的代码：
1 2 3 4 5 6 7 8 9 known = {0:0, 1:1} def fibonacci(n): if n in known: return known[n] res = fibonacci(n-1) + fibonacci(n-2) known[n] = res return res 按照同样的思路，我们可以把计算的ack函数的值储存到字典里，后面再计算时先看之前是不是曾计算过，如果计算过，直接调用已有结果即可。
原ack函数代码：
1 2 3 4 5 6 7 8 def ackermann(m,n): #来自6.</description></item><item><title>Think Python Exercise 6.2 阿克曼函数</title><link>https://o5o.me/post/think_python_exercise_6.2_ackermann/</link><pubDate>Tue, 03 Jan 2023 21:25:57 +0800</pubDate><guid>https://o5o.me/post/think_python_exercise_6.2_ackermann/</guid><description>Ackermann 函数 $A(m, n)$ 的定义如下:
$$ A(m, n)=\left{\begin{array}{ll} n+1 &amp;amp; \text { if } m=0 \ A(m-1,1) &amp;amp; \text { if } m&amp;gt;0 \text { and } n=0 \ A(m-1, A(m, n-1)) &amp;amp; \text { if } m&amp;gt;0 \text { and } n&amp;gt;0 \end{array}\right. $$
查看维基百科的定义, 编写一个叫作ack的函数来计算 Ackermann 函数。使用你的函 数计算ack(3,4), 其结果应该为 125 。如果 $m$ 和 $n$ 的值较大时, 会发生什么?
拙见：
1 2 3 4 5 6 7 8 9 def ack(m,n): if m == 0: return n+1 elif m &amp;gt; 0 and n == 0: return ack(m-1,1) elif m &amp;gt; 0 and n &amp;gt; 0: return ack(m-1,ack(m,n-1)) ack(3,4) 似乎看上去平平无奇，把它的计算过程展示出来：</description></item><item><title>Think Python Exercise 6.1</title><link>https://o5o.me/post/think_python_exercise_6.1/</link><pubDate>Tue, 03 Jan 2023 21:05:57 +0800</pubDate><guid>https://o5o.me/post/think_python_exercise_6.1/</guid><description>画出下面程序的堆栈图。这个程序的最终输出是什么?
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 def b(z): prod = a(z, z) print(z, prod) return prod def a(x, y): x = x + 1 return x * y def c(x, y, z): total = x + y + z square = b(total)**2 return square x = 1 y = x + 1 print(c(x, y+3, x+y)) 程序的最终输出：8100
应该没有特别的意义吧？</description></item><item><title>Think Python Exercise 11.2 字典方法setdefault</title><link>https://o5o.me/post/think_python_exercise_11.2/</link><pubDate>Tue, 03 Jan 2023 18:28:00 +0800</pubDate><guid>https://o5o.me/post/think_python_exercise_11.2/</guid><description>查看字典方法setdefault的文档, 并使用该方法写一个更简洁的invert_dict。
原来的函数的定义：
1 2 3 4 5 6 7 8 9 10 11 def invert_dict(d): &amp;#34;&amp;#34;&amp;#34;倒转一个字典，将原字典的值作为键，原字典的键作为值。 &amp;#34;&amp;#34;&amp;#34; inverse = dict() for key in d: val = d[key] if val not in inverse: inverse[val] = [key] #反转后，一个键可能对应多个值，所以把值放到列表里 else: inverse[val].append(key) #相当于给列表追加一个值。键val的值是一个列表。 return inverse 文档链接：这里
setdefault(key[, default]), 如果字典存在键 key ，返回它的值。如果不存在，插入值为 default 的键 key ，并返回 default 。 default 默认为 None。
1 2 3 4 5 6 7 8 9 10 def invert_dict(d): &amp;#34;&amp;#34;&amp;#34;倒转一个字典，将原字典的值作为键，原字典的键作为值。 &amp;#34;&amp;#34;&amp;#34; inverse = dict() for key in d: inverse[d[key]]=inverse.</description></item><item><title>Think Python Exercise 11.1</title><link>https://o5o.me/post/think_python_exercise_11.1/</link><pubDate>Tue, 03 Jan 2023 18:12:23 +0800</pubDate><guid>https://o5o.me/post/think_python_exercise_11.1/</guid><description>编写一函数,读取words.txt中的单词并存储为字典中的键。值是什么无所谓。然后,你可以使用in操作符检查一个字符串是否在字典中。
如果你做过练习 10.10 ,可以比较一下in操作符和二分查找的速度。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 def make_word_list(): word_list = [] fin = open(&amp;#39;words.txt&amp;#39;) for line in fin: word = line.strip() word_list.append(word) return word_list def dictword(w_li): word_dict = dict() for word in w_li: word_dict[word] = &amp;#39;ok&amp;#39; #题目说值是什么无所谓 return word_dict word_list = make_word_list() word_dict = dictword(word_list) &amp;#39;aha&amp;#39; in word_dict 我就不比较in操作符和二分查找的速度了。</description></item><item><title>Think Python Exercise 10.11</title><link>https://o5o.me/post/think_python_exercise_10.11/</link><pubDate>Mon, 02 Jan 2023 23:14:23 +0800</pubDate><guid>https://o5o.me/post/think_python_exercise_10.11/</guid><description>两个单词中如果一个是另一个的反转, 则二者被称为是 ‘‘反转词对’’。 编写一个函数,找出单词表中所有的反转词对。
解答：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 def read_word1(file_in): #来自10.9 word_list = [] for line in file_in: word = line.strip() word_list.append(word) return word_list def in_bisect(t,a): #来自10.10 &amp;#34;&amp;#34;&amp;#34;列表t，单词a，看单词是否在列表内，在的话返回单词的位置。 列表里的单词，必须是已经按字母顺序排好序的。 &amp;#34;&amp;#34;&amp;#34; s1 = int((len(t))/2) s = s1 #如果a在t内，s保存a的序数 while s1 &amp;gt; 0: if a == t[s1]: return s elif a &amp;gt; t[s1]: t = t[s1:] s1 = int(len(t)/2) #在循环过程中，确保s和s1所指的是同一个元素。 #print(a,&amp;#34;的位置大于&amp;#34;,s) s += s1 else: t = t[:s1] s1 = int(len(t)/2) #print(a,&amp;#34;的位置小于等于&amp;#34;,s) s -= s1 return None def findpairs(word_li): i = 0 for word in word_li: drow = word[::-1] #将单词里的字母按照相反的顺序排列 k = in_bisect(word_li[i:],drow) #写word_list[i:]目的是不让程序往前去找所谓的“反转词” if k: print(word,&amp;#39;和&amp;#39;,word_li[k+i]) i += 1 fin = open(&amp;#39;words.</description></item><item><title>Think Python Exercise 10.10 二分法</title><link>https://o5o.me/post/think_python_exercise_10.10/</link><pubDate>Mon, 02 Jan 2023 21:29:30 +0800</pubDate><guid>https://o5o.me/post/think_python_exercise_10.10/</guid><description>使用in运算符可以检查一个单词是否在单词表中, 但这很慢, 因为它是按顺序查找单词。
由于单词是按照字母顺序排序的,我们可以使用两分法 (也称二叉树搜索) 来加快速度, 类似于在字典中查找单词的方法。你从中间开始,如果你要找的单词在中间的单词之前,你查找前半部分,否则你查找后半部分。
不管怎样, 你都会将搜索范围减小一半。 如果单词表有 113,809 个单词, 你只需要 17 步就可以找到这个单词,或着得出单词不存在的结论。
编写一个叫做in_bisect的函数,接受一个已排序的列表和一个目标值作为参数,返回该值在列表中的位置,如果不存在则返回None。
或者你可以阅读bisect模块的文档并使用它!
解答：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 def in_bisect(t,a): &amp;#34;&amp;#34;&amp;#34;列表t，单词a，看单词是否在列表内，在的话返回单词的位置。 列表里的单词，必须是已经按字母顺序排好序的。 &amp;#34;&amp;#34;&amp;#34; s1 = int((len(t))/2) s = s1 #如果a在列表内，s保存a的下标 while s1 &amp;gt; 0: if a == t[s1]: return s elif a &amp;gt; t[s1]: t = t[s1:] s1 = int(len(t)/2) #在循环过程中，确保s和s1所指的是同一个元素。 #print(a,&amp;#34;的位置大于&amp;#34;,s) s += s1 else: t = t[:s1] s1 = int(len(t)/2) #print(a,&amp;#34;的位置小于等于&amp;#34;,s) s -= s1 return None t1 = [&amp;#39;a&amp;#39;,&amp;#39;b&amp;#39;,&amp;#39;c&amp;#39;,&amp;#39;d&amp;#39;,&amp;#39;e&amp;#39;,&amp;#39;f&amp;#39;,&amp;#39;g&amp;#39;,&amp;#39;h&amp;#39;,&amp;#39;i&amp;#39;,&amp;#39;j&amp;#39;,&amp;#39;k&amp;#39;,&amp;#39;l&amp;#39;,&amp;#39;m&amp;#39;,&amp;#39;n&amp;#39;,&amp;#39;o&amp;#39;,&amp;#39;p&amp;#39;,&amp;#39;q&amp;#39;] in_bisect(t1,&amp;#39;c&amp;#39;) s和s1这两个变量，保存的是列表元素的下标。在循环过程中，确保s和s1所指的是同一个元素，即：s保存的是元素在完整列表里的下标，s1保存的是元素在切片后的列表里的下标，在两个列表里，第s个元素和第s1个元素（都从0开始）是同一个元素。</description></item><item><title>Think Python Exercise 10.3</title><link>https://o5o.me/post/think_python_exercise_10.3/</link><pubDate>Mon, 02 Jan 2023 21:22:48 +0800</pubDate><guid>https://o5o.me/post/think_python_exercise_10.3/</guid><description>编写一个叫做middle的函数,接受一个列表作为参数,并返回一个除了第一个和最后一个元素的列表。例如:
&amp;gt;&amp;gt;&amp;gt; t = [1, 2, 3, 4] &amp;gt;&amp;gt;&amp;gt; middle(t) [2, 3] 解答：
1 2 3 4 5 def middle(t): return t[1:-1] t1 = [1,2,3,4] middle(t1)</description></item><item><title>Think Python Exercise 10.7</title><link>https://o5o.me/post/think_python_exercise_10.7/</link><pubDate>Mon, 02 Jan 2023 20:31:00 +0800</pubDate><guid>https://o5o.me/post/think_python_exercise_10.7/</guid><description>编写一个叫做 has_duplicates 的函数，接受一个列表作为参数，如果一个元素在列表中出现了不止一次，则返回 True 。这个函数不能改变原列表。
解答：
1 2 3 4 5 6 7 8 9 10 11 12 def has_duplicates(t): p = [] for i in t: if i not in p: p.append(i) else: return True return False t1 = [1,2,3] has_duplicates(t1)</description></item><item><title>Roam Research和Anki联用：动作配置</title><link>https://o5o.me/post/rr_km_anki_configuration_tutorial/</link><pubDate>Mon, 02 Jan 2023 01:07:10 +0800</pubDate><guid>https://o5o.me/post/rr_km_anki_configuration_tutorial/</guid><description>Roam Research是一个笔记软件，Anki是一个间隔重复软件。我在RR里写的笔记有复习需求，在Anki里的卡片有编辑、整理需求，所以以前的我就用Keyboard Maestro这个工具写了一个动作（Macro）来帮我将二者联系起来。
RR的笔记可以导出为Anki卡片（卡片仅用于复习、展示，所有的编辑都在笔记上完成），笔记更新，卡片能同步更新，笔记和卡片能相互跳转。
可以按下面的顺序进行配置（所需文件在文章最后），手把手教学请看视频：
【详细配置】Keyboard Maestro动作实现Roam Research笔记和Anki卡片的双向链接、跳转和同步更新，配置指南
Anki模板导入、修改 要改的地方就一处：修改模板里的RR graph名称。不改的话就没办法从Anki跳转回RR了。
KM动作导入、修改 要改的地方也就只有一处：把你的Anki牌组的名字填进去。
Anki插件安装 anki connect，插件代码：2055492159
禁用App Nap 从Mac OS X Mavericks开始，操作系统中引入了名为App Nap的功能。此功能导致某些打开（但不可见）的应用程序处于挂起状态。由于此行为会导致Anki Connect在前台有另一个窗口时停止工作，因此应禁用Anki的App Nap1。
在终端运行下面的命令即可。
1 2 3 defaults write net.ankiweb.dtop NSAppSleepDisabled -bool true defaults write net.ichi2.anki NSAppSleepDisabled -bool true defaults write org.qt-project.Qt.QtWebEngineCore NSAppSleepDisabled -bool true 最后 这就配置完成了，是不是很简单？quicker版的动作配置更简单，除了下载插件，啥都不用配置，自动配置。想想以前真的傻，我给quicker版的这个动作加了批量导入、多种挖空标记、多种方式排列的笔记导入、自动从Anki获取牌组列表、自动添加Anki模板等等功能，这些功能在我现在看来用途很小很小，但当时却花了大量时间去改动作、修bug，浪费了很多时间在完全没必要的事情上。
模板、动作下载链接: 百度网盘，提取码: 3tvu
希望能给看到这里的你带来一些帮助。
Notes for MacOS Users&amp;#160;&amp;#x21a9;&amp;#xfe0e;</description></item><item><title>Think Python Exercise 4.1</title><link>https://o5o.me/post/think_python_exercise_4.1/</link><pubDate>Sun, 01 Jan 2023 18:23:34 +0800</pubDate><guid>https://o5o.me/post/think_python_exercise_4.1/</guid><description>画一个执行 circle(bob,radius) 时的堆栈图（stack diagram），说明程序的各个状态。你可以手动进行计算，也可以在代码中加入打印语句。 “重构”一节中给出的 arc 函数版本并不太精确，因为圆形的线性近似（linear approximation）永远处在真正的圆形之外。因此，Turtle 总是和正确的终点相差几个像素。我的答案中展示了降低这个错误影响的一种方法。阅读其中的代码，看看你是否能够理解。如果你画一个堆栈图的话，你可能会更容易明白背后的原理。 先放上代码，得到代码过程可以看Think Python Exercise 4.0。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 import turtle import math def polyline(t,length,n,angle): for i in range(n): t.fd(length) t.lt(angle) def arc(t,r,angle): &amp;#34;&amp;#34;&amp;#34;angle取值范围是1~360，度数。 画出圆的一部分。 &amp;#34;&amp;#34;&amp;#34; arc_length = 2 * math.pi * r * angle / 360 n = int(arc_length / 3) + 1 step_length = arc_length / n step_angle = angle / n polyline(t,step_length,n,step_angle) def circle(t,r): arc(t,r,360) #circle是arc函数在角度angle取360时的特例 bob = turtle.</description></item><item><title>Think Python Exercise 4.0</title><link>https://o5o.me/post/think_python_exercise_4.0/</link><pubDate>Sun, 01 Jan 2023 16:04:43 +0800</pubDate><guid>https://o5o.me/post/think_python_exercise_4.0/</guid><description>写一个名为 square 的函数，接受一个名为 t 的形参，t 是一个海龟。这个函数应用这只海龟画一个正方形。 写一个函数调用，将 bob 作为实参传给 square ，然后再重新运行程序。
1 2 3 4 5 6 7 8 9 10 11 12 import turtle def square(t): for i in range(4): t.fd(100) t.lt(90) bob = turtle.Turtle() square(bob) turtle.mainloop() 给 square 增加另一个名为 length 的形参。修改函数体，使得正方形边的长度是 length ，然后修改函数调用，提供第二个实参。 重新运行程序。用一系列 length 值测试你的程序。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import turtle def square(t,length): for i in range(4): t.</description></item><item><title>Think Python Exercise 5.4</title><link>https://o5o.me/post/think_python_exercise_5.4/</link><pubDate>Sun, 01 Jan 2023 13:04:59 +0800</pubDate><guid>https://o5o.me/post/think_python_exercise_5.4/</guid><description>下面程序的输出是什么？画出展示程序每次打印输出时的堆栈图。
1 2 3 4 5 6 7 def recurse(n, s): if n == 0: print(s) else: recurse(n-1, n+s) recurse(3, 0) 如果你这样调用函数： recurse(-1,0) ，会有什么结果？ 请写一个文档字符串，解释调用该函数时需要了解的全部信息（仅此而已）。 解答：
我用obsidian的Excalidraw插件画了一个。
如果这样调用函数： recurse(-1,0)，Python会抛出一个递归错误：超过最大递归深度。
&amp;gt;&amp;gt;&amp;gt; recurse(-1,0) Traceback (most recent call last): File &amp;#34;&amp;lt;stdin&amp;gt;&amp;#34;, line 1, in &amp;lt;module&amp;gt; File &amp;#34;&amp;lt;stdin&amp;gt;&amp;#34;, line 5, in recurse File &amp;#34;&amp;lt;stdin&amp;gt;&amp;#34;, line 5, in recurse File &amp;#34;&amp;lt;stdin&amp;gt;&amp;#34;, line 5, in recurse [Previous line repeated 996 more times] RecursionError: maximum recursion depth exceeded 写一个文档字符串，解释调用该函数时需要了解的全部信息</description></item><item><title>正则表达式匹配HTML标签</title><link>https://o5o.me/post/regexps_match_html_tags/</link><pubDate>Sat, 31 Dec 2022 22:25:25 +0800</pubDate><guid>https://o5o.me/post/regexps_match_html_tags/</guid><description>最近在用SuperMemo渐进阅读旋元佑的《英语魔法师之语法俱乐部》这本语法书。我的阅读前流程是这样的：（括号内的是所用工具）
将epub电子书按章节分割（calibre-EpubSplit） 将需要阅读的章节导入SuperMemo（Quicker、pandoc、AutoHotkey） 在SuperMemo内将该章节分割成更小的卡片（鼠标右键-阅读-分割-分割文章） 统一将所得的所有卡片设为新材料（根卡片鼠标右键-处理选中分支-学习-忘记） 菜单栏-学习-阶段-新学材料（也可等当天复习完后根据提示进入） 问题在于，我所拥有的这本epub电子书，html标签很乱，导致我在导入SM后无法正确根据html标签分割文章，因此在导入SM前需要先整理epub文件的html标签。这也就是这篇文章的由来。
截取这本书的一个片段：
1 &amp;lt;p class=&amp;#34;calibre_16&amp;#34;&amp;gt;以上谈的是修饰动词专用的“方法、状态副词”，以及它在句中位置的变化原则。接下来看看其他种类的副词。&amp;lt;/p&amp;gt;&amp;lt;blockquote class=&amp;#34;calibre_5&amp;#34;&amp;gt;&amp;lt;blockquote class=&amp;#34;calibre2&amp;#34;&amp;gt;&amp;lt;blockquote class=&amp;#34;calibre2&amp;#34;&amp;gt;&amp;lt;blockquote class=&amp;#34;calibre2&amp;#34;&amp;gt;&amp;lt;blockquote class=&amp;#34;calibre_21&amp;#34;&amp;gt;&amp;lt;span class=&amp;#34;calibre1&amp;#34;&amp;gt;&amp;lt;span class=&amp;#34;bold&amp;#34;&amp;gt;&amp;lt;span class=&amp;#34;calibre_12&amp;#34;&amp;gt;强调语气的副词（Intensifiers)&amp;lt;/span&amp;gt;&amp;lt;/span&amp;gt;&amp;lt;/span&amp;gt;&amp;lt;/blockquote&amp;gt;&amp;lt;/blockquote&amp;gt;&amp;lt;/blockquote&amp;gt;&amp;lt;/blockquote&amp;gt;&amp;lt;a id=&amp;#34;filepos295095&amp;#34;&amp;gt;&amp;lt;/a&amp;gt;&amp;lt;/blockquote&amp;gt;&amp;lt;p class=&amp;#34;calibre_24&amp;#34;&amp;gt;这一类副词有一个特色：它在使用上很有弹性，&amp;lt;span class=&amp;#34;bold&amp;#34;&amp;gt;四种主要词类，包括名词、动词、形容词与副词都可以用它来修饰。&amp;lt;/span&amp;gt;认识这一点，才算真正弄清楚形容词与副词间的分工。这一类的副词又可以细分为以下三种：&amp;lt;/p&amp;gt; 所要做的是把下面这一段变为：&amp;lt;h2&amp;gt;强调语气的副词（Intensifiers)&amp;lt;/h2&amp;gt;，这样我就可以在SM里很方便地按h2标签分割内容。
1 &amp;lt;blockquote class=&amp;#34;calibre2&amp;#34;&amp;gt;&amp;lt;blockquote class=&amp;#34;calibre2&amp;#34;&amp;gt;&amp;lt;blockquote class=&amp;#34;calibre2&amp;#34;&amp;gt;&amp;lt;blockquote class=&amp;#34;calibre_21&amp;#34;&amp;gt;&amp;lt;span class=&amp;#34;calibre1&amp;#34;&amp;gt;&amp;lt;span class=&amp;#34;bold&amp;#34;&amp;gt;&amp;lt;span class=&amp;#34;calibre_12&amp;#34;&amp;gt;强调语气的副词（Intensifiers)&amp;lt;/span&amp;gt;&amp;lt;/span&amp;gt;&amp;lt;/span&amp;gt;&amp;lt;/blockquote&amp;gt;&amp;lt;/blockquote&amp;gt;&amp;lt;/blockquote&amp;gt;&amp;lt;/blockquote&amp;gt; 可以看到，一共是4个blockquote标签，3个span标签，那么我们可以先设法用正则匹配出一个起始blockquote标签，然后重复4次，匹配出一个起始span标签，然后重复3词，就能匹配出所有的起始标签了。
(&amp;lt;blockquote\s[^&amp;gt;]*&amp;#34;&amp;gt;){4}(&amp;lt;span\s[^&amp;gt;]*&amp;#34;&amp;gt;){3} 同样的道理，匹配所有的闭合标签。
(&amp;lt;\/span&amp;gt;){3}(&amp;lt;/blockquote&amp;gt;){4} 最后，标题可以用(.*?)匹配，把它们组合在一起，就成功匹配出了这段html代码。
(&amp;lt;blockquote\s[^&amp;gt;]*&amp;#34;&amp;gt;){4}(&amp;lt;span\s[^&amp;gt;]*&amp;#34;&amp;gt;){3}(.*?)(&amp;lt;\/span&amp;gt;){3}(&amp;lt;/blockquote&amp;gt;){4} 将其用下面的内容替换，内容就整理好了。
\n&amp;lt;h2&amp;gt;$3&amp;lt;/h2&amp;gt;\n 上面的正则，经过我的实践，是比较经济实惠的。以后如果有更好的方案，本文会继续更新。</description></item><item><title>Think Python Exercise 10.6</title><link>https://o5o.me/post/think_python_exercise_10.6/</link><pubDate>Sat, 31 Dec 2022 18:28:02 +0800</pubDate><guid>https://o5o.me/post/think_python_exercise_10.6/</guid><description>如果可以通过重排一个单词中字母的顺序，得到另外一个单词，那么称这两个单词是变位词。编写一个叫做 is_anagram 的函数，接受两个字符串作为参数， 如果它们是变位词则返回 True 。
解答：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 def is_anagram(s1,s2): t1 = list(s1) t2 = list(s2) #先把字符串转换成列表 if len(t1) == len(t2): #如果两个字符串长度都不一样，那么肯定不是变位词了 t1.sort() t2.sort() #按照同样的方式重新排序后，如果二者元素对应相等，那么它们就是变位词了 for i in range(len(t1)): if t1[i] == t2[i]: pass else: return False return True else: return False is_anagram(&amp;#39;abc&amp;#39;,&amp;#39;bac&amp;#39;)</description></item><item><title>Think Python Exercise 10.5</title><link>https://o5o.me/post/think_python_exercise_10.5/</link><pubDate>Sat, 31 Dec 2022 17:50:04 +0800</pubDate><guid>https://o5o.me/post/think_python_exercise_10.5/</guid><description>编写一个叫做is_sorted的函数，接受一个列表作为参数，如果列表是递增排列的则返回 True ，否则返回False。 例如：
&amp;gt;&amp;gt;&amp;gt; is_sorted([1, 2, 2]) True &amp;gt;&amp;gt;&amp;gt; is_sorted([&amp;#39;b&amp;#39;, &amp;#39;a&amp;#39;]) False 分析：
可以先对列表用.sort()方法进行递增排列，如果递增排列后的列表和原列表的元素都对应相同，说明原列表本身就是递增排列的。
一个错误的写法：
1 2 3 4 5 6 7 8 9 def is_sorted(t): t_copy = t[:] print(t_copy) if t_copy == t.sort(): return True else: return False is_sorted([1, 2, 2]) 程序没有报错，但它仍是错的，因为，我们要比较的是两个列表里的元素对应相同，而不是看这两个变量是不是指向同一个列表。t_copy和t.sort()肯定不指向同一个列表，但它们的元素对应相同。因此我们不能用t_copy == t.sort()这样的方法来比较。可以这样做：
1 2 3 4 5 6 7 8 9 10 11 def is_sorted(t): t_copy = t[:] for i in range(len(t)): if t_copy[i] == t[i]: #如果递增排列后的列表和原列表的元素都对应相同，说明原列表本身就是递增排列的 pass else: return False return True is_sorted([1, 2, 2]) 还可以用另一种方法实现：从第二个元素开始，依次和前面一个元素比较大小。</description></item><item><title>Think Python Exercise 10.4</title><link>https://o5o.me/post/think_python_exercise_10.4/</link><pubDate>Sat, 31 Dec 2022 17:29:11 +0800</pubDate><guid>https://o5o.me/post/think_python_exercise_10.4/</guid><description>编写一个叫做 chop 的函数，接受一个列表作为参数，移除第一个和最后一个元素，并返回None。例如：
&amp;gt;&amp;gt;&amp;gt; t = [1, 2, 3, 4] &amp;gt;&amp;gt;&amp;gt; chop(t) &amp;gt;&amp;gt;&amp;gt; t [2, 3] 分析：
一顿操作猛如虎：（错的）
1 2 3 4 5 6 7 8 def chop(t): t = t[1:-1] t1 = [1, 2, 3, 4] chop(t1) t1 为什么t1没变化？是我列表切片用错了吗，再试试：（还是错的）
1 2 3 4 5 6 7 8 def chop(t): t = t[1:len(t)-2] t1 = [1, 2, 3, 4] chop(t1) t1 可以看到，t1还是没变化，为什么？为什么这样是错的？
不要被迷惑了，当一个列表t1传递给一个函数时，t1和形参t共同指向同一个列表，但当函数内部t重新赋值后，t指向了一个新的列表，而t1依然指向原来的列表，那么当函数运行结束后，t1的值当然还是原来的啦。
由于题目要求函数不能有返回值，可以使用下面的做法：
1 2 3 4 5 6 7 8 9 def chop(t): del t[0] del t[-1] t1 = [1, 2, 3, 4] chop(t1) t1 如果函数可以有返回值，可以这样写：</description></item><item><title>Think Python Exercise 10.9</title><link>https://o5o.me/post/think_python_exercise_10.9/</link><pubDate>Sat, 31 Dec 2022 16:59:00 +0800</pubDate><guid>https://o5o.me/post/think_python_exercise_10.9/</guid><description>编写一个函数，读取文件 words.txt ，建立一个列表,其中每个单词为一个元素。
编写两个版本，一个使用 append 方法，另一个使用 t = t + [x] 。那个版本运行得慢？为什么？
解答：
在 jupyter 中的一个代码单元（cell）中，代码第一行写上%%time或%%timeit，即可计算代码的运行时间。
版本1：
1 2 3 4 5 6 7 8 9 10 11 12 %%time def read_word1(file_in): word_list = [] for line in file_in: word = line.strip() word_list.append(word) return word_list fin = open(&amp;#39;words.txt&amp;#39;) a = read_word1(fin) 运行结果：
CPU times: user 85.3 ms, sys: 0 ns, total: 85.3 ms Wall time: 88.4 ms
版本2：
1 2 3 4 5 6 7 8 9 10 11 12 %%time def read_word2(file_in): word_list = [] for line in file_in: word = line.</description></item><item><title>Think Python Exercise 10.2</title><link>https://o5o.me/post/think_python_exercise_10.2/</link><pubDate>Sat, 31 Dec 2022 16:42:52 +0800</pubDate><guid>https://o5o.me/post/think_python_exercise_10.2/</guid><description>编写一个叫做 cumsum 的函数，接受一个由数值组成的列表，并返回累加和；即一个新列表，其中第i个元素是原列表中前i+1个元素的和（注意i是从0开始的）。 例如：
&amp;gt;&amp;gt;&amp;gt; t = [1, 2, 3] &amp;gt;&amp;gt;&amp;gt; cumsum(t) [1, 3, 6] 解答：
1 2 3 4 5 6 7 8 9 10 11 12 def cumsum(t): numsum = [] for i in range(len(t)): numsum.append(sum(t[:i+1])) #对t的前i+1个元素求和（注意i是从0开始，所以第i个元素是第i+1个元素），然后追加到新列表里 return numsum t = [1, 2, 3] print(cumsum(t)) t = [3,3,6,9,10] print(cumsum(t))</description></item><item><title>Think Python Exercise 10.1</title><link>https://o5o.me/post/think_python_exercise_10.1/</link><pubDate>Sat, 31 Dec 2022 16:22:37 +0800</pubDate><guid>https://o5o.me/post/think_python_exercise_10.1/</guid><description>编写一个叫做 nested_sum 的函数，接受一个由一些整数列表构成的列表作为参数，并将所有嵌套列表中的元素相加。例如：
&amp;gt;&amp;gt;&amp;gt; t = [[1, 2], [3], [4, 5, 6]] &amp;gt;&amp;gt;&amp;gt; nested_sum(t) 21 解答：
可以分别对每个子列表求和，再对得到的各个和求和。也可以先把各个子列表合并起来，然后对得到的列表求和。
1 2 3 4 5 6 7 8 9 def nested_sum(t): c = [] for i in t: c = c + i #把t列表里的各个列表合并成一个列表 return sum(c) t = [[1, 2], [3], [4, 5, 6]] nested_sum(t)</description></item><item><title>游戏手柄用于SuperMemo复习</title><link>https://o5o.me/post/supermemo-gamepad/</link><pubDate>Fri, 30 Dec 2022 12:23:10 +0800</pubDate><guid>https://o5o.me/post/supermemo-gamepad/</guid><description>在用SuperMemo复习时，一边要移动鼠标，浏览卡片内容，一边要用键盘评分、修改卡片内容，容易手忙脚乱。把评分常用的按键和其他一些按键映射到游戏手柄上可以稍微方便一点。
游戏手柄：八位堂Zero2小手柄。 软件：AntiMicroX
手柄连接计算机 看说明书即可。
在AntiMicroX中设定快捷键 打开软件后，点手柄上的按键，可以看到有的按键映射是错的，点软件窗口左下角的“游戏控制器映射”，先矫正一遍。
然后在软件主窗口中找到你想设定快捷键的按键（可以通过按手柄上的对应按键确定它的位置），鼠标点击，设定快捷键即可。
在我的SuperMemo中，目前是有很多的摘录卡片，以及很少的填空题卡片。我习惯于一边复习一边编辑卡片内容，比如把一段紧凑的话分成一行一行的句子，修改一些措辞。
在SM中，当我的鼠标点击了卡片，可以看作我进入了“编辑模式”，如果这张卡片看完了，想进入下一张卡片，我需要先退出“编辑模式”（按ESC），再按回车键。可以把这两个键简化为一个键，在游戏手柄上按一次，无论你是不是在“编辑模式”，都可以跳转到下一张卡片。
在AntiMicroX窗口中鼠标点击按键，在弹出的窗口中点击“高级选项”，又弹出一个窗口，在“分配”栏里点击“小方块”（里面出现&amp;quot;&amp;hellip;&amp;quot;），这时候在键盘上输入想设定的按键。设定两个按键，那么点击游戏手柄上的按键时，这两个按键会依次执行。
我的按键设定 设定原则是，使用越多的按键放在越容易按的位置。
使用手柄时我习惯竖着拿。除了十字方向键（我不用），最不方便按的是左肩键，其次是右肩键，然后是开始键和选择键。
因此，我的设定是：
左肩键，评分5。一是用的少，二来对一张卡片评分5时需要调整手的握姿，这样就会很慎重、很有仪式感。如果这种情况下还非要把一张卡片评分为5，说明真的掌握的很好了。
右肩键，评分2。答错时按的。
A，评分3/ENTER。最容易按的键。因为在评分时，按Enter键的效果和按3是一样的，所以设定为Enter，这样在复习时就不用频繁移动手指了。
X，评分1。
B，评分4。
Y，ESC+Enter，切换到下一张卡片。
为什么A设定了Enter，这里还要再设定一个ESC+Enter呢？或者能不能都用ESC+Enter呢？你复习的时候亲手去操作一下就明白了。评分时按ESC+Enter没效果；阅读并编辑卡片时，按Enter不会跳转到下一张卡片，而是在卡片里添加一个空行。
这是一件很主观的事情，怎么舒服怎么来。
全文完。</description></item><item><title>Think Python Exercise 9.6</title><link>https://o5o.me/post/think_python_exercise_9.6/</link><pubDate>Thu, 29 Dec 2022 17:45:12 +0800</pubDate><guid>https://o5o.me/post/think_python_exercise_9.6/</guid><description>编写一个名为is_abecedarian 的函数, 如果单词中的字符以字符表的顺序出现 (允许重复字符),则返回True。有多少个具备这种特征的单词?
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 def word_abcde(word): alphabets = &amp;#34;abcdefghijklmnopqrstuvwxyz&amp;#34; i = 0 front = 0 #前一个字母的序数 mine = 0 #当前字母的序数 while i &amp;lt; len(word): index = 0 while index &amp;lt; len(alphabets): # print(i,word[i],index,alphabets[index]) if word[i] == alphabets[index]: mine = index if mine &amp;lt; front: return False else: front = mine break index += 1 i += 1 return True def is_abecedarian(file_in): count = 0 for line in file_in: word = line.</description></item><item><title>Think Python Exercise 9.5</title><link>https://o5o.me/post/think_python_exercise_9.5/</link><pubDate>Thu, 29 Dec 2022 16:05:12 +0800</pubDate><guid>https://o5o.me/post/think_python_exercise_9.5/</guid><description>编写一个名为uses_all的函数,接受一个单词和一个必须使用的字符组成的字符串。如果该单词包括此字符串中的全部字符至少一次,则返回True。你能统计出多少单词包含了所有的元音字符aeiou吗?如果换成aeiouy 呢?
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 def uses_all(word, muststr): for i in muststr: count = 0 index = 0 while index &amp;lt; len(word): if i == word[index]: break index += 1 if index == len(word): return False return True def count_word(file_in, als): count = 0 for line in file_in: word = line.</description></item><item><title>Think Python Exercise 9.4</title><link>https://o5o.me/post/think_python_exercise_9.4/</link><pubDate>Thu, 29 Dec 2022 15:30:12 +0800</pubDate><guid>https://o5o.me/post/think_python_exercise_9.4/</guid><description>编写一个名为 avoids 的函数，接受一个单词和一个指定禁止使用字符的字符串，如果单词中不包含任意被禁止的字符，则返回True 。
修改你的程序，提示用户输入一个禁止使用的字符，然后打印不包含这些字符的单词的数量。你能找到一个5个禁止使用字符的组合，使得其排除的单词数目最少么？
你能找到一个&amp;quot;5个禁止使用字符&amp;quot;的组合，使得其排除的单词数目最少么？ 分析：从26个字母中挑选5个字母构成一个组合，打印不包含这些字母的单词的数量，看哪个组合下被排除出去的单词数目最少。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 def avoids(word,ause): #ause，avoid use for i in ause: for letter in word: if letter == i: return False return True def has_no_string(file_in, nals): #nals指的是no alphabets，字母 count_nals = 0 #不含用户指定的各个字符的单词的个数 for line in file_in: word = line.strip() if avoids(word,nals): count_nals += 1 print(&amp;#34;不含&amp;#34;,nals,&amp;#34;的单词有&amp;#34;,count_nals,&amp;#34;个&amp;#34;) text = input(&amp;#34;请输入一个禁止使用的字符串，字符串里的字母都不会出现在单词中\n&amp;#34;) fin = open(&amp;#39;words.</description></item><item><title>Think Python Exercise 9.3</title><link>https://o5o.me/post/think_python_exercise_9.3/</link><pubDate>Thu, 29 Dec 2022 15:28:12 +0800</pubDate><guid>https://o5o.me/post/think_python_exercise_9.3/</guid><description>编写一个名为 avoids 的函数，接受一个单词和一个指定禁止使用字符的字符串，如果单词中不包含任意被禁止的字符，则返回True 。
修改你的程序，提示用户输入一个禁止使用的字符，然后打印不包含这些字符的单词的数量。你能找到一个5个禁止使用字符的组合，使得其排除的单词数目最少么？
你能找到一个&amp;quot;5个禁止使用字符&amp;quot;的组合，使得其排除的单词数目最少么？ 分析：从26个字母中挑选5个字母构成一个组合，打印不包含这些字母的单词的数量，看哪个组合下被排除出去的单词数目最少。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 def avoids(word,ause): #ause，avoid use for i in ause: for letter in word: if letter == i: return False return True def has_no_string(file_in, nals): #nals指的是no alphabets，字母 count_nals = 0 #不含用户指定的各个字符的单词的个数 for line in file_in: word = line.strip() if avoids(word,nals): count_nals += 1 print(&amp;#34;不含&amp;#34;,nals,&amp;#34;的单词有&amp;#34;,count_nals,&amp;#34;个&amp;#34;) text = input(&amp;#34;请输入一个禁止使用的字符串，字符串里的字母都不会出现在单词中\n&amp;#34;) fin = open(&amp;#39;words.</description></item><item><title>Think Python Exercise 9.2</title><link>https://o5o.me/post/think_python_exercise_9.2/</link><pubDate>Thu, 29 Dec 2022 15:27:12 +0800</pubDate><guid>https://o5o.me/post/think_python_exercise_9.2/</guid><description>1939年，Ernest Vincent Wright出版了一本名为 《Gadsby》 的小说，该小说里完全没有使用字符“e”。由于“e”是最常用的英文字符，因此这并不容易做到。
事实上，不使用这个最常用的符号(字符e)来构建一个孤立的想法是很难的。开始进展缓慢，但是经过有意识的、长时间的训练，你可以逐渐地熟练。
好啦，不再说题外话了（让我们开始编程练习）。
写一个叫做has_no_e的函数，如果给定的单词中不包含字符“e”，其返回 True 。
修改上一节中的程序，只打印不包含“e”的单词，并且计算列表中不含“e”单词的比例。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 fin = open(&amp;#39;words.txt&amp;#39;) def has_no_e(file_in): count_ne = 0 #不含e的单词的个数 count = 0 #总单词个数 for line in file_in: word = line.strip() index = 0 while index &amp;lt; len(word): if word[index] == &amp;#39;e&amp;#39;: break else: index = index + 1 if index == len(word): # print(word) #因为单词比较多，不一个个列出来了 count_ne = count_ne + 1 count = count + 1 print(&amp;#34;不含e的单词有&amp;#34;,count_ne,&amp;#34;个&amp;#34;,&amp;#34;单词一共有&amp;#34;,count,&amp;#34;个&amp;#34;,&amp;#34;不含“e”单词的比例为&amp;#34;,count_ne/count*100,&amp;#34;%&amp;#34;) has_no_e(fin) 上面是一个字母一个字母判断单词是不是包含‘e’的，下面是在 if 中使用 in 操作符简化后的方案：</description></item><item><title>Think Python Exercise 9.1</title><link>https://o5o.me/post/think_python_exercise_9.1/</link><pubDate>Wed, 28 Dec 2022 21:48:12 +0800</pubDate><guid>https://o5o.me/post/think_python_exercise_9.1/</guid><description>编程写一个程序，使得它可以读取 words.txt　，然后只打印出那些长度超过20个字符的单词(不包括空格)。
1 2 3 4 5 6 fin = open(&amp;#39;words.txt&amp;#39;) for line in fin: word = line.strip() if len(word) &amp;gt; 20: print(word)</description></item></channel></rss>