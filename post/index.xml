<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on o5o</title><link>https://o5o.me/post/</link><description>Recent content in Posts on o5o</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Sat, 31 Dec 2022 22:25:25 +0800</lastBuildDate><atom:link href="https://o5o.me/post/index.xml" rel="self" type="application/rss+xml"/><item><title>正则表达式匹配HTML标签</title><link>https://o5o.me/post/regexps_match_html_tags/</link><pubDate>Sat, 31 Dec 2022 22:25:25 +0800</pubDate><guid>https://o5o.me/post/regexps_match_html_tags/</guid><description>最近在用SuperMemo渐进阅读旋元佑的《英语魔法师之语法俱乐部》这本语法书。我的阅读前流程是这样的：（括号内的是所用工具）
将epub电子书按章节分割（calibre-EpubSplit） 将需要阅读的章节导入SuperMemo（Quicker、pandoc、AutoHotkey） 在SuperMemo内将该章节分割成更小的卡片（鼠标右键-阅读-分割-分割文章） 统一将所得的所有卡片设为新材料（根卡片鼠标右键-处理选中分支-学习-忘记） 菜单栏-学习-阶段-新学材料（也可等当天复习完后根据提示进入） 问题在于，我所拥有的这本epub电子书，html标签很乱，导致我在导入SM后无法正确根据html标签分割文章，因此在导入SM前需要先整理epub文件的html标签。这也就是这篇文章的由来。
截取这本书的一个片段：
1 &amp;lt;p class=&amp;#34;calibre_16&amp;#34;&amp;gt;以上谈的是修饰动词专用的“方法、状态副词”，以及它在句中位置的变化原则。接下来看看其他种类的副词。&amp;lt;/p&amp;gt;&amp;lt;blockquote class=&amp;#34;calibre_5&amp;#34;&amp;gt;&amp;lt;blockquote class=&amp;#34;calibre2&amp;#34;&amp;gt;&amp;lt;blockquote class=&amp;#34;calibre2&amp;#34;&amp;gt;&amp;lt;blockquote class=&amp;#34;calibre2&amp;#34;&amp;gt;&amp;lt;blockquote class=&amp;#34;calibre_21&amp;#34;&amp;gt;&amp;lt;span class=&amp;#34;calibre1&amp;#34;&amp;gt;&amp;lt;span class=&amp;#34;bold&amp;#34;&amp;gt;&amp;lt;span class=&amp;#34;calibre_12&amp;#34;&amp;gt;强调语气的副词（Intensifiers)&amp;lt;/span&amp;gt;&amp;lt;/span&amp;gt;&amp;lt;/span&amp;gt;&amp;lt;/blockquote&amp;gt;&amp;lt;/blockquote&amp;gt;&amp;lt;/blockquote&amp;gt;&amp;lt;/blockquote&amp;gt;&amp;lt;a id=&amp;#34;filepos295095&amp;#34;&amp;gt;&amp;lt;/a&amp;gt;&amp;lt;/blockquote&amp;gt;&amp;lt;p class=&amp;#34;calibre_24&amp;#34;&amp;gt;这一类副词有一个特色：它在使用上很有弹性，&amp;lt;span class=&amp;#34;bold&amp;#34;&amp;gt;四种主要词类，包括名词、动词、形容词与副词都可以用它来修饰。&amp;lt;/span&amp;gt;认识这一点，才算真正弄清楚形容词与副词间的分工。这一类的副词又可以细分为以下三种：&amp;lt;/p&amp;gt; 所要做的是把下面这一段变为：&amp;lt;h2&amp;gt;强调语气的副词（Intensifiers)&amp;lt;/h2&amp;gt;，这样我就可以在SM里很方便地按h2标签分割内容。
1 &amp;lt;blockquote class=&amp;#34;calibre2&amp;#34;&amp;gt;&amp;lt;blockquote class=&amp;#34;calibre2&amp;#34;&amp;gt;&amp;lt;blockquote class=&amp;#34;calibre2&amp;#34;&amp;gt;&amp;lt;blockquote class=&amp;#34;calibre_21&amp;#34;&amp;gt;&amp;lt;span class=&amp;#34;calibre1&amp;#34;&amp;gt;&amp;lt;span class=&amp;#34;bold&amp;#34;&amp;gt;&amp;lt;span class=&amp;#34;calibre_12&amp;#34;&amp;gt;强调语气的副词（Intensifiers)&amp;lt;/span&amp;gt;&amp;lt;/span&amp;gt;&amp;lt;/span&amp;gt;&amp;lt;/blockquote&amp;gt;&amp;lt;/blockquote&amp;gt;&amp;lt;/blockquote&amp;gt;&amp;lt;/blockquote&amp;gt; 可以看到，一共是4个blockquote标签，3个span标签，那么我们可以先设法用正则匹配出一个起始blockquote标签，然后重复4次，匹配出一个起始span标签，然后重复3词，就能匹配出所有的起始标签了。
(&amp;lt;blockquote\s[^&amp;gt;]*&amp;#34;&amp;gt;){4}(&amp;lt;span\s[^&amp;gt;]*&amp;#34;&amp;gt;){3} 同样的道理，匹配所有的闭合标签。
(&amp;lt;\/span&amp;gt;){3}(&amp;lt;/blockquote&amp;gt;){4} 最后，标题可以用(.*?)匹配，把它们组合在一起，就成功匹配出了这段html代码。
(&amp;lt;blockquote\s[^&amp;gt;]*&amp;#34;&amp;gt;){4}(&amp;lt;span\s[^&amp;gt;]*&amp;#34;&amp;gt;){3}(.*?)(&amp;lt;\/span&amp;gt;){3}(&amp;lt;/blockquote&amp;gt;){4} 将其用下面的内容替换，内容就整理好了。
\n&amp;lt;h2&amp;gt;$3&amp;lt;/h2&amp;gt;\n 上面的正则，经过我的实践，是比较经济实惠的。以后如果有更好的方案，本文会继续更新。</description></item><item><title>Think Python Exercise 10.6</title><link>https://o5o.me/post/think_python_exercise_10.6/</link><pubDate>Sat, 31 Dec 2022 18:28:02 +0800</pubDate><guid>https://o5o.me/post/think_python_exercise_10.6/</guid><description>如果可以通过重排一个单词中字母的顺序，得到另外一个单词，那么称这两个单词是变位词。编写一个叫做 is_anagram 的函数，接受两个字符串作为参数， 如果它们是变位词则返回 True 。
解答：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 def is_anagram(s1,s2): t1 = list(s1) t2 = list(s2) #先把字符串转换成列表 if len(t1) == len(t2): #如果两个字符串长度都不一样，那么肯定不是变位词了 t1.sort() t2.sort() #按照同样的方式重新排序后，如果二者元素对应相等，那么它们就是变位词了 for i in range(len(t1)): if t1[i] == t2[i]: pass else: return False return True else: return False is_anagram(&amp;#39;abc&amp;#39;,&amp;#39;bac&amp;#39;)</description></item><item><title>Think Python Exercise 10.5</title><link>https://o5o.me/post/think_python_exercise_10.5/</link><pubDate>Sat, 31 Dec 2022 17:50:04 +0800</pubDate><guid>https://o5o.me/post/think_python_exercise_10.5/</guid><description>编写一个叫做is_sorted的函数，接受一个列表作为参数，如果列表是递增排列的则返回 True ，否则返回False。 例如：
&amp;gt;&amp;gt;&amp;gt; is_sorted([1, 2, 2]) True &amp;gt;&amp;gt;&amp;gt; is_sorted([&amp;#39;b&amp;#39;, &amp;#39;a&amp;#39;]) False 分析：
可以先对列表用.sort()方法进行递增排列，如果递增排列后的列表和原列表的元素都对应相同，说明原列表本身就是递增排列的。
一个错误的写法：
1 2 3 4 5 6 7 8 9 def is_sorted(t): t_copy = t[:] print(t_copy) if t_copy == t.sort(): return True else: return False is_sorted([1, 2, 2]) 程序没有报错，但它仍是错的，因为，我们要比较的是两个列表里的元素对应相同，而不是看这两个变量是不是指向同一个列表。t_copy和t.sort()肯定不指向同一个列表，但它们的元素对应相同。因此我们不能用t_copy == t.sort()这样的方法来比较。可以这样做：
1 2 3 4 5 6 7 8 9 10 11 def is_sorted(t): t_copy = t[:] for i in range(len(t)): if t_copy[i] == t[i]: #如果递增排列后的列表和原列表的元素都对应相同，说明原列表本身就是递增排列的 pass else: return False return True is_sorted([1, 2, 2]) 还可以用另一种方法实现：</description></item><item><title>Think Python Exercise 10.4</title><link>https://o5o.me/post/think_python_exercise_10.4/</link><pubDate>Sat, 31 Dec 2022 17:29:11 +0800</pubDate><guid>https://o5o.me/post/think_python_exercise_10.4/</guid><description>编写一个叫做 chop 的函数，接受一个列表作为参数，移除第一个和最后一个元素，并返回None。例如：
&amp;gt;&amp;gt;&amp;gt; t = [1, 2, 3, 4] &amp;gt;&amp;gt;&amp;gt; chop(t) &amp;gt;&amp;gt;&amp;gt; t [2, 3] 分析：
一顿操作猛如虎：（错的）
1 2 3 4 5 6 7 8 def chop(t): t = t[1:-1] t1 = [1, 2, 3, 4] chop(t1) t1 为什么t1没变化？是我列表切片用错了吗，再试试：（还是错的）
1 2 3 4 5 6 7 8 def chop(t): t = t[1:len(t)-2] t1 = [1, 2, 3, 4] chop(t1) t1 可以看到，t1还是没变化，为什么？为什么这样是错的？
不要被迷惑了，当一个列表t1传递给一个函数时，t1和形参t共同指向同一个列表，但当函数内部t重新赋值后，t指向了一个新的列表，而t1依然指向原来的列表，那么当函数运行结束后，t1的值当然还是原来的啦。
由于题目要求函数不能有返回值，可以使用下面的做法：
1 2 3 4 5 6 7 8 9 def chop(t): del t[0] del t[-1] t1 = [1, 2, 3, 4] chop(t1) t1 如果函数可以有返回值，可以这样写：</description></item><item><title>Think Python Exercise 10.3</title><link>https://o5o.me/post/think_python_exercise_10.3/</link><pubDate>Sat, 31 Dec 2022 16:59:00 +0800</pubDate><guid>https://o5o.me/post/think_python_exercise_10.3/</guid><description>编写一个函数，读取文件 words.txt ，建立一个列表,其中每个单词为一个元素。
编写两个版本，一个使用 append 方法，另一个使用 t = t + [x] 。那个版本运行得慢？为什么？
解答：
在 jupyter 中的一个代码单元（cell）中，代码第一行写上%%time或%%timeit，即可计算代码的运行时间。
版本1：
1 2 3 4 5 6 7 8 9 10 11 12 %%time def read_word1(file_in): word_list = [] for line in file_in: word = line.strip() word_list.append(word) return word_list fin = open(&amp;#39;words.txt&amp;#39;) a = read_word1(fin) 运行结果：
CPU times: user 85.3 ms, sys: 0 ns, total: 85.3 ms Wall time: 88.4 ms
版本2：
1 2 3 4 5 6 7 8 9 10 11 12 %%time def read_word2(file_in): word_list = [] for line in file_in: word = line.</description></item><item><title>Think Python Exercise 10.2</title><link>https://o5o.me/post/think_python_exercise_10.2/</link><pubDate>Sat, 31 Dec 2022 16:42:52 +0800</pubDate><guid>https://o5o.me/post/think_python_exercise_10.2/</guid><description>编写一个叫做 cumsum 的函数，接受一个由数值组成的列表，并返回累加和；即一个新列表，其中第i个元素是原列表中前i+1个元素的和（注意i是从0开始的）。 例如：
&amp;gt;&amp;gt;&amp;gt; t = [1, 2, 3] &amp;gt;&amp;gt;&amp;gt; cumsum(t) [1, 3, 6] 解答：
1 2 3 4 5 6 7 8 9 10 11 12 def cumsum(t): numsum = [] for i in range(len(t)): numsum.append(sum(t[:i+1])) #对t的前i+1个元素求和（注意i是从0开始，所以第i个元素是第i+1个元素），然后追加到新列表里 return numsum t = [1, 2, 3] print(cumsum(t)) t = [3,3,6,9,10] print(cumsum(t))</description></item><item><title>Think Python Exercise 10.1</title><link>https://o5o.me/post/think_python_exercise_10.1/</link><pubDate>Sat, 31 Dec 2022 16:22:37 +0800</pubDate><guid>https://o5o.me/post/think_python_exercise_10.1/</guid><description>编写一个叫做 nested_sum 的函数，接受一个由一些整数列表构成的列表作为参数，并将所有嵌套列表中的元素相加。例如：
&amp;gt;&amp;gt;&amp;gt; t = [[1, 2], [3], [4, 5, 6]] &amp;gt;&amp;gt;&amp;gt; nested_sum(t) 21 解答：
可以分别对每个子列表求和，再对得到的各个和求和。也可以先把各个子列表合并起来，然后对得到的列表求和。
1 2 3 4 5 6 7 8 9 def nested_sum(t): c = [] for i in t: c = c + i #把t列表里的各个列表合并成一个列表 return sum(c) t = [[1, 2], [3], [4, 5, 6]] nested_sum(t)</description></item><item><title>游戏手柄用于SuperMemo复习</title><link>https://o5o.me/post/supermemo-gamepad/</link><pubDate>Fri, 30 Dec 2022 12:23:10 +0800</pubDate><guid>https://o5o.me/post/supermemo-gamepad/</guid><description>在用SuperMemo复习时，一边要移动鼠标，浏览卡片内容，一边要用键盘评分、修改卡片内容，容易手忙脚乱。把评分常用的按键和其他一些按键映射到游戏手柄上可以稍微方便一点。
游戏手柄：八位堂Zero2小手柄。 软件：AntiMicroX
手柄连接计算机 看说明书即可。
在AntiMicroX中设定快捷键 打开软件后，点手柄上的按键，可以看到有的按键映射是错的，点软件窗口左下角的“游戏控制器映射”，先矫正一遍。
然后在软件主窗口中找到你想设定快捷键的按键（可以通过按手柄上的对应按键确定它的位置），鼠标点击，设定快捷键即可。
在我的SuperMemo中，目前是有很多的摘录卡片，以及很少的填空题卡片。我习惯于一边复习一边编辑卡片内容，比如把一段紧凑的话分成一行一行的句子，修改一些措辞。
在SM中，当我的鼠标点击了卡片，可以看作我进入了“编辑模式”，如果这张卡片看完了，想进入下一张卡片，我需要先退出“编辑模式”（按ESC），再按回车键。可以把这两个键简化为一个键，在游戏手柄上按一次，无论你是不是在“编辑模式”，都可以跳转到下一张卡片。
在AntiMicroX窗口中鼠标点击按键，在弹出的窗口中点击“高级选项”，又弹出一个窗口，在“分配”栏里点击“小方块”（里面出现&amp;quot;&amp;hellip;&amp;quot;），这时候在键盘上输入想设定的按键。设定两个按键，那么点击游戏手柄上的按键时，这两个按键会依次执行。
我的按键设定 设定原则是，使用越多的按键放在越容易按的位置。
使用手柄时我习惯竖着拿。除了十字方向键（我不用），最不方便按的是左肩键，其次是右肩键，然后是开始键和选择键。
因此，我的设定是：
左肩键，评分5。一是用的少，二来对一张卡片评分5时需要调整手的握姿，这样就会很慎重、很有仪式感。如果这种情况下还非要把一张卡片评分为5，说明真的掌握的很好了。
右肩键，评分2。答错时按的。
A，评分3/ENTER。最容易按的键。因为在评分时，按Enter键的效果和按3是一样的，所以设定为Enter，这样在复习时就不用频繁移动手指了。
X，评分1。
B，评分4。
Y，ESC+Enter，切换到下一张卡片。
为什么A设定了Enter，这里还要再设定一个ESC+Enter呢？或者能不能都用ESC+Enter呢？你复习的时候亲手去操作一下就明白了。评分时按ESC+Enter没效果；阅读并编辑卡片时，按Enter不会跳转到下一张卡片，而是在卡片里添加一个空行。
这是一件很主观的事情，怎么舒服怎么来。
全文完。</description></item><item><title>Think Python Exercise 9.6</title><link>https://o5o.me/post/think_python_exercise_9.6/</link><pubDate>Thu, 29 Dec 2022 17:45:12 +0800</pubDate><guid>https://o5o.me/post/think_python_exercise_9.6/</guid><description>编写一个名为is_abecedarian 的函数, 如果单词中的字符以字符表的顺序出现 (允许重复字符),则返回True。有多少个具备这种特征的单词?
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 def word_abcde(word): alphabets = &amp;#34;abcdefghijklmnopqrstuvwxyz&amp;#34; i = 0 front = 0 #前一个字母的序数 mine = 0 #当前字母的序数 while i &amp;lt; len(word): index = 0 while index &amp;lt; len(alphabets): # print(i,word[i],index,alphabets[index]) if word[i] == alphabets[index]: mine = index if mine &amp;lt; front: return False else: front = mine break index += 1 i += 1 return True def is_abecedarian(file_in): count = 0 for line in file_in: word = line.</description></item><item><title>Think Python Exercise 9.5</title><link>https://o5o.me/post/think_python_exercise_9.5/</link><pubDate>Thu, 29 Dec 2022 16:05:12 +0800</pubDate><guid>https://o5o.me/post/think_python_exercise_9.5/</guid><description>编写一个名为uses_all的函数,接受一个单词和一个必须使用的字符组成的字符串。如果该单词包括此字符串中的全部字符至少一次,则返回True。你能统计出多少单词包含了所有的元音字符aeiou吗?如果换成aeiouy 呢?
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 def uses_all(word, muststr): for i in muststr: count = 0 index = 0 while index &amp;lt; len(word): if i == word[index]: break index += 1 if index == len(word): return False return True def count_word(file_in, als): count = 0 for line in file_in: word = line.</description></item><item><title>Think Python Exercise 9.4</title><link>https://o5o.me/post/think_python_exercise_9.4/</link><pubDate>Thu, 29 Dec 2022 15:30:12 +0800</pubDate><guid>https://o5o.me/post/think_python_exercise_9.4/</guid><description>编写一个名为 avoids 的函数，接受一个单词和一个指定禁止使用字符的字符串，如果单词中不包含任意被禁止的字符，则返回True 。
修改你的程序，提示用户输入一个禁止使用的字符，然后打印不包含这些字符的单词的数量。你能找到一个5个禁止使用字符的组合，使得其排除的单词数目最少么？
你能找到一个&amp;quot;5个禁止使用字符&amp;quot;的组合，使得其排除的单词数目最少么？ 分析：从26个字母中挑选5个字母构成一个组合，打印不包含这些字母的单词的数量，看哪个组合下被排除出去的单词数目最少。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 def avoids(word,ause): #ause，avoid use for i in ause: for letter in word: if letter == i: return False return True def has_no_string(file_in, nals): #nals指的是no alphabets，字母 count_nals = 0 #不含用户指定的各个字符的单词的个数 for line in file_in: word = line.strip() if avoids(word,nals): count_nals += 1 print(&amp;#34;不含&amp;#34;,nals,&amp;#34;的单词有&amp;#34;,count_nals,&amp;#34;个&amp;#34;) text = input(&amp;#34;请输入一个禁止使用的字符串，字符串里的字母都不会出现在单词中\n&amp;#34;) fin = open(&amp;#39;words.</description></item><item><title>Think Python Exercise 9.3</title><link>https://o5o.me/post/think_python_exercise_9.3/</link><pubDate>Thu, 29 Dec 2022 15:28:12 +0800</pubDate><guid>https://o5o.me/post/think_python_exercise_9.3/</guid><description>编写一个名为 avoids 的函数，接受一个单词和一个指定禁止使用字符的字符串，如果单词中不包含任意被禁止的字符，则返回True 。
修改你的程序，提示用户输入一个禁止使用的字符，然后打印不包含这些字符的单词的数量。你能找到一个5个禁止使用字符的组合，使得其排除的单词数目最少么？
你能找到一个&amp;quot;5个禁止使用字符&amp;quot;的组合，使得其排除的单词数目最少么？ 分析：从26个字母中挑选5个字母构成一个组合，打印不包含这些字母的单词的数量，看哪个组合下被排除出去的单词数目最少。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 def avoids(word,ause): #ause，avoid use for i in ause: for letter in word: if letter == i: return False return True def has_no_string(file_in, nals): #nals指的是no alphabets，字母 count_nals = 0 #不含用户指定的各个字符的单词的个数 for line in file_in: word = line.strip() if avoids(word,nals): count_nals += 1 print(&amp;#34;不含&amp;#34;,nals,&amp;#34;的单词有&amp;#34;,count_nals,&amp;#34;个&amp;#34;) text = input(&amp;#34;请输入一个禁止使用的字符串，字符串里的字母都不会出现在单词中\n&amp;#34;) fin = open(&amp;#39;words.</description></item><item><title>Think Python Exercise 9.2</title><link>https://o5o.me/post/think_python_exercise_9.2/</link><pubDate>Thu, 29 Dec 2022 15:27:12 +0800</pubDate><guid>https://o5o.me/post/think_python_exercise_9.2/</guid><description>1939年，Ernest Vincent Wright出版了一本名为 《Gadsby》 的小说，该小说里完全没有使用字符“e”。由于“e”是最常用的英文字符，因此这并不容易做到。
事实上，不使用这个最常用的符号(字符e)来构建一个孤立的想法是很难的。开始进展缓慢，但是经过有意识的、长时间的训练，你可以逐渐地熟练。
好啦，不再说题外话了（让我们开始编程练习）。
写一个叫做has_no_e的函数，如果给定的单词中不包含字符“e”，其返回 True 。
修改上一节中的程序，只打印不包含“e”的单词，并且计算列表中不含“e”单词的比例。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 fin = open(&amp;#39;words.txt&amp;#39;) def has_no_e(file_in): count_ne = 0 #不含e的单词的个数 count = 0 #总单词个数 for line in file_in: word = line.strip() index = 0 while index &amp;lt; len(word): if word[index] == &amp;#39;e&amp;#39;: break else: index = index + 1 if index == len(word): # print(word) #因为单词比较多，不一个个列出来了 count_ne = count_ne + 1 count = count + 1 print(&amp;#34;不含e的单词有&amp;#34;,count_ne,&amp;#34;个&amp;#34;,&amp;#34;单词一共有&amp;#34;,count,&amp;#34;个&amp;#34;,&amp;#34;不含“e”单词的比例为&amp;#34;,count_ne/count*100,&amp;#34;%&amp;#34;) has_no_e(fin) 上面是一个字母一个字母判断单词是不是包含‘e’的，下面是在 if 中使用 in 操作符简化后的方案：</description></item><item><title>Think Python Exercise 9.1</title><link>https://o5o.me/post/think_python_exercise_9.1/</link><pubDate>Wed, 28 Dec 2022 21:48:12 +0800</pubDate><guid>https://o5o.me/post/think_python_exercise_9.1/</guid><description>编程写一个程序，使得它可以读取 words.txt　，然后只打印出那些长度超过20个字符的单词(不包括空格)。
1 2 3 4 5 6 fin = open(&amp;#39;words.txt&amp;#39;) for line in fin: word = line.strip() if len(word) &amp;gt; 20: print(word)</description></item></channel></rss>